v8-version,11,3,244,8,-node.17,0
v8-platform,macos,macos
shared-library,/usr/local/bin/node,0x118231000,0x119b2886a,202473472
shared-library,/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation,0x7ff812236c40,0x7ff81240ece1,149737472
shared-library,/usr/lib/libobjc.A.dylib,0x7ff811e03640,0x7ff811e305c4,149737472
shared-library,/System/Library/PrivateFrameworks/CoreServicesInternal.framework/Versions/A/CoreServicesInternal,0x7ff8156d7a70,0x7ff815710ec0,149737472
shared-library,/System/Library/Frameworks/Foundation.framework/Versions/C/Foundation,0x7ff8131ef950,0x7ff813abc391,149737472
shared-library,/usr/lib/liboah.dylib,0x7ff81f04a230,0x7ff81f04fdca,149737472
shared-library,/usr/lib/libfakelink.dylib,0x7ff81f0813fa,0x7ff81f082b52,149737472
shared-library,/usr/lib/libicucore.A.dylib,0x7ff81513c680,0x7ff81535e9ac,149737472
shared-library,/usr/lib/libSystem.B.dylib,0x7ff81f07e725,0x7ff81f07ece2,149737472
shared-library,/System/Library/PrivateFrameworks/SoftLinking.framework/Versions/A/SoftLinking,0x7ff81f083c35,0x7ff81f083ebe,149737472
shared-library,/usr/lib/libc++abi.dylib,0x7ff81217fc70,0x7ff812190bbe,149737472
shared-library,/usr/lib/libc++.1.dylib,0x7ff812100cc0,0x7ff812153ef6,149737472
shared-library,/usr/lib/system/libcache.dylib,0x7ff81f07871c,0x7ff81f07b47c,149737472
shared-library,/usr/lib/system/libcommonCrypto.dylib,0x7ff81f0329d0,0x7ff81f03ce6c,149737472
shared-library,/usr/lib/system/libcompiler_rt.dylib,0x7ff81f05bddc,0x7ff81f060c45,149737472
shared-library,/usr/lib/system/libcopyfile.dylib,0x7ff81f0518d0,0x7ff81f059306,149737472
shared-library,/usr/lib/system/libcorecrypto.dylib,0x7ff811f445c0,0x7ff811fcb6d4,149737472
shared-library,/usr/lib/system/libdispatch.dylib,0x7ff81202bb40,0x7ff812060ffd,149737472
shared-library,/usr/lib/system/libdyld.dylib,0x7ff8121dc510,0x7ff8121fdc30,149737472
shared-library,/usr/lib/system/libkeymgr.dylib,0x7ff81f06dae7,0x7ff81f06df18,149737472
shared-library,/usr/lib/system/libmacho.dylib,0x7ff81f011468,0x7ff81f0158c7,149737472
shared-library,/usr/lib/system/libquarantine.dylib,0x7ff81e4a4e0a,0x7ff81e4a6cb0,149737472
shared-library,/usr/lib/system/libremovefile.dylib,0x7ff81f06b6d0,0x7ff81f06cd87,149737472
shared-library,/usr/lib/system/libsystem_asl.dylib,0x7ff8177ea2fc,0x7ff8177fe5e8,149737472
shared-library,/usr/lib/system/libsystem_blocks.dylib,0x7ff811ee2108,0x7ff811ee4490,149737472
shared-library,/usr/lib/system/libsystem_c.dylib,0x7ff812075640,0x7ff8120f41c8,149737472
shared-library,/usr/lib/system/libsystem_collections.dylib,0x7ff81f063ec2,0x7ff81f0679dc,149737472
shared-library,/usr/lib/system/libsystem_configuration.dylib,0x7ff81d5c2000,0x7ff81d5c48be,149737472
shared-library,/usr/lib/system/libsystem_containermanager.dylib,0x7ff81c6307dc,0x7ff81c650f39,149737472
shared-library,/usr/lib/system/libsystem_coreservices.dylib,0x7ff81ec6a610,0x7ff81ec6e2b0,149737472
shared-library,/usr/lib/system/libsystem_darwin.dylib,0x7ff8153d2160,0x7ff8153d933c,149737472
shared-library,/usr/lib/system/libsystem_darwindirectory.dylib,0x7ffc28f05bed,0x7ffc28f083dc,149737472
shared-library,/usr/lib/system/libsystem_dnssd.dylib,0x7ff81f06f5fc,0x7ff81f0751bd,149737472
shared-library,/usr/lib/system/libsystem_featureflags.dylib,0x7ff812071ec9,0x7ff812073bd0,149737472
shared-library,/usr/lib/system/libsystem_info.dylib,0x7ff81220ad50,0x7ff81223085b,149737472
shared-library,/usr/lib/system/libsystem_m.dylib,0x7ff81efa7200,0x7ff81efdd66c,149737472
shared-library,/usr/lib/system/libsystem_malloc.dylib,0x7ff811ff1b30,0x7ff81201e4f0,149737472
shared-library,/usr/lib/system/libsystem_networkextension.dylib,0x7ff81775fd96,0x7ff817772720,149737472
shared-library,/usr/lib/system/libsystem_notify.dylib,0x7ff81581bd24,0x7ff815829e66,149737472
shared-library,/usr/lib/system/libsystem_sandbox.dylib,0x7ff81d5c5d30,0x7ff81d5ca2ba,149737472
shared-library,/usr/lib/system/libsystem_secinit.dylib,0x7ff81f068edd,0x7ff81f06a44c,149737472
shared-library,/usr/lib/system/libsystem_kernel.dylib,0x7ff812195670,0x7ff8121be91c,149737472
shared-library,/usr/lib/system/libsystem_platform.dylib,0x7ff812200880,0x7ff812207553,149737472
shared-library,/usr/lib/system/libsystem_pthread.dylib,0x7ff8121cfbf0,0x7ff8121d8728,149737472
shared-library,/usr/lib/system/libsystem_symptoms.dylib,0x7ff819380dd6,0x7ff8193864ca,149737472
shared-library,/usr/lib/system/libsystem_trace.dylib,0x7ff811f2a400,0x7ff811f4001a,149737472
shared-library,/usr/lib/system/libunwind.dylib,0x7ff81f042e90,0x7ff81f04846a,149737472
shared-library,/usr/lib/system/libxpc.dylib,0x7ff811ee6610,0x7ff811f1823e,149737472
shared-library,/System/Library/Frameworks/IOKit.framework/Versions/A/IOKit,0x7ff815759730,0x7ff815801960,149737472
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/CoreServices,0x7ff826a1ffc0,0x7ff826a1ffc0,149737472
shared-library,/usr/lib/libDiagnosticMessagesClient.dylib,0x7ff819fe9f85,0x7ff819feac04,149737472
shared-library,/usr/lib/libenergytrace.dylib,0x7ff817777759,0x7ff817777d3e,149737472
shared-library,/usr/lib/libbsm.0.dylib,0x7ff81e4cbbd4,0x7ff81e4d8fed,149737472
shared-library,/usr/lib/libz.1.dylib,0x7ff81ef92960,0x7ff81ef9f184,149737472
shared-library,/usr/lib/system/libkxld.dylib,0x7ff81f01a240,0x7ff81f030de4,149737472
shared-library,/System/Library/Frameworks/CFNetwork.framework/Versions/A/CFNetwork,0x7ff8173b1da0,0x7ff81761c945,149737472
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/FSEvents.framework/Versions/A/FSEvents,0x7ff81ae10d40,0x7ff81ae1afa0,149737472
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/CarbonCore.framework/Versions/A/CarbonCore,0x7ff8153dd520,0x7ff8154c0c25,149737472
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/Metadata.framework/Versions/A/Metadata,0x7ff81a0326a0,0x7ff81a0b296c,149737472
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/OSServices.framework/Versions/A/OSServices,0x7ff81ec70960,0x7ff81ec95303,149737472
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/SearchKit.framework/Versions/A/SearchKit,0x7ff81f15bbb0,0x7ff81f1acdd0,149737472
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/AE.framework/Versions/A/AE,0x7ff819307a70,0x7ff8193665f0,149737472
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/LaunchServices.framework/Versions/A/LaunchServices,0x7ff8126d1740,0x7ff8128dea52,149737472
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/DictionaryServices.framework/Versions/A/DictionaryServices,0x7ff820634750,0x7ff8206747a8,149737472
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/SharedFileList.framework/Versions/A/SharedFileList,0x7ff81ae1eb68,0x7ff81ae3c17e,149737472
shared-library,/System/Library/Frameworks/Security.framework/Versions/A/Security,0x7ff814d9f910,0x7ff8150922b0,149737472
shared-library,/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/SystemConfiguration,0x7ff812ea6d20,0x7ff812f1dfd0,149737472
shared-library,/usr/lib/libapple_nghttp2.dylib,0x7ff81f1e6120,0x7ff81f1f83da,149737472
shared-library,/usr/lib/libcompression.dylib,0x7ff81f21c900,0x7ff81f27e494,149737472
shared-library,/usr/lib/libsqlite3.dylib,0x7ff818f810b0,0x7ff819129ed0,149737472
shared-library,/System/Library/Frameworks/Network.framework/Versions/A/Network,0x7ff81938a610,0x7ff819d4e74f,149737472
shared-library,/usr/lib/libCoreEntitlements.dylib,0x7ffc2757c480,0x7ffc2758767a,149737472
shared-library,/System/Library/PrivateFrameworks/MessageSecurity.framework/Versions/A/MessageSecurity,0x7ffb2fc3f1d0,0x7ffb2fc7ccfa,149737472
shared-library,/System/Library/PrivateFrameworks/ProtocolBuffer.framework/Versions/A/ProtocolBuffer,0x7ff818f67f30,0x7ff818f7b421,149737472
shared-library,/usr/lib/libMobileGestalt.dylib,0x7ff817779840,0x7ff8177cd4f8,149737472
shared-library,/System/Library/PrivateFrameworks/AppleFSCompression.framework/Versions/A/AppleFSCompression,0x7ff81eb8c9c0,0x7ff81ebe528a,149737472
shared-library,/usr/lib/libcoretls.dylib,0x7ff81e4b3b80,0x7ff81e4c640b,149737472
shared-library,/usr/lib/libcoretls_cfhelpers.dylib,0x7ff82069c0b4,0x7ff82069cdf2,149737472
shared-library,/usr/lib/libpam.2.dylib,0x7ff81f216c7c,0x7ff81f219e99,149737472
shared-library,/usr/lib/libxar.1.dylib,0x7ff820713b30,0x7ff82071fab4,149737472
shared-library,/System/Library/PrivateFrameworks/CoreAutoLayout.framework/Versions/A/CoreAutoLayout,0x7ff81ae498b0,0x7ff81ae7f13f,149737472
shared-library,/System/Library/Frameworks/DiskArbitration.framework/Versions/A/DiskArbitration,0x7ff81a0ca4f0,0x7ff81a0d0166,149737472
shared-library,/usr/lib/libarchive.2.dylib,0x7ff81f0d3540,0x7ff81f146a12,149737472
shared-library,/usr/lib/libxml2.2.dylib,0x7ff81ae919b0,0x7ff81af51847,149737472
shared-library,/usr/lib/liblangid.dylib,0x7ff81d5d23b7,0x7ff81d5d2d78,149737472
shared-library,/System/Library/Frameworks/Combine.framework/Versions/A/Combine,0x7ff82486a260,0x7ff824936620,149737472
shared-library,/System/Library/PrivateFrameworks/CollectionsInternal.framework/Versions/A/CollectionsInternal,0x7ffb1f515340,0x7ffb1f636070,149737472
shared-library,/System/Library/PrivateFrameworks/ReflectionInternal.framework/Versions/A/ReflectionInternal,0x7ffc142f90d0,0x7ffc142fda3a,149737472
shared-library,/System/Library/PrivateFrameworks/RuntimeInternal.framework/Versions/A/RuntimeInternal,0x7ffc14898660,0x7ffc148a71ab,149737472
shared-library,/usr/lib/swift/libswiftCore.dylib,0x7ff822466ab0,0x7ff82281cd24,149737472
shared-library,/usr/lib/swift/libswiftCoreFoundation.dylib,0x7ff9181bbb40,0x7ff9181c0190,149737472
shared-library,/usr/lib/swift/libswiftDarwin.dylib,0x7ff915ff3340,0x7ff915ff73aa,149737472
shared-library,/usr/lib/swift/libswiftDispatch.dylib,0x7ff82839cee0,0x7ff8283adb8e,149737472
shared-library,/usr/lib/swift/libswiftIOKit.dylib,0x7ff9181f9c70,0x7ff9181f9fab,149737472
shared-library,/usr/lib/swift/libswiftObjectiveC.dylib,0x7ff82ab24820,0x7ff82ab26180,149737472
shared-library,/usr/lib/swift/libswiftXPC.dylib,0x7ff9181cca10,0x7ff9181f135c,149737472
shared-library,/usr/lib/swift/libswift_Concurrency.dylib,0x7ffc28bea840,0x7ffc28c24d03,149737472
shared-library,/usr/lib/swift/libswift_StringProcessing.dylib,0x7ffc28d253b0,0x7ffc28d98ad8,149737472
shared-library,/usr/lib/swift/libswiftos.dylib,0x7ff82ab28490,0x7ff82ab3abf0,149737472
shared-library,/System/Library/PrivateFrameworks/AppleSystemInfo.framework/Versions/A/AppleSystemInfo,0x7ff81d5cd6eb,0x7ff81d5d0284,149737472
shared-library,/usr/lib/libpcap.A.dylib,0x7ff81f085460,0x7ff81f0a650a,149737472
shared-library,/usr/lib/libdns_services.dylib,0x7ff81937785f,0x7ff81937e0d8,149737472
shared-library,/usr/lib/libnetwork.dylib,0x7ff8173affc0,0x7ff8173affc0,149737472
shared-library,/System/Library/PrivateFrameworks/IOMobileFramebuffer.framework/Versions/A/IOMobileFramebuffer,0x7ff81e1cd6b0,0x7ff81e1d8ffe,149737472
shared-library,/System/Library/Frameworks/IOSurface.framework/Versions/A/IOSurface,0x7ff81c659710,0x7ff81c66906b,149737472
shared-library,/usr/lib/liblzma.5.dylib,0x7ff820682528,0x7ff8206947f7,149737472
shared-library,/usr/lib/swift/libswift_RegexParser.dylib,0x7ffc28c71030,0x7ffc28d08f6a,149737472
shared-library,/usr/lib/libbz2.1.0.dylib,0x7ff81ec5a710,0x7ff81ec67ec5,149737472
shared-library,/usr/lib/libiconv.2.dylib,0x7ff81f0bace0,0x7ff81f0c06e4,149737472
shared-library,/usr/lib/libcharset.1.dylib,0x7ff81f00de1c,0x7ff81f00de80,149737472
shared-library,/usr/lib/libheimdal-asn1.dylib,0x7ff820c06790,0x7ff820c0ecf9,149737472
shared-library,/usr/lib/libCheckFix.dylib,0x7ff81e4a9b10,0x7ff81e4af311,149737472
shared-library,/System/Library/PrivateFrameworks/TCC.framework/Versions/A/TCC,0x7ff817801648,0x7ff817818530,149737472
shared-library,/System/Library/PrivateFrameworks/CoreNLP.framework/Versions/A/CoreNLP,0x7ff81d5d4d60,0x7ff81d6b9290,149737472
shared-library,/System/Library/PrivateFrameworks/MetadataUtilities.framework/Versions/A/MetadataUtilities,0x7ff819fecc60,0x7ff81a024900,149737472
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Accelerate,0x7ff826d25000,0x7ff826d25000,149737472
shared-library,/usr/lib/libmecab.dylib,0x7ff81e4dc5c0,0x7ff81e5275e0,149737472
shared-library,/usr/lib/libCRFSuite.dylib,0x7ff812f2da00,0x7ff812f5d9b0,149737472
shared-library,/usr/lib/libgermantok.dylib,0x7ff81e534f90,0x7ff81e536dda,149737472
shared-library,/usr/lib/libThaiTokenizer.dylib,0x7ff81f1c1e90,0x7ff81f1c2e26,149737472
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vImage.framework/Versions/A/vImage,0x7ff81a0d1ee0,0x7ff81a6b99fa,149737472
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/vecLib,0x7ff8269f3000,0x7ff8269f3000,149737472
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libvMisc.dylib,0x7ff820755c40,0x7ff8208a3141,149737472
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libvDSP.dylib,0x7ff81dfbcde0,0x7ff81e18db3d,149737472
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib,0x7ff812ad72c0,0x7ff812d4512e,149737472
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libLAPACK.dylib,0x7ff81f2fcfc0,0x7ff820620fb7,149737472
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libLinearAlgebra.dylib,0x7ff81e537fe8,0x7ff81e54ae8d,149737472
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libSparseBLAS.dylib,0x7ff81f200c20,0x7ff81f213a08,149737472
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libQuadrature.dylib,0x7ff81f2f710a,0x7ff81f2fb11c,149737472
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBNNS.dylib,0x7ff81d6e28b0,0x7ff81df4441d,149737472
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libSparse.dylib,0x7ff812e2f8b0,0x7ff812ea0fe9,149737472
shared-library,/System/Library/PrivateFrameworks/MIL.framework/Versions/A/MIL,0x7ffb2e5c9b90,0x7ffb2e9e92a6,149737472
shared-library,/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Frameworks/CFOpenDirectory.framework/Versions/A/CFOpenDirectory,0x7ff81adf51a0,0x7ff81ae0889f,149737472
shared-library,/System/Library/Frameworks/OpenDirectory.framework/Versions/A/OpenDirectory,0x7ff81ade905c,0x7ff81adefaa2,149737472
shared-library,/System/Library/PrivateFrameworks/APFS.framework/Versions/A/APFS,0x7ff82069e0e0,0x7ff8206fa520,149737472
shared-library,/System/Library/Frameworks/SecurityFoundation.framework/Versions/A/SecurityFoundation,0x7ff81e3ee370,0x7ff81e432780,149737472
shared-library,/usr/lib/libutil.dylib,0x7ff820722564,0x7ff820724964,149737472
shared-library,/System/Library/PrivateFrameworks/InstalledContentLibrary.framework/Versions/A/InstalledContentLibrary,0x7ffb2ca18a50,0x7ffb2cacfa73,149737472
shared-library,/System/Library/PrivateFrameworks/CoreServicesStore.framework/Versions/A/CoreServicesStore,0x7ff8157193f0,0x7ff81574bb8a,149737472
shared-library,/usr/lib/libapp_launch_measurement.dylib,0x7ff81ae45b00,0x7ff81ae4778e,149737472
shared-library,/System/Library/PrivateFrameworks/AppleMobileFileIntegrity.framework/Versions/A/AppleMobileFileIntegrity,0x7ffb1d3f6854,0x7ffb1d401e47,149737472
shared-library,/usr/lib/libmis.dylib,0x7ff91819cc28,0x7ff9181a92d0,149737472
shared-library,/System/Library/PrivateFrameworks/MobileSystemServices.framework/Versions/A/MobileSystemServices,0x7ff9282c1250,0x7ff9282c3690,149737472
shared-library,/System/Library/PrivateFrameworks/ConfigProfileHelper.framework/Versions/A/ConfigProfileHelper,0x7ffa25cc783f,0x7ffa25cc8a86,149737472
shared-library,/System/Library/PrivateFrameworks/CoreAnalytics.framework/Versions/A/CoreAnalytics,0x7ff819fbeaf0,0x7ff819fe0851,149737472
shared-library,/System/Library/PrivateFrameworks/AppleSauce.framework/Versions/A/AppleSauce,0x7ff81f1c39c0,0x7ff81f1e1ec9,149737472
shared-library,/System/Library/PrivateFrameworks/LanguageModeling.framework/Versions/A/LanguageModeling,0x7ff813e26ce0,0x7ff813fab4d8,149737472
shared-library,/usr/lib/libxslt.1.dylib,0x7ff8207257d0,0x7ff8207461a8,149737472
shared-library,/usr/lib/libcmph.dylib,0x7ff81f0c1868,0x7ff81f0cfcee,149737472
shared-library,/System/Library/PrivateFrameworks/CoreEmoji.framework/Versions/A/CoreEmoji,0x7ff81e19c0b0,0x7ff81e1c2109,149737472
shared-library,/System/Library/PrivateFrameworks/LinguisticData.framework/Versions/A/LinguisticData,0x7ff81d6ddaa0,0x7ff81d6e10a5,149737472
shared-library,/System/Library/PrivateFrameworks/Lexicon.framework/Versions/A/Lexicon,0x7ff812d4bd30,0x7ff812e080c2,149737472
shared-library,/System/Library/PrivateFrameworks/BackgroundTaskManagement.framework/Versions/A/BackgroundTaskManagement,0x7ff81e477168,0x7ff81e491412,149737472
shared-library,/usr/lib/libTLE.dylib,0x7ffc276f7700,0x7ffc276feaf9,149737472
shared-library-end
profiler,begin,1000
tick,0x7ff8092c89aa,1534,0,0x0,6
new,CodeRange,0x112580000,0
new,MemoryChunk,0x31e641940000,262144
new,MemoryChunk,0x31e63cc40000,262144
new,MemoryChunk,0x31e633140000,262144
new,MemoryChunk,0x31e66f800000,262144
new,MemoryChunk,0x31e6ed800000,262144
heap-capacity,1030880
heap-available,4346312128
new,MemoryChunk,0x31e693180000,262144
tick,0x10c8f7870,2778,0,0x0,6
new,MemoryChunk,0x31e655840000,270336
new,MemoryChunk,0x31e647c40000,262144
new,MemoryChunk,0x31e647a80000,262144
tick,0x10ca25b7b,4063,0,0x0,6
new,MemoryChunk,0x31e6ea1c0000,262144
code-creation,Builtin,2,4800,0x10cd30ac0,768,DeoptimizationEntry_Eager
code-creation,Builtin,2,4819,0x10cd30e00,772,DeoptimizationEntry_Lazy
code-creation,Builtin,2,4826,0x10cd31140,2720,RecordWriteSaveFP
code-creation,Builtin,2,4832,0x10cd31c00,1180,RecordWriteIgnoreFP
code-creation,Builtin,2,4837,0x10cd320c0,332,EphemeronKeyBarrierSaveFP
code-creation,Builtin,2,4843,0x10cd32240,116,EphemeronKeyBarrierIgnoreFP
code-creation,Builtin,2,4848,0x10cd322c0,64,AdaptorWithBuiltinExitFrame
code-creation,Builtin,2,4854,0x10cd32340,288,CallFunction_ReceiverIsNullOrUndefined
code-creation,Builtin,2,4860,0x10cd32480,336,CallFunction_ReceiverIsNotNullOrUndefined
code-creation,Builtin,2,4867,0x10cd32600,372,CallFunction_ReceiverIsAny
code-creation,Builtin,2,4872,0x10cd32780,100,CallBoundFunction
code-creation,Builtin,2,4877,0x10cd32800,844,CallWrappedFunction
code-creation,Builtin,2,4882,0x10cd32b80,168,Call_ReceiverIsNullOrUndefined
code-creation,Builtin,2,4888,0x10cd32c40,168,Call_ReceiverIsNotNullOrUndefined
code-creation,Builtin,2,4893,0x10cd32d00,168,Call_ReceiverIsAny
code-creation,Builtin,2,4898,0x10cd32dc0,976,Call_ReceiverIsNullOrUndefined_Baseline_Compact
code-creation,Builtin,2,4904,0x10cd331c0,968,Call_ReceiverIsNullOrUndefined_Baseline
code-creation,Builtin,2,4910,0x10cd335c0,1040,Call_ReceiverIsNotNullOrUndefined_Baseline_Compact
code-creation,Builtin,2,4917,0x10cd33a00,1032,Call_ReceiverIsNotNullOrUndefined_Baseline
code-creation,Builtin,2,4923,0x10cd33e40,1040,Call_ReceiverIsAny_Baseline_Compact
code-creation,Builtin,2,4929,0x10cd34280,1032,Call_ReceiverIsAny_Baseline
code-creation,Builtin,2,4935,0x10cd346c0,924,Call_ReceiverIsNullOrUndefined_WithFeedback
code-creation,Builtin,2,4941,0x10cd34a80,924,Call_ReceiverIsNotNullOrUndefined_WithFeedback
code-creation,Builtin,2,4947,0x10cd34e40,924,Call_ReceiverIsAny_WithFeedback
code-creation,Builtin,2,4953,0x10cd35200,732,CallProxy
code-creation,Builtin,2,4957,0x10cd35500,152,CallVarargs
code-creation,Builtin,2,4962,0x10cd355c0,936,CallWithSpread
code-creation,Builtin,2,4967,0x10cd35980,1948,CallWithSpread_Baseline
code-creation,Builtin,2,4972,0x10cd36140,1908,CallWithSpread_WithFeedback
code-creation,Builtin,2,4977,0x10cd368c0,888,CallWithArrayLike
code-creation,Builtin,2,4982,0x10cd36c40,1828,CallWithArrayLike_WithFeedback
code-creation,Builtin,2,4987,0x10cd37380,156,CallForwardVarargs
code-creation,Builtin,2,4992,0x10cd37440,156,CallFunctionForwardVarargs
code-creation,Builtin,2,4998,0x10cd37500,128,CallFunctionTemplate_CheckAccess
code-creation,Builtin,2,5003,0x10cd375c0,232,CallFunctionTemplate_CheckCompatibleReceiver
code-creation,Builtin,2,5025,0x10cd376c0,320,CallFunctionTemplate_CheckAccessAndCompatibleReceiver
code-creation,Builtin,2,5032,0x10cd37840,32,ConstructFunction
code-creation,Builtin,2,5037,0x10cd37880,100,ConstructBoundFunction
code-creation,Builtin,2,5042,0x10cd37900,28,ConstructedNonConstructable
code-creation,Builtin,2,5048,0x10cd37940,100,Construct
code-creation,Builtin,2,5052,0x10cd379c0,152,ConstructVarargs
code-creation,Builtin,2,5057,0x10cd37a80,968,ConstructWithSpread
code-creation,Builtin,2,5062,0x10cd37e80,1764,ConstructWithSpread_Baseline
code-creation,Builtin,2,5067,0x10cd38580,1744,ConstructWithSpread_WithFeedback
code-creation,Builtin,2,5073,0x10cd38c80,952,ConstructWithArrayLike
code-creation,Builtin,2,5078,0x10cd39040,1684,ConstructWithArrayLike_WithFeedback
code-creation,Builtin,2,5084,0x10cd39700,196,ConstructForwardVarargs
code-creation,Builtin,2,5089,0x10cd39800,196,ConstructFunctionForwardVarargs
code-creation,Builtin,2,5094,0x10cd39900,776,Construct_Baseline
code-creation,Builtin,2,5099,0x10cd39c40,800,Construct_WithFeedback
code-creation,Builtin,2,5104,0x10cd39f80,444,JSConstructStubGeneric
code-creation,Builtin,2,5110,0x10cd3a140,340,JSBuiltinsConstructStub
code-creation,Builtin,2,5115,0x10cd3a2c0,772,FastNewObject
code-creation,Builtin,2,5119,0x10cd3a600,312,FastNewClosure
code-creation,Builtin,2,5124,0x10cd3a740,764,ConstructProxy
code-creation,Builtin,2,5129,0x10cd3aa40,192,JSEntry
code-creation,Builtin,2,5133,0x10cd3ab40,192,JSConstructEntry
code-creation,Builtin,2,5138,0x10cd3ac40,192,JSRunMicrotasksEntry
code-creation,Builtin,2,5143,0x10cd3ad40,100,JSEntryTrampoline
code-creation,Builtin,2,5148,0x10cd3adc0,100,JSConstructEntryTrampoline
code-creation,Builtin,2,5153,0x10cd3ae40,256,ResumeGeneratorTrampoline
code-creation,Builtin,2,5158,0x10cd3af80,1268,StringFromCodePointAt
code-creation,Builtin,2,5164,0x10cd3b480,708,StringEqual
code-creation,Builtin,2,5168,0x10cd3b780,328,StringGreaterThan
code-creation,Builtin,2,5173,0x10cd3b900,328,StringGreaterThanOrEqual
code-creation,Builtin,2,5178,0x10cd3ba80,328,StringLessThan
code-creation,Builtin,2,5194,0x10cd3bc00,328,StringLessThanOrEqual
code-creation,Builtin,2,5201,0x10cd3bd80,328,StringCompare
code-creation,Builtin,2,5209,0x10cd3bf00,2392,StringSubstring
code-creation,Builtin,2,5214,0x10cd3c880,80,OrderedHashTableHealIndex
code-creation,Builtin,2,5221,0x10cd3c900,876,InterpreterEntryTrampoline
code-creation,Builtin,2,5229,0x10cd3cc80,888,InterpreterEntryTrampolineForProfiling
code-creation,Builtin,2,5237,0x10cd3d000,76,InterpreterPushArgsThenCall
code-creation,Builtin,2,5243,0x10cd3d080,84,InterpreterPushUndefinedAndArgsThenCall
code-creation,Builtin,2,5250,0x10cd3d100,84,InterpreterPushArgsThenCallWithFinalSpread
code-creation,Builtin,2,5257,0x10cd3d180,84,InterpreterPushArgsThenConstruct
code-creation,Builtin,2,5262,0x10cd3d200,84,InterpreterPushArgsThenConstructArrayFunction
code-creation,Builtin,2,5268,0x10cd3d280,88,InterpreterPushArgsThenConstructWithFinalSpread
code-creation,Builtin,2,5275,0x10cd3d300,80,InterpreterEnterAtBytecode
code-creation,Builtin,2,5282,0x10cd3d380,216,InterpreterEnterAtNextBytecode
code-creation,Builtin,2,5289,0x10cd3d480,96,InterpreterOnStackReplacement
code-creation,Builtin,2,5295,0x10cd3d500,388,BaselineOutOfLinePrologue
code-creation,Builtin,2,5302,0x10cd3d6c0,16,BaselineOutOfLinePrologueDeopt
code-creation,Builtin,2,5308,0x10cd3d700,100,BaselineOnStackReplacement
code-creation,Builtin,2,5313,0x10cd3d780,84,BaselineLeaveFrame
code-creation,Builtin,2,5318,0x10cd3d800,208,BaselineOrInterpreterEnterAtBytecode
code-creation,Builtin,2,5324,0x10cd3d900,216,BaselineOrInterpreterEnterAtNextBytecode
code-creation,Builtin,2,5330,0x10cd3da00,184,InterpreterOnStackReplacement_ToBaseline
code-creation,Builtin,2,5336,0x10cd3dac0,36,MaglevOnStackReplacement
tick,0x7ff8092cbace,5348,0,0x0,6
code-creation,Builtin,2,5368,0x10cd3db00,860,CompileLazy
code-creation,Builtin,2,5378,0x10cd3de80,72,CompileLazyDeoptimizedCode
code-creation,Builtin,2,5385,0x10cd3df00,224,InstantiateAsmJs
code-creation,Builtin,2,5401,0x10cd3e000,32,NotifyDeoptimized
code-creation,Builtin,2,5407,0x10cd3e040,52,ContinueToCodeStubBuiltin
code-creation,Builtin,2,5412,0x10cd3e080,60,ContinueToCodeStubBuiltinWithResult
code-creation,Builtin,2,5418,0x10cd3e0c0,56,ContinueToJavaScriptBuiltin
code-creation,Builtin,2,5424,0x10cd3e100,64,ContinueToJavaScriptBuiltinWithResult
code-creation,Builtin,2,5430,0x10cd3e180,264,CallApiCallback
code-creation,Builtin,2,5435,0x10cd3e2c0,244,CallApiGetter
code-creation,Builtin,2,5440,0x10cd3e3c0,12,HandleApiCall
code-creation,Builtin,2,5445,0x10cd3e400,12,HandleApiCallAsFunction
code-creation,Builtin,2,5450,0x10cd3e440,12,HandleApiCallAsConstructor
code-creation,Builtin,2,5456,0x10cd3e480,64,AllocateInYoungGeneration
code-creation,Builtin,2,5462,0x10cd3e500,52,AllocateRegularInYoungGeneration
code-creation,Builtin,2,5468,0x10cd3e540,64,AllocateInOldGeneration
code-creation,Builtin,2,5473,0x10cd3e5c0,52,AllocateRegularInOldGeneration
code-creation,Builtin,2,5479,0x10cd3e600,144,NewHeapNumber
code-creation,Builtin,2,5484,0x10cd3e6c0,508,CopyFastSmiOrObjectElements
code-creation,Builtin,2,5490,0x10cd3e8c0,520,GrowFastDoubleElements
code-creation,Builtin,2,5495,0x10cd3eb00,420,GrowFastSmiOrObjectElements
code-creation,Builtin,2,5500,0x10cd3ecc0,444,DebugBreakTrampoline
code-creation,Builtin,2,5505,0x10cd3ee80,272,RestartFrameTrampoline
code-creation,Builtin,2,5510,0x10cd3efc0,188,ToNumber
code-creation,Builtin,2,5515,0x10cd3f080,88,ToBigInt
code-creation,Builtin,2,5519,0x10cd3f100,308,ToNumber_Baseline
code-creation,Builtin,2,5524,0x10cd3f240,372,ToNumeric_Baseline
code-creation,Builtin,2,5529,0x10cd3f3c0,104,PlainPrimitiveToNumber
code-creation,Builtin,2,5534,0x10cd3f440,224,ToNumberConvertBigInt
code-creation,Builtin,2,5540,0x10cd3f540,60,ToBigIntConvertNumber
code-creation,Builtin,2,5547,0x10cd3f580,140,Typeof
code-creation,Builtin,2,5551,0x10cd3f640,112,BigIntToI64
code-creation,Builtin,2,5556,0x10cd3f6c0,4,BigIntToI32Pair
code-creation,Builtin,2,5561,0x10cd3f700,220,I64ToBigInt
code-creation,Builtin,2,5565,0x10cd3f800,4,I32PairToBigInt
code-creation,Builtin,2,5570,0x10cd3f840,116,ToBooleanLazyDeoptContinuation
code-creation,Builtin,2,5576,0x10cd3f8c0,356,MathCeilContinuation
code-creation,Builtin,2,5581,0x10cd3fa40,364,MathFloorContinuation
code-creation,Builtin,2,5586,0x10cd3fbc0,408,MathRoundContinuation
code-creation,Builtin,2,5591,0x10cd3fd80,4468,KeyedLoadIC_PolymorphicName
code-creation,Builtin,2,5597,0x10cd40f00,16788,KeyedStoreIC_Megamorphic
code-creation,Builtin,2,5602,0x10cd450c0,13192,DefineKeyedOwnIC_Megamorphic
code-creation,Builtin,2,5607,0x10cd48480,604,LoadGlobalIC_NoFeedback
code-creation,Builtin,2,5613,0x10cd48700,68,LoadIC_FunctionPrototype
code-creation,Builtin,2,5618,0x10cd48780,12,LoadIC_StringLength
code-creation,Builtin,2,5623,0x10cd487c0,16,LoadIC_StringWrapperLength
code-creation,Builtin,2,5628,0x10cd48800,4444,LoadIC_NoFeedback
code-creation,Builtin,2,5633,0x10cd49980,32,StoreGlobalIC_Slow
code-creation,Builtin,2,5638,0x10cd499c0,7952,StoreIC_NoFeedback
code-creation,Builtin,2,5643,0x10cd4b900,4324,DefineNamedOwnIC_NoFeedback
code-creation,Builtin,2,5648,0x10cd4ca00,188,KeyedLoadIC_SloppyArguments
code-creation,Builtin,2,5654,0x10cd4cac0,72,LoadIndexedInterceptorIC
code-creation,Builtin,2,5659,0x10cd4cb40,248,KeyedStoreIC_SloppyArguments_Standard
code-creation,Builtin,2,5665,0x10cd4cc40,248,KeyedStoreIC_SloppyArguments_GrowNoTransitionHandleCOW
code-creation,Builtin,2,5672,0x10cd4cd40,248,KeyedStoreIC_SloppyArguments_NoTransitionIgnoreOOB
code-creation,Builtin,2,5678,0x10cd4ce40,248,KeyedStoreIC_SloppyArguments_NoTransitionHandleCOW
code-creation,Builtin,2,5685,0x10cd4cf40,14848,StoreFastElementIC_Standard
code-creation,Builtin,2,5690,0x10cd50980,10804,StoreFastElementIC_GrowNoTransitionHandleCOW
code-creation,Builtin,2,5697,0x10cd533c0,14108,StoreFastElementIC_NoTransitionIgnoreOOB
code-creation,Builtin,2,5703,0x10cd56b00,6500,StoreFastElementIC_NoTransitionHandleCOW
code-creation,Builtin,2,5709,0x10cd58480,8400,ElementsTransitionAndStore_Standard
code-creation,Builtin,2,5723,0x10cd5a580,19360,ElementsTransitionAndStore_GrowNoTransitionHandleCOW
code-creation,Builtin,2,5730,0x10cd5f140,8400,ElementsTransitionAndStore_NoTransitionIgnoreOOB
code-creation,Builtin,2,5736,0x10cd61240,11172,ElementsTransitionAndStore_NoTransitionHandleCOW
code-creation,Builtin,2,5742,0x10cd63e00,1116,KeyedHasIC_PolymorphicName
code-creation,Builtin,2,5748,0x10cd64280,172,KeyedHasIC_SloppyArguments
code-creation,Builtin,2,5753,0x10cd64340,72,HasIndexedInterceptorIC
code-creation,Builtin,2,5758,0x10cd643c0,160,EnqueueMicrotask
code-creation,Builtin,2,5763,0x10cd64480,8,RunMicrotasksTrampoline
code-creation,Builtin,2,5769,0x10cd644c0,3720,RunMicrotasks
code-creation,Builtin,2,5773,0x10cd65380,3456,HasProperty
code-creation,Builtin,2,5778,0x10cd66140,1316,DeleteProperty
code-creation,Builtin,2,5783,0x10cd66680,2596,CopyDataProperties
code-creation,Builtin,2,5788,0x10cd670c0,10776,SetDataProperties
code-creation,Builtin,2,5792,0x10cd69b00,3316,CopyDataPropertiesWithExcludedPropertiesOnStack
code-creation,Builtin,2,5799,0x10cd6a800,56,CopyDataPropertiesWithExcludedProperties
code-creation,Builtin,2,5805,0x10cd6a840,28,Abort
code-creation,Builtin,2,5809,0x10cd6a880,28,AbortCSADcheck
code-creation,Builtin,2,5814,0x10cd6a8c0,12,EmptyFunction
code-creation,Builtin,2,5819,0x10cd6a900,12,Illegal
code-creation,Builtin,2,5823,0x10cd6a940,12,StrictPoisonPillThrower
code-creation,Builtin,2,5829,0x10cd6a980,12,UnsupportedThrower
code-creation,Builtin,2,5834,0x10cd6a9c0,60,ReturnReceiver
code-creation,Builtin,2,5838,0x10cd6aa00,36,ArrayConstructor
code-creation,Builtin,2,5843,0x10cd6aa40,380,ArrayConstructorImpl
code-creation,Builtin,2,5848,0x10cd6abc0,220,ArrayNoArgumentConstructor_PackedSmi_DontOverride
code-creation,Builtin,2,5855,0x10cd6acc0,220,ArrayNoArgumentConstructor_HoleySmi_DontOverride
code-creation,Builtin,2,5861,0x10cd6adc0,184,ArrayNoArgumentConstructor_PackedSmi_DisableAllocationSites
code-creation,Builtin,2,5868,0x10cd6ae80,184,ArrayNoArgumentConstructor_HoleySmi_DisableAllocationSites
code-creation,Builtin,2,5875,0x10cd6af40,184,ArrayNoArgumentConstructor_Packed_DisableAllocationSites
code-creation,Builtin,2,5882,0x10cd6b000,184,ArrayNoArgumentConstructor_Holey_DisableAllocationSites
code-creation,Builtin,2,5888,0x10cd6b0c0,192,ArrayNoArgumentConstructor_PackedDouble_DisableAllocationSites
code-creation,Builtin,2,5896,0x10cd6b1c0,192,ArrayNoArgumentConstructor_HoleyDouble_DisableAllocationSites
code-creation,Builtin,2,5903,0x10cd6b2c0,272,ArraySingleArgumentConstructor_PackedSmi_DontOverride
code-creation,Builtin,2,5909,0x10cd6b400,476,ArraySingleArgumentConstructor_HoleySmi_DontOverride
code-creation,Builtin,2,5916,0x10cd6b600,228,ArraySingleArgumentConstructor_PackedSmi_DisableAllocationSites
code-creation,Builtin,2,5923,0x10cd6b700,404,ArraySingleArgumentConstructor_HoleySmi_DisableAllocationSites
code-creation,Builtin,2,5930,0x10cd6b8c0,228,ArraySingleArgumentConstructor_Packed_DisableAllocationSites
code-creation,Builtin,2,5937,0x10cd6b9c0,404,ArraySingleArgumentConstructor_Holey_DisableAllocationSites
code-creation,Builtin,2,5944,0x10cd6bb80,228,ArraySingleArgumentConstructor_PackedDouble_DisableAllocationSites
code-creation,Builtin,2,5951,0x10cd6bc80,408,ArraySingleArgumentConstructor_HoleyDouble_DisableAllocationSites
code-creation,Builtin,2,5958,0x10cd6be40,48,ArrayNArgumentsConstructor
code-creation,Builtin,2,5964,0x10cd6be80,12,ArrayConcat
code-creation,Builtin,2,5968,0x10cd6bec0,12,ArrayPrototypeFill
code-creation,Builtin,2,5973,0x10cd6bf00,1340,ArrayIncludesSmi
code-creation,Builtin,2,5978,0x10cd6c440,1220,ArrayIncludesSmiOrObject
code-creation,Builtin,2,5983,0x10cd6c940,276,ArrayIncludesPackedDoubles
code-creation,Builtin,2,5989,0x10cd6ca80,360,ArrayIncludesHoleyDoubles
code-creation,Builtin,2,5994,0x10cd6cc00,584,ArrayIncludes
code-creation,Builtin,2,5999,0x10cd6ce80,1256,ArrayIndexOfSmi
code-creation,Builtin,2,6004,0x10cd6d380,1140,ArrayIndexOfSmiOrObject
code-creation,Builtin,2,6009,0x10cd6d800,236,ArrayIndexOfPackedDoubles
code-creation,Builtin,2,6014,0x10cd6d900,236,ArrayIndexOfHoleyDoubles
code-creation,Builtin,2,6026,0x10cd6da00,584,ArrayIndexOf
code-creation,Builtin,2,6031,0x10cd6dc80,12,ArrayPop
code-creation,Builtin,2,6036,0x10cd6dcc0,568,ArrayPrototypePop
code-creation,Builtin,2,6040,0x10cd6df00,12,ArrayPrototypeGroup
code-creation,Builtin,2,6045,0x10cd6df40,12,ArrayPrototypeGroupToMap
code-creation,Builtin,2,6051,0x10cd6df80,12,ArrayPush
code-creation,Builtin,2,6055,0x10cd6dfc0,2416,ArrayPrototypePush
code-creation,Builtin,2,6060,0x10cd6e940,12,ArrayShift
code-creation,Builtin,2,6065,0x10cd6e980,12,ArrayUnshift
code-creation,Builtin,2,6070,0x10cd6e9c0,12,ArrayFromAsync
code-creation,Builtin,2,6074,0x10cd6ea00,1076,CloneFastJSArray
code-creation,Builtin,2,6079,0x10cd6ee40,2364,CloneFastJSArrayFillingHoles
code-creation,Builtin,2,6085,0x10cd6f780,1104,ExtractFastJSArray
code-creation,Builtin,2,6090,0x10cd6fc00,264,ArrayPrototypeEntries
code-creation,Builtin,2,6095,0x10cd6fd40,252,ArrayPrototypeKeys
code-creation,Builtin,2,6100,0x10cd6fe40,264,ArrayPrototypeValues
code-creation,Builtin,2,6105,0x10cd6ff80,4256,ArrayIteratorPrototypeNext
code-creation,Builtin,2,6110,0x10cd71040,4900,FlattenIntoArray
code-creation,Builtin,2,6115,0x10cd72380,4812,FlatMapIntoArray
code-creation,Builtin,2,6120,0x10cd73680,368,ArrayPrototypeFlat
code-creation,Builtin,2,6125,0x10cd73800,428,ArrayPrototypeFlatMap
code-creation,Builtin,2,6130,0x10cd739c0,12,ArrayBufferConstructor
code-creation,Builtin,2,6135,0x10cd73a00,12,ArrayBufferConstructor_DoNotInitialize
code-creation,Builtin,2,6141,0x10cd73a40,12,ArrayBufferPrototypeSlice
code-creation,Builtin,2,6146,0x10cd73a80,12,ArrayBufferPrototypeResize
code-creation,Builtin,2,6152,0x10cd73ac0,12,ArrayBufferPrototypeTransfer
code-creation,Builtin,2,6157,0x10cd73b00,12,ArrayBufferPrototypeTransferToFixedLength
code-creation,Builtin,2,6163,0x10cd73b40,964,AsyncFunctionEnter
code-creation,Builtin,2,6168,0x10cd73f40,80,AsyncFunctionReject
code-creation,Builtin,2,6173,0x10cd73fc0,76,AsyncFunctionResolve
code-creation,Builtin,2,6178,0x10cd74040,12,AsyncFunctionLazyDeoptContinuation
code-creation,Builtin,2,6184,0x10cd74080,1564,AsyncFunctionAwaitCaught
code-creation,Builtin,2,6189,0x10cd746c0,1564,AsyncFunctionAwaitUncaught
code-creation,Builtin,2,6195,0x10cd74d00,172,AsyncFunctionAwaitRejectClosure
code-creation,Builtin,2,6200,0x10cd74dc0,168,AsyncFunctionAwaitResolveClosure
code-creation,Builtin,2,6206,0x10cd74e80,12,BigIntConstructor
code-creation,Builtin,2,6211,0x10cd74ec0,12,BigIntAsUintN
code-creation,Builtin,2,6216,0x10cd74f00,12,BigIntAsIntN
code-creation,Builtin,2,6220,0x10cd74f40,12,BigIntPrototypeToLocaleString
code-creation,Builtin,2,6226,0x10cd74f80,12,BigIntPrototypeToString
code-creation,Builtin,2,6231,0x10cd74fc0,12,BigIntPrototypeValueOf
code-creation,Builtin,2,6236,0x10cd75000,12,CallSitePrototypeGetColumnNumber
code-creation,Builtin,2,6242,0x10cd75040,12,CallSitePrototypeGetEnclosingColumnNumber
code-creation,Builtin,2,6248,0x10cd75080,12,CallSitePrototypeGetEnclosingLineNumber
code-creation,Builtin,2,6254,0x10cd750c0,12,CallSitePrototypeGetEvalOrigin
code-creation,Builtin,2,6259,0x10cd75100,12,CallSitePrototypeGetFileName
code-creation,Builtin,2,6265,0x10cd75140,12,CallSitePrototypeGetFunction
code-creation,Builtin,2,6270,0x10cd75180,12,CallSitePrototypeGetFunctionName
code-creation,Builtin,2,6276,0x10cd751c0,12,CallSitePrototypeGetLineNumber
code-creation,Builtin,2,6281,0x10cd75200,12,CallSitePrototypeGetMethodName
code-creation,Builtin,2,6287,0x10cd75240,12,CallSitePrototypeGetPosition
code-creation,Builtin,2,6292,0x10cd75280,12,CallSitePrototypeGetPromiseIndex
code-creation,Builtin,2,6298,0x10cd752c0,12,CallSitePrototypeGetScriptHash
code-creation,Builtin,2,6304,0x10cd75300,12,CallSitePrototypeGetScriptNameOrSourceURL
code-creation,Builtin,2,6310,0x10cd75340,12,CallSitePrototypeGetThis
code-creation,Builtin,2,6315,0x10cd75380,12,CallSitePrototypeGetTypeName
code-creation,Builtin,2,6321,0x10cd753c0,12,CallSitePrototypeIsAsync
code-creation,Builtin,2,6326,0x10cd75400,12,CallSitePrototypeIsConstructor
code-creation,Builtin,2,6333,0x10cd75440,12,CallSitePrototypeIsEval
code-creation,Builtin,2,6345,0x10cd75480,12,CallSitePrototypeIsNative
code-creation,Builtin,2,6351,0x10cd754c0,12,CallSitePrototypeIsPromiseAll
code-creation,Builtin,2,6356,0x10cd75500,12,CallSitePrototypeIsToplevel
code-creation,Builtin,2,6362,0x10cd75540,12,CallSitePrototypeToString
code-creation,Builtin,2,6367,0x10cd75580,12,ConsoleDebug
code-creation,Builtin,2,6372,0x10cd755c0,12,ConsoleError
code-creation,Builtin,2,6376,0x10cd75600,12,ConsoleInfo
code-creation,Builtin,2,6381,0x10cd75640,12,ConsoleLog
code-creation,Builtin,2,6386,0x10cd75680,12,ConsoleWarn
code-creation,Builtin,2,6390,0x10cd756c0,12,ConsoleDir
code-creation,Builtin,2,6395,0x10cd75700,12,ConsoleDirXml
code-creation,Builtin,2,6399,0x10cd75740,12,ConsoleTable
code-creation,Builtin,2,6404,0x10cd75780,12,ConsoleTrace
code-creation,Builtin,2,6409,0x10cd757c0,12,ConsoleGroup
code-creation,Builtin,2,6413,0x10cd75800,12,ConsoleGroupCollapsed
code-creation,Builtin,2,6419,0x10cd75840,12,ConsoleGroupEnd
code-creation,Builtin,2,6423,0x10cd75880,12,ConsoleClear
code-creation,Builtin,2,6428,0x10cd758c0,12,ConsoleCount
code-creation,Builtin,2,6433,0x10cd75900,12,ConsoleCountReset
code-creation,Builtin,2,6437,0x10cd75940,12,ConsoleAssert
code-creation,Builtin,2,6442,0x10cd75980,12,ConsoleProfile
code-creation,Builtin,2,6447,0x10cd759c0,12,ConsoleProfileEnd
code-creation,Builtin,2,6452,0x10cd75a00,12,ConsoleTime
code-creation,Builtin,2,6457,0x10cd75a40,12,ConsoleTimeLog
code-creation,Builtin,2,6461,0x10cd75a80,12,ConsoleTimeEnd
code-creation,Builtin,2,6466,0x10cd75ac0,12,ConsoleTimeStamp
code-creation,Builtin,2,6482,0x10cd75b00,12,ConsoleContext
code-creation,Builtin,2,6488,0x10cd75b40,12,DataViewConstructor
code-creation,Builtin,2,6493,0x10cd75b80,12,DateConstructor
code-creation,Builtin,2,6498,0x10cd75bc0,220,DatePrototypeGetDate
code-creation,Builtin,2,6503,0x10cd75cc0,220,DatePrototypeGetDay
code-creation,Builtin,2,6508,0x10cd75dc0,220,DatePrototypeGetFullYear
code-creation,Builtin,2,6514,0x10cd75ec0,220,DatePrototypeGetHours
code-creation,Builtin,2,6521,0x10cd75fc0,204,DatePrototypeGetMilliseconds
code-creation,Builtin,2,6529,0x10cd760c0,220,DatePrototypeGetMinutes
code-creation,Builtin,2,6535,0x10cd761c0,220,DatePrototypeGetMonth
code-creation,Builtin,2,6541,0x10cd762c0,220,DatePrototypeGetSeconds
code-creation,Builtin,2,6546,0x10cd763c0,128,DatePrototypeGetTime
code-creation,Builtin,2,6551,0x10cd76480,204,DatePrototypeGetTimezoneOffset
code-creation,Builtin,2,6557,0x10cd76580,204,DatePrototypeGetUTCDate
code-creation,Builtin,2,6562,0x10cd76680,204,DatePrototypeGetUTCDay
code-creation,Builtin,2,6567,0x10cd76780,204,DatePrototypeGetUTCFullYear
code-creation,Builtin,2,6573,0x10cd76880,204,DatePrototypeGetUTCHours
code-creation,Builtin,2,6578,0x10cd76980,204,DatePrototypeGetUTCMilliseconds
code-creation,Builtin,2,6583,0x10cd76a80,204,DatePrototypeGetUTCMinutes
code-creation,Builtin,2,6590,0x10cd76b80,204,DatePrototypeGetUTCMonth
code-creation,Builtin,2,6596,0x10cd76c80,204,DatePrototypeGetUTCSeconds
code-creation,Builtin,2,6602,0x10cd76d80,128,DatePrototypeValueOf
code-creation,Builtin,2,6609,0x10cd76e40,436,DatePrototypeToPrimitive
code-creation,Builtin,2,6616,0x10cd77000,12,DatePrototypeGetYear
code-creation,Builtin,2,6622,0x10cd77040,12,DatePrototypeSetYear
code-creation,Builtin,2,6628,0x10cd77080,12,DateNow
code-creation,Builtin,2,6633,0x10cd770c0,12,DateParse
code-creation,Builtin,2,6637,0x10cd77100,12,DatePrototypeSetDate
code-creation,Builtin,2,6642,0x10cd77140,12,DatePrototypeSetFullYear
code-creation,Builtin,2,6649,0x10cd77180,12,DatePrototypeSetHours
code-creation,Builtin,2,6656,0x10cd771c0,12,DatePrototypeSetMilliseconds
code-creation,Builtin,2,6663,0x10cd77200,12,DatePrototypeSetMinutes
code-creation,Builtin,2,6669,0x10cd77240,12,DatePrototypeSetMonth
code-creation,Builtin,2,6674,0x10cd77280,12,DatePrototypeSetSeconds
code-creation,Builtin,2,6681,0x10cd772c0,12,DatePrototypeSetTime
code-creation,Builtin,2,6687,0x10cd77300,12,DatePrototypeSetUTCDate
code-creation,Builtin,2,6693,0x10cd77340,12,DatePrototypeSetUTCFullYear
code-creation,Builtin,2,6706,0x10cd77380,12,DatePrototypeSetUTCHours
code-creation,Builtin,2,6712,0x10cd773c0,12,DatePrototypeSetUTCMilliseconds
code-creation,Builtin,2,6718,0x10cd77400,12,DatePrototypeSetUTCMinutes
code-creation,Builtin,2,6723,0x10cd77440,12,DatePrototypeSetUTCMonth
code-creation,Builtin,2,6729,0x10cd77480,12,DatePrototypeSetUTCSeconds
code-creation,Builtin,2,6734,0x10cd774c0,12,DatePrototypeToDateString
code-creation,Builtin,2,6739,0x10cd77500,12,DatePrototypeToISOString
code-creation,Builtin,2,6746,0x10cd77540,12,DatePrototypeToUTCString
code-creation,Builtin,2,6753,0x10cd77580,12,DatePrototypeToString
code-creation,Builtin,2,6762,0x10cd775c0,12,DatePrototypeToTimeString
code-creation,Builtin,2,6769,0x10cd77600,12,DatePrototypeToJson
code-creation,Builtin,2,6774,0x10cd77640,12,DateUTC
code-creation,Builtin,2,6778,0x10cd77680,12,ErrorConstructor
code-creation,Builtin,2,6783,0x10cd776c0,12,ErrorCaptureStackTrace
code-creation,Builtin,2,6788,0x10cd77700,12,ErrorPrototypeToString
code-creation,Builtin,2,6794,0x10cd77740,12,FunctionConstructor
code-creation,Builtin,2,6799,0x10cd77780,80,FunctionPrototypeApply
code-creation,Builtin,2,6804,0x10cd77800,12,FunctionPrototypeBind
code-creation,Builtin,2,6809,0x10cd77840,36,FunctionPrototypeCall
code-creation,Builtin,2,6814,0x10cd77880,12,FunctionPrototypeToString
code-creation,Builtin,2,6821,0x10cd778c0,212,CreateIterResultObject
code-creation,Builtin,2,6827,0x10cd779c0,916,CreateGeneratorObject
code-creation,Builtin,2,6834,0x10cd77d80,12,GeneratorFunctionConstructor
code-creation,Builtin,2,6842,0x10cd77dc0,404,GeneratorPrototypeNext
code-creation,Builtin,2,6849,0x10cd77f80,404,GeneratorPrototypeReturn
code-creation,Builtin,2,6856,0x10cd78140,408,GeneratorPrototypeThrow
code-creation,Builtin,2,6861,0x10cd78300,12,AsyncFunctionConstructor
code-creation,Builtin,2,6867,0x10cd78340,376,SuspendGeneratorBaseline
code-creation,Builtin,2,6872,0x10cd784c0,96,ResumeGeneratorBaseline
code-creation,Builtin,2,6877,0x10cd78540,36,GetIteratorWithFeedbackLazyDeoptContinuation
code-creation,Builtin,2,6883,0x10cd78580,84,CallIteratorWithFeedbackLazyDeoptContinuation
code-creation,Builtin,2,6890,0x10cd78600,12,GlobalDecodeURI
code-creation,Builtin,2,6896,0x10cd78640,12,GlobalDecodeURIComponent
code-creation,Builtin,2,6902,0x10cd78680,12,GlobalEncodeURI
code-creation,Builtin,2,6908,0x10cd786c0,12,GlobalEncodeURIComponent
code-creation,Builtin,2,6915,0x10cd78700,12,GlobalEscape
code-creation,Builtin,2,6922,0x10cd78740,12,GlobalUnescape
code-creation,Builtin,2,6927,0x10cd78780,12,GlobalEval
code-creation,Builtin,2,6933,0x10cd787c0,136,GlobalIsFinite
code-creation,Builtin,2,6938,0x10cd78880,132,GlobalIsNaN
code-creation,Builtin,2,6942,0x10cd78940,12,JsonParse
code-creation,Builtin,2,6947,0x10cd78980,12,JsonStringify
code-creation,Builtin,2,6951,0x10cd789c0,12,JsonRawJson
code-creation,Builtin,2,6956,0x10cd78a00,12,JsonIsRawJson
code-creation,Builtin,2,6961,0x10cd78a40,5064,LoadIC
code-creation,Builtin,2,6965,0x10cd79e40,4696,LoadIC_Megamorphic
code-creation,Builtin,2,6970,0x10cd7b0c0,4908,LoadIC_Noninlined
code-creation,Builtin,2,6977,0x10cd7c400,44,LoadICTrampoline
code-creation,Builtin,2,6983,0x10cd7c440,24,LoadICBaseline
code-creation,Builtin,2,6988,0x10cd7c480,44,LoadICTrampoline_Megamorphic
code-creation,Builtin,2,6995,0x10cd7c4c0,8832,LoadSuperIC
code-creation,Builtin,2,7000,0x10cd7e780,24,LoadSuperICBaseline
code-creation,Builtin,2,7005,0x10cd7e7c0,8196,KeyedLoadIC
code-creation,Builtin,2,7009,0x10cd80800,16176,KeyedLoadIC_Megamorphic
code-creation,Builtin,2,7015,0x10cd84740,13232,KeyedLoadIC_MegamorphicStringKey
code-creation,Builtin,2,7020,0x10cd87b00,44,KeyedLoadICTrampoline
code-creation,Builtin,2,7025,0x10cd87b40,24,KeyedLoadICBaseline
code-creation,Builtin,2,7030,0x10cd87b80,44,KeyedLoadICTrampoline_Megamorphic
code-creation,Builtin,2,7038,0x10cd87bc0,44,KeyedLoadICTrampoline_MegamorphicStringKey
code-creation,Builtin,2,7046,0x10cd87c00,5408,StoreGlobalIC
code-creation,Builtin,2,7051,0x10cd89140,44,StoreGlobalICTrampoline
code-creation,Builtin,2,7056,0x10cd89180,24,StoreGlobalICBaseline
code-creation,Builtin,2,7068,0x10cd891c0,5924,StoreIC
code-creation,Builtin,2,7073,0x10cd8a900,44,StoreICTrampoline
code-creation,Builtin,2,7078,0x10cd8a940,24,StoreICBaseline
code-creation,Builtin,2,7083,0x10cd8a980,5720,DefineNamedOwnIC
code-creation,Builtin,2,7088,0x10cd8c000,44,DefineNamedOwnICTrampoline
code-creation,Builtin,2,7093,0x10cd8c040,24,DefineNamedOwnICBaseline
code-creation,Builtin,2,7100,0x10cd8c080,6388,KeyedStoreIC
code-creation,Builtin,2,7105,0x10cd8d980,44,KeyedStoreICTrampoline
code-creation,Builtin,2,7112,0x10cd8d9c0,24,KeyedStoreICBaseline
code-creation,Builtin,2,7119,0x10cd8da00,6328,DefineKeyedOwnIC
code-creation,Builtin,2,7126,0x10cd8f2c0,52,DefineKeyedOwnICTrampoline
code-creation,Builtin,2,7131,0x10cd8f300,28,DefineKeyedOwnICBaseline
code-creation,Builtin,2,7136,0x10cd8f340,320,StoreInArrayLiteralIC
code-creation,Builtin,2,7141,0x10cd8f4c0,24,StoreInArrayLiteralICBaseline
code-creation,Builtin,2,7147,0x10cd8f500,144,LookupContextTrampoline
code-creation,Builtin,2,7152,0x10cd8f5c0,156,LookupContextBaseline
code-creation,Builtin,2,7157,0x10cd8f680,144,LookupContextInsideTypeofTrampoline
code-creation,Builtin,2,7163,0x10cd8f740,156,LookupContextInsideTypeofBaseline
code-creation,Builtin,2,7170,0x10cd8f800,3236,LoadGlobalIC
code-creation,Builtin,2,7175,0x10cd904c0,3216,LoadGlobalICInsideTypeof
code-creation,Builtin,2,7182,0x10cd91180,44,LoadGlobalICTrampoline
code-creation,Builtin,2,7187,0x10cd911c0,24,LoadGlobalICBaseline
code-creation,Builtin,2,7192,0x10cd91200,44,LoadGlobalICInsideTypeofTrampoline
code-creation,Builtin,2,7198,0x10cd91240,24,LoadGlobalICInsideTypeofBaseline
code-creation,Builtin,2,7203,0x10cd91280,140,LookupGlobalIC
code-creation,Builtin,2,7208,0x10cd91340,176,LookupGlobalICTrampoline
code-creation,Builtin,2,7213,0x10cd91400,160,LookupGlobalICBaseline
code-creation,Builtin,2,7219,0x10cd914c0,140,LookupGlobalICInsideTypeof
code-creation,Builtin,2,7226,0x10cd91580,176,LookupGlobalICInsideTypeofTrampoline
code-creation,Builtin,2,7233,0x10cd91640,160,LookupGlobalICInsideTypeofBaseline
code-creation,Builtin,2,7241,0x10cd91700,2664,CloneObjectIC
code-creation,Builtin,2,7247,0x10cd92180,24,CloneObjectICBaseline
code-creation,Builtin,2,7256,0x10cd921c0,2696,CloneObjectIC_Slow
code-creation,Builtin,2,7262,0x10cd92c80,3076,KeyedHasIC
code-creation,Builtin,2,7267,0x10cd938c0,24,KeyedHasICBaseline
code-creation,Builtin,2,7272,0x10cd93900,3456,KeyedHasIC_Megamorphic
code-creation,Builtin,2,7277,0x10cd946c0,1708,IterableToList
code-creation,Builtin,2,7282,0x10cd94d80,1528,IterableToFixedArray
code-creation,Builtin,2,7287,0x10cd95380,728,IterableToListWithSymbolLookup
code-creation,Builtin,2,7292,0x10cd95680,56,IterableToFixedArrayWithSymbolLookupSlow
code-creation,Builtin,2,7299,0x10cd956c0,112,IterableToListMayPreserveHoles
code-creation,Builtin,2,7306,0x10cd95740,1228,IterableToFixedArrayForWasm
code-creation,Builtin,2,7312,0x10cd95c40,1660,StringListFromIterable
code-creation,Builtin,2,7317,0x10cd962c0,1132,FindOrderedHashMapEntry
code-creation,Builtin,2,7322,0x10cd96740,4292,MapConstructor
code-creation,Builtin,2,7327,0x10cd97840,1852,MapPrototypeSet
code-creation,Builtin,2,7332,0x10cd97f80,1472,MapPrototypeDelete
code-creation,Builtin,2,7337,0x10cd98580,212,MapPrototypeGet
code-creation,Builtin,2,7342,0x10cd98680,172,MapPrototypeHas
code-creation,Builtin,2,7346,0x10cd98740,12,MapPrototypeClear
code-creation,Builtin,2,7351,0x10cd98780,288,MapPrototypeEntries
code-creation,Builtin,2,7358,0x10cd988c0,144,MapPrototypeGetSize
code-creation,Builtin,2,7365,0x10cd98980,488,MapPrototypeForEach
code-creation,Builtin,2,7372,0x10cd98b80,288,MapPrototypeKeys
code-creation,Builtin,2,7378,0x10cd98cc0,288,MapPrototypeValues
code-creation,Builtin,2,7385,0x10cd98e00,916,MapIteratorPrototypeNext
code-creation,Builtin,2,7392,0x10cd991c0,1180,MapIteratorToList
code-creation,Builtin,2,7399,0x10cd99680,12,NumberPrototypeToExponential
code-creation,Builtin,2,7406,0x10cd996c0,12,NumberPrototypeToFixed
code-creation,Builtin,2,7413,0x10cd99700,12,NumberPrototypeToLocaleString
code-creation,Builtin,2,7421,0x10cd99740,12,NumberPrototypeToPrecision
code-creation,Builtin,2,7434,0x10cd99780,356,SameValue
code-creation,Builtin,2,7441,0x10cd99900,200,SameValueNumbersOnly
code-creation,Builtin,2,7448,0x10cd99a00,1368,Add_Baseline
code-creation,Builtin,2,7455,0x10cd99f80,1072,AddSmi_Baseline
code-creation,Builtin,2,7463,0x10cd9a3c0,1340,Subtract_Baseline
code-creation,Builtin,2,7470,0x10cd9a900,1076,SubtractSmi_Baseline
code-creation,Builtin,2,7477,0x10cd9ad40,1436,Multiply_Baseline
code-creation,Builtin,2,7482,0x10cd9b300,1164,MultiplySmi_Baseline
code-creation,Builtin,2,7489,0x10cd9b7c0,1532,Divide_Baseline
code-creation,Builtin,2,7503,0x10cd9bdc0,1304,DivideSmi_Baseline
code-creation,Builtin,2,7508,0x10cd9c300,1472,Modulus_Baseline
code-creation,Builtin,2,7513,0x10cd9c900,1188,ModulusSmi_Baseline
code-creation,Builtin,2,7520,0x10cd9cdc0,808,Exponentiate_Baseline
code-creation,Builtin,2,7526,0x10cd9d100,704,ExponentiateSmi_Baseline
code-creation,Builtin,2,7534,0x10cd9d400,1520,BitwiseAnd_Baseline
code-creation,Builtin,2,7541,0x10cd9da00,368,BitwiseAndSmi_Baseline
code-creation,Builtin,2,7546,0x10cd9db80,1520,BitwiseOr_Baseline
code-creation,Builtin,2,7553,0x10cd9e180,368,BitwiseOrSmi_Baseline
code-creation,Builtin,2,7560,0x10cd9e300,1524,BitwiseXor_Baseline
code-creation,Builtin,2,7565,0x10cd9e900,368,BitwiseXorSmi_Baseline
code-creation,Builtin,2,7571,0x10cd9ea80,976,ShiftLeft_Baseline
code-creation,Builtin,2,7576,0x10cd9ee80,392,ShiftLeftSmi_Baseline
code-creation,Builtin,2,7582,0x10cd9f040,976,ShiftRight_Baseline
code-creation,Builtin,2,7588,0x10cd9f440,376,ShiftRightSmi_Baseline
code-creation,Builtin,2,7594,0x10cd9f5c0,1096,ShiftRightLogical_Baseline
code-creation,Builtin,2,7600,0x10cd9fa40,632,ShiftRightLogicalSmi_Baseline
code-creation,Builtin,2,7606,0x10cd9fcc0,1304,Add_WithFeedback
code-creation,Builtin,2,7611,0x10cda0200,1288,Subtract_WithFeedback
code-creation,Builtin,2,7618,0x10cda0740,1380,Multiply_WithFeedback
code-creation,Builtin,2,7624,0x10cda0cc0,1488,Divide_WithFeedback
tick,0x7ff8092cbace,7633,0,0x0,6
tick,0x7ff809303aa9,7649,0,0x0,6
code-creation,Builtin,2,7658,0x10cda12c0,1408,Modulus_WithFeedback
code-creation,Builtin,2,7665,0x10cda1880,768,Exponentiate_WithFeedback
code-creation,Builtin,2,7671,0x10cda1bc0,1464,BitwiseAnd_WithFeedback
code-creation,Builtin,2,7676,0x10cda2180,1464,BitwiseOr_WithFeedback
code-creation,Builtin,2,7682,0x10cda2740,1464,BitwiseXor_WithFeedback
code-creation,Builtin,2,7687,0x10cda2d00,928,ShiftLeft_WithFeedback
code-creation,Builtin,2,7692,0x10cda30c0,928,ShiftRight_WithFeedback
code-creation,Builtin,2,7697,0x10cda3480,1040,ShiftRightLogical_WithFeedback
code-creation,Builtin,2,7703,0x10cda38c0,1968,Equal_Baseline
code-creation,Builtin,2,7708,0x10cda4080,1188,StrictEqual_Baseline
code-creation,Builtin,2,7713,0x10cda4540,1440,LessThan_Baseline
code-creation,Builtin,2,7718,0x10cda4b00,1440,GreaterThan_Baseline
code-creation,Builtin,2,7723,0x10cda50c0,1440,LessThanOrEqual_Baseline
code-creation,Builtin,2,7728,0x10cda5680,1440,GreaterThanOrEqual_Baseline
code-creation,Builtin,2,7734,0x10cda5c40,1868,Equal_WithFeedback
code-creation,Builtin,2,7739,0x10cda63c0,1188,StrictEqual_WithFeedback
code-creation,Builtin,2,7744,0x10cda6880,1428,LessThan_WithFeedback
code-creation,Builtin,2,7749,0x10cda6e40,1428,GreaterThan_WithFeedback
code-creation,Builtin,2,7754,0x10cda7400,1428,LessThanOrEqual_WithFeedback
code-creation,Builtin,2,7760,0x10cda79c0,1428,GreaterThanOrEqual_WithFeedback
code-creation,Builtin,2,7766,0x10cda7f80,360,BitwiseNot_Baseline
code-creation,Builtin,2,7771,0x10cda8100,456,Decrement_Baseline
code-creation,Builtin,2,7776,0x10cda8300,460,Increment_Baseline
code-creation,Builtin,2,7781,0x10cda8500,488,Negate_Baseline
code-creation,Builtin,2,7786,0x10cda8700,348,BitwiseNot_WithFeedback
code-creation,Builtin,2,7791,0x10cda8880,440,Decrement_WithFeedback
code-creation,Builtin,2,7796,0x10cda8a40,444,Increment_WithFeedback
code-creation,Builtin,2,7801,0x10cda8c00,468,Negate_WithFeedback
code-creation,Builtin,2,7806,0x10cda8e00,256,ObjectAssign
code-creation,Builtin,2,7811,0x10cda8f40,932,ObjectCreate
code-creation,Builtin,2,7825,0x10cda9300,12,ObjectDefineGetter
code-creation,Builtin,2,7831,0x10cda9340,12,ObjectDefineProperties
code-creation,Builtin,2,7836,0x10cda9380,12,ObjectDefineProperty
code-creation,Builtin,2,7841,0x10cda93c0,12,ObjectDefineSetter
code-creation,Builtin,2,7846,0x10cda9400,1484,ObjectEntries
code-creation,Builtin,2,7851,0x10cda9a00,12,ObjectFreeze
code-creation,Builtin,2,7856,0x10cda9a40,4724,ObjectGetOwnPropertyDescriptor
code-creation,Builtin,2,7862,0x10cdaacc0,12,ObjectGetOwnPropertyDescriptors
code-creation,Builtin,2,7867,0x10cdaad00,600,ObjectGetOwnPropertyNames
code-creation,Builtin,2,7873,0x10cdaaf80,12,ObjectGetOwnPropertySymbols
code-creation,Builtin,2,7878,0x10cdaafc0,168,ObjectHasOwn
code-creation,Builtin,2,7883,0x10cdab080,416,ObjectIs
code-creation,Builtin,2,7887,0x10cdab240,12,ObjectIsFrozen
code-creation,Builtin,2,7892,0x10cdab280,12,ObjectIsSealed
code-creation,Builtin,2,7897,0x10cdab2c0,532,ObjectKeys
code-creation,Builtin,2,7901,0x10cdab500,12,ObjectLookupGetter
code-creation,Builtin,2,7906,0x10cdab540,12,ObjectLookupSetter
code-creation,Builtin,2,7911,0x10cdab580,3048,ObjectPrototypeHasOwnProperty
code-creation,Builtin,2,7917,0x10cdac180,240,ObjectPrototypeIsPrototypeOf
code-creation,Builtin,2,7922,0x10cdac280,12,ObjectPrototypePropertyIsEnumerable
code-creation,Builtin,2,7928,0x10cdac2c0,12,ObjectPrototypeGetProto
code-creation,Builtin,2,7933,0x10cdac300,12,ObjectPrototypeSetProto
code-creation,Builtin,2,7938,0x10cdac340,12,ObjectSeal
code-creation,Builtin,2,7943,0x10cdac380,1356,ObjectToString
code-creation,Builtin,2,7948,0x10cdac900,1260,ObjectValues
code-creation,Builtin,2,7952,0x10cdace00,304,OrdinaryHasInstance
code-creation,Builtin,2,7957,0x10cdacf40,372,InstanceOf
code-creation,Builtin,2,7962,0x10cdad0c0,644,InstanceOf_WithFeedback
code-creation,Builtin,2,7967,0x10cdad380,664,InstanceOf_Baseline
code-creation,Builtin,2,7972,0x10cdad640,276,ForInEnumerate
code-creation,Builtin,2,7977,0x10cdad780,148,ForInPrepare
code-creation,Builtin,2,7982,0x10cdad840,3396,ForInFilter
code-creation,Builtin,2,7986,0x10cdae5c0,56,ReflectApply
code-creation,Builtin,2,7991,0x10cdae600,64,ReflectConstruct
code-creation,Builtin,2,7996,0x10cdae680,12,ReflectDefineProperty
code-creation,Builtin,2,8001,0x10cdae6c0,12,ReflectOwnKeys
code-creation,Builtin,2,8006,0x10cdae700,12,ReflectSet
code-creation,Builtin,2,8010,0x10cdae740,12,RegExpCapture1Getter
code-creation,Builtin,2,8015,0x10cdae780,12,RegExpCapture2Getter
code-creation,Builtin,2,8021,0x10cdae7c0,12,RegExpCapture3Getter
code-creation,Builtin,2,8026,0x10cdae800,12,RegExpCapture4Getter
code-creation,Builtin,2,8031,0x10cdae840,12,RegExpCapture5Getter
code-creation,Builtin,2,8036,0x10cdae880,12,RegExpCapture6Getter
code-creation,Builtin,2,8041,0x10cdae8c0,12,RegExpCapture7Getter
code-creation,Builtin,2,8046,0x10cdae900,12,RegExpCapture8Getter
code-creation,Builtin,2,8051,0x10cdae940,12,RegExpCapture9Getter
code-creation,Builtin,2,8056,0x10cdae980,2360,RegExpConstructor
code-creation,Builtin,2,8061,0x10cdaf2c0,12,RegExpInputGetter
code-creation,Builtin,2,8066,0x10cdaf300,12,RegExpInputSetter
code-creation,Builtin,2,8071,0x10cdaf340,12,RegExpLastMatchGetter
code-creation,Builtin,2,8076,0x10cdaf380,12,RegExpLastParenGetter
code-creation,Builtin,2,8081,0x10cdaf3c0,12,RegExpLeftContextGetter
code-creation,Builtin,2,8086,0x10cdaf400,952,RegExpPrototypeCompile
code-creation,Builtin,2,8091,0x10cdaf7c0,12,RegExpPrototypeToString
code-creation,Builtin,2,8096,0x10cdaf800,12,RegExpRightContextGetter
code-creation,Builtin,2,8102,0x10cdaf840,240,RegExpExecAtom
code-creation,Builtin,2,8107,0x10cdaf940,996,RegExpExecInternal
code-creation,Builtin,2,8112,0x10cdafd40,8,RegExpInterpreterTrampoline
code-creation,Builtin,2,8117,0x10cdafd80,8,RegExpExperimentalTrampoline
code-creation,Builtin,2,8123,0x10cdafdc0,1116,FindOrderedHashSetEntry
code-creation,Builtin,2,8128,0x10cdb0240,2972,SetConstructor
code-creation,Builtin,2,8133,0x10cdb0e00,172,SetPrototypeHas
code-creation,Builtin,2,8138,0x10cdb0ec0,1632,SetPrototypeAdd
code-creation,Builtin,2,8143,0x10cdb1540,1432,SetPrototypeDelete
code-creation,Builtin,2,8155,0x10cdb1b00,12,SetPrototypeClear
code-creation,Builtin,2,8160,0x10cdb1b40,288,SetPrototypeEntries
code-creation,Builtin,2,8165,0x10cdb1c80,148,SetPrototypeGetSize
code-creation,Builtin,2,8170,0x10cdb1d40,456,SetPrototypeForEach
code-creation,Builtin,2,8175,0x10cdb1f40,288,SetPrototypeValues
code-creation,Builtin,2,8180,0x10cdb2080,840,SetIteratorPrototypeNext
code-creation,Builtin,2,8186,0x10cdb2400,1104,SetOrSetIteratorToList
code-creation,Builtin,2,8191,0x10cdb2880,12,ShadowRealmConstructor
code-creation,Builtin,2,8196,0x10cdb28c0,576,ShadowRealmGetWrappedValue
code-creation,Builtin,2,8201,0x10cdb2b40,12,ShadowRealmPrototypeEvaluate
code-creation,Builtin,2,8207,0x10cdb2b80,1404,ShadowRealmPrototypeImportValue
code-creation,Builtin,2,8212,0x10cdb3100,236,ShadowRealmImportValueFulfilled
code-creation,Builtin,2,8218,0x10cdb3200,76,ShadowRealmImportValueRejected
code-creation,Builtin,2,8224,0x10cdb3280,12,SharedArrayBufferPrototypeGetByteLength
code-creation,Builtin,2,8230,0x10cdb32c0,12,SharedArrayBufferPrototypeSlice
code-creation,Builtin,2,8235,0x10cdb3300,12,SharedArrayBufferPrototypeGrow
code-creation,Builtin,2,8241,0x10cdb3340,2104,AtomicsLoad
code-creation,Builtin,2,8245,0x10cdb3b80,2188,AtomicsStore
code-creation,Builtin,2,8250,0x10cdb4440,2836,AtomicsExchange
code-creation,Builtin,2,8255,0x10cdb4f80,3120,AtomicsCompareExchange
code-creation,Builtin,2,8260,0x10cdb5bc0,2864,AtomicsAdd
code-creation,Builtin,2,8265,0x10cdb6700,2864,AtomicsSub
code-creation,Builtin,2,8269,0x10cdb7240,2864,AtomicsAnd
code-creation,Builtin,2,8274,0x10cdb7d80,2864,AtomicsOr
code-creation,Builtin,2,8278,0x10cdb88c0,2864,AtomicsXor
code-creation,Builtin,2,8283,0x10cdb9400,12,AtomicsNotify
code-creation,Builtin,2,8288,0x10cdb9440,12,AtomicsIsLockFree
code-creation,Builtin,2,8293,0x10cdb9480,12,AtomicsWait
code-creation,Builtin,2,8297,0x10cdb94c0,12,AtomicsWaitAsync
code-creation,Builtin,2,8302,0x10cdb9500,12,StringFromCodePoint
code-creation,Builtin,2,8307,0x10cdb9540,1308,StringFromCharCode
code-creation,Builtin,2,8312,0x10cdb9a80,12,StringPrototypeLastIndexOf
code-creation,Builtin,2,8318,0x10cdb9ac0,4612,StringPrototypeMatchAll
code-creation,Builtin,2,8323,0x10cdbad00,12,StringPrototypeLocaleCompare
code-creation,Builtin,2,8328,0x10cdbad40,1292,StringPrototypeReplace
code-creation,Builtin,2,8334,0x10cdbb280,2864,StringPrototypeSplit
code-creation,Builtin,2,8339,0x10cdbbdc0,12,StringRaw
code-creation,Builtin,2,8343,0x10cdbbe00,12,SymbolConstructor
code-creation,Builtin,2,8348,0x10cdbbe40,12,SymbolFor
code-creation,Builtin,2,8353,0x10cdbbe80,12,SymbolKeyFor
code-creation,Builtin,2,8357,0x10cdbbec0,88,TypedArrayBaseConstructor
code-creation,Builtin,2,8363,0x10cdbbf40,252,TypedArrayConstructor
code-creation,Builtin,2,8368,0x10cdbc040,12,TypedArrayPrototypeBuffer
code-creation,Builtin,2,8373,0x10cdbc080,880,TypedArrayPrototypeByteLength
code-creation,Builtin,2,8379,0x10cdbc400,364,TypedArrayPrototypeByteOffset
code-creation,Builtin,2,8384,0x10cdbc580,592,TypedArrayPrototypeLength
code-creation,Builtin,2,8390,0x10cdbc800,12,TypedArrayPrototypeCopyWithin
code-creation,Builtin,2,8395,0x10cdbc840,12,TypedArrayPrototypeFill
code-creation,Builtin,2,8401,0x10cdbc880,12,TypedArrayPrototypeIncludes
code-creation,Builtin,2,8406,0x10cdbc8c0,12,TypedArrayPrototypeIndexOf
code-creation,Builtin,2,8411,0x10cdbc900,12,TypedArrayPrototypeLastIndexOf
code-creation,Builtin,2,8417,0x10cdbc940,12,TypedArrayPrototypeReverse
code-creation,Builtin,2,8422,0x10cdbc980,432,TypedArrayPrototypeToStringTag
code-creation,Builtin,2,8428,0x10cdbcb40,24540,TypedArrayPrototypeMap
code-creation,Builtin,2,8433,0x10cdc2b40,992,GenericJSToWasmWrapper
code-creation,Builtin,2,8438,0x10cdc2f40,1268,WasmReturnPromiseOnSuspend
code-creation,Builtin,2,8444,0x10cdc3440,160,WasmSuspend
code-creation,Builtin,2,8448,0x10cdc3500,324,WasmResume
code-creation,Builtin,2,8453,0x10cdc3680,340,WasmReject
code-creation,Builtin,2,8458,0x10cdc3800,156,WasmCompileLazy
code-creation,Builtin,2,8463,0x10cdc38c0,192,WasmLiftoffFrameSetup
code-creation,Builtin,2,8474,0x10cdc39c0,180,WasmDebugBreak
code-creation,Builtin,2,8479,0x10cdc3a80,16,WasmOnStackReplace
code-creation,Builtin,2,8484,0x10cdc3ac0,132,WasmFloat32ToNumber
code-creation,Builtin,2,8489,0x10cdc3b80,144,WasmFloat64ToNumber
code-creation,Builtin,2,8494,0x10cdc3c40,24,JSToWasmLazyDeoptContinuation
code-creation,Builtin,2,8500,0x10cdc3c80,4532,WeakMapConstructor
code-creation,Builtin,2,8505,0x10cdc4e40,264,WeakMapLookupHashIndex
code-creation,Builtin,2,8510,0x10cdc4f80,224,WeakMapGet
code-creation,Builtin,2,8514,0x10cdc5080,184,WeakMapPrototypeHas
code-creation,Builtin,2,8519,0x10cdc5140,256,WeakMapPrototypeSet
code-creation,Builtin,2,8524,0x10cdc5280,156,WeakMapPrototypeDelete
code-creation,Builtin,2,8530,0x10cdc5340,3156,WeakSetConstructor
code-creation,Builtin,2,8535,0x10cdc5fc0,184,WeakSetPrototypeHas
code-creation,Builtin,2,8540,0x10cdc6080,260,WeakSetPrototypeAdd
code-creation,Builtin,2,8545,0x10cdc61c0,156,WeakSetPrototypeDelete
code-creation,Builtin,2,8553,0x10cdc6280,448,WeakCollectionDelete
code-creation,Builtin,2,8558,0x10cdc6480,808,WeakCollectionSet
code-creation,Builtin,2,8563,0x10cdc67c0,12,SharedStructTypeConstructor
code-creation,Builtin,2,8569,0x10cdc6800,12,SharedStructConstructor
code-creation,Builtin,2,8574,0x10cdc6840,12,SharedArrayConstructor
code-creation,Builtin,2,8579,0x10cdc6880,12,AtomicsMutexConstructor
code-creation,Builtin,2,8584,0x10cdc68c0,12,AtomicsMutexLock
code-creation,Builtin,2,8589,0x10cdc6900,12,AtomicsMutexTryLock
code-creation,Builtin,2,8594,0x10cdc6940,12,AtomicsConditionConstructor
code-creation,Builtin,2,8599,0x10cdc6980,12,AtomicsConditionWait
code-creation,Builtin,2,8605,0x10cdc69c0,12,AtomicsConditionNotify
code-creation,Builtin,2,8610,0x10cdc6a00,288,AsyncGeneratorResolve
code-creation,Builtin,2,8615,0x10cdc6b40,104,AsyncGeneratorReject
code-creation,Builtin,2,8620,0x10cdc6bc0,1624,AsyncGeneratorYieldWithAwait
code-creation,Builtin,2,8626,0x10cdc7240,1912,AsyncGeneratorReturn
code-creation,Builtin,2,8631,0x10cdc79c0,376,AsyncGeneratorResumeNext
code-creation,Builtin,2,8636,0x10cdc7b40,12,AsyncGeneratorFunctionConstructor
code-creation,Builtin,2,8642,0x10cdc7b80,1020,AsyncGeneratorPrototypeNext
code-creation,Builtin,2,8647,0x10cdc7f80,1028,AsyncGeneratorPrototypeReturn
code-creation,Builtin,2,8653,0x10cdc83c0,1028,AsyncGeneratorPrototypeThrow
code-creation,Builtin,2,8658,0x10cdc8800,1600,AsyncGeneratorAwaitCaught
code-creation,Builtin,2,8664,0x10cdc8e80,1600,AsyncGeneratorAwaitUncaught
code-creation,Builtin,2,8669,0x10cdc9500,176,AsyncGeneratorAwaitResolveClosure
code-creation,Builtin,2,8675,0x10cdc95c0,172,AsyncGeneratorAwaitRejectClosure
code-creation,Builtin,2,8680,0x10cdc9680,124,AsyncGeneratorYieldWithAwaitResolveClosure
code-creation,Builtin,2,8687,0x10cdc9700,124,AsyncGeneratorReturnClosedResolveClosure
code-creation,Builtin,2,8693,0x10cdc9780,116,AsyncGeneratorReturnClosedRejectClosure
code-creation,Builtin,2,8699,0x10cdc9800,180,AsyncGeneratorReturnResolveClosure
code-creation,Builtin,2,8704,0x10cdc98c0,1656,AsyncFromSyncIteratorPrototypeNext
code-creation,Builtin,2,8710,0x10cdc9f40,1764,AsyncFromSyncIteratorPrototypeThrow
code-creation,Builtin,2,8716,0x10cdca640,1788,AsyncFromSyncIteratorPrototypeReturn
code-creation,Builtin,2,8722,0x10cdcad40,100,AsyncIteratorValueUnwrap
code-creation,Builtin,2,8727,0x10cdcadc0,192,CEntry_Return1_ArgvInRegister_NoBuiltinExit
code-creation,Builtin,2,8733,0x10cdcaec0,204,CEntry_Return1_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,8739,0x10cdcafc0,204,CEntry_Return1_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,8745,0x10cdcb0c0,192,CEntry_Return2_ArgvInRegister_NoBuiltinExit
code-creation,Builtin,2,8752,0x10cdcb1c0,204,CEntry_Return2_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,8758,0x10cdcb2c0,204,CEntry_Return2_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,8764,0x10cdcb3c0,4,DirectCEntry
code-creation,Builtin,2,8768,0x10cdcb400,1244,StringAdd_CheckNone
code-creation,Builtin,2,8783,0x10cdcb900,2384,SubString
code-creation,Builtin,2,8792,0x10cdcc280,84,DoubleToI
code-creation,Builtin,2,8797,0x10cdcc300,3088,GetProperty
code-creation,Builtin,2,8810,0x10cdccf40,3248,GetPropertyWithReceiver
code-creation,Builtin,2,8816,0x10cdcdc00,16876,SetProperty
code-creation,Builtin,2,8823,0x10cdd1e00,14060,CreateDataProperty
code-creation,Builtin,2,8828,0x10cdd5500,52,GetOwnPropertyDescriptor
code-creation,Builtin,2,8834,0x10cdd5540,8,MemCopyUint8Uint8
code-creation,Builtin,2,8840,0x10cdd5580,8,MemMove
code-creation,Builtin,2,8844,0x10cdd55c0,180,FindNonDefaultConstructorOrConstruct
code-creation,Builtin,2,8850,0x10cdd5680,2788,OrdinaryGetOwnPropertyDescriptor
code-creation,Builtin,2,8856,0x10cdd6180,12,IsTraceCategoryEnabled
code-creation,Builtin,2,8862,0x10cdd61c0,12,Trace
code-creation,Builtin,2,8867,0x10cdd6200,12,FinalizationRegistryUnregister
code-creation,Builtin,2,8874,0x10cdd6240,408,AsyncModuleEvaluate
code-creation,Builtin,2,8879,0x10cdd6400,12,CallAsyncModuleFulfilled
code-creation,Builtin,2,8884,0x10cdd6440,12,CallAsyncModuleRejected
code-creation,Builtin,2,8891,0x10cdd6480,12,TemporalNowTimeZone
code-creation,Builtin,2,8896,0x10cdd64c0,12,TemporalNowInstant
code-creation,Builtin,2,8903,0x10cdd6500,12,TemporalNowPlainDateTime
code-creation,Builtin,2,8908,0x10cdd6540,12,TemporalNowPlainDateTimeISO
code-creation,Builtin,2,8915,0x10cdd6580,12,TemporalNowZonedDateTime
code-creation,Builtin,2,8921,0x10cdd65c0,12,TemporalNowZonedDateTimeISO
code-creation,Builtin,2,8926,0x10cdd6600,12,TemporalNowPlainDate
code-creation,Builtin,2,8931,0x10cdd6640,12,TemporalNowPlainDateISO
code-creation,Builtin,2,8936,0x10cdd6680,12,TemporalNowPlainTimeISO
code-creation,Builtin,2,8941,0x10cdd66c0,12,TemporalPlainDateConstructor
code-creation,Builtin,2,8948,0x10cdd6700,12,TemporalPlainDateFrom
code-creation,Builtin,2,8954,0x10cdd6740,12,TemporalPlainDateCompare
code-creation,Builtin,2,8960,0x10cdd6780,12,TemporalPlainDatePrototypeCalendar
code-creation,Builtin,2,8966,0x10cdd67c0,12,TemporalPlainDatePrototypeYear
code-creation,Builtin,2,8972,0x10cdd6800,12,TemporalPlainDatePrototypeMonth
code-creation,Builtin,2,8977,0x10cdd6840,12,TemporalPlainDatePrototypeMonthCode
code-creation,Builtin,2,8983,0x10cdd6880,12,TemporalPlainDatePrototypeDay
code-creation,Builtin,2,8989,0x10cdd68c0,12,TemporalPlainDatePrototypeDayOfWeek
code-creation,Builtin,2,8994,0x10cdd6900,12,TemporalPlainDatePrototypeDayOfYear
code-creation,Builtin,2,9000,0x10cdd6940,12,TemporalPlainDatePrototypeWeekOfYear
code-creation,Builtin,2,9008,0x10cdd6980,12,TemporalPlainDatePrototypeDaysInWeek
code-creation,Builtin,2,9015,0x10cdd69c0,12,TemporalPlainDatePrototypeDaysInMonth
code-creation,Builtin,2,9021,0x10cdd6a00,12,TemporalPlainDatePrototypeDaysInYear
code-creation,Builtin,2,9027,0x10cdd6a40,12,TemporalPlainDatePrototypeMonthsInYear
code-creation,Builtin,2,9033,0x10cdd6a80,12,TemporalPlainDatePrototypeInLeapYear
code-creation,Builtin,2,9039,0x10cdd6ac0,12,TemporalPlainDatePrototypeToPlainYearMonth
code-creation,Builtin,2,9045,0x10cdd6b00,12,TemporalPlainDatePrototypeToPlainMonthDay
code-creation,Builtin,2,9051,0x10cdd6b40,12,TemporalPlainDatePrototypeGetISOFields
code-creation,Builtin,2,9059,0x10cdd6b80,12,TemporalPlainDatePrototypeAdd
code-creation,Builtin,2,9066,0x10cdd6bc0,12,TemporalPlainDatePrototypeSubtract
code-creation,Builtin,2,9074,0x10cdd6c00,12,TemporalPlainDatePrototypeWith
code-creation,Builtin,2,9081,0x10cdd6c40,12,TemporalPlainDatePrototypeWithCalendar
code-creation,Builtin,2,9089,0x10cdd6c80,12,TemporalPlainDatePrototypeUntil
code-creation,Builtin,2,9096,0x10cdd6cc0,12,TemporalPlainDatePrototypeSince
code-creation,Builtin,2,9104,0x10cdd6d00,12,TemporalPlainDatePrototypeEquals
code-creation,Builtin,2,9111,0x10cdd6d40,12,TemporalPlainDatePrototypeToPlainDateTime
code-creation,Builtin,2,9119,0x10cdd6d80,12,TemporalPlainDatePrototypeToZonedDateTime
code-creation,Builtin,2,9126,0x10cdd6dc0,12,TemporalPlainDatePrototypeToString
code-creation,Builtin,2,9132,0x10cdd6e00,12,TemporalPlainDatePrototypeToJSON
code-creation,Builtin,2,9138,0x10cdd6e40,12,TemporalPlainDatePrototypeToLocaleString
code-creation,Builtin,2,9144,0x10cdd6e80,12,TemporalPlainDatePrototypeValueOf
code-creation,Builtin,2,9156,0x10cdd6ec0,12,TemporalPlainTimeConstructor
code-creation,Builtin,2,9162,0x10cdd6f00,12,TemporalPlainTimeFrom
code-creation,Builtin,2,9169,0x10cdd6f40,12,TemporalPlainTimeCompare
code-creation,Builtin,2,9176,0x10cdd6f80,12,TemporalPlainTimePrototypeCalendar
code-creation,Builtin,2,9184,0x10cdd6fc0,12,TemporalPlainTimePrototypeHour
code-creation,Builtin,2,9190,0x10cdd7000,12,TemporalPlainTimePrototypeMinute
code-creation,Builtin,2,9196,0x10cdd7040,12,TemporalPlainTimePrototypeSecond
code-creation,Builtin,2,9202,0x10cdd7080,12,TemporalPlainTimePrototypeMillisecond
code-creation,Builtin,2,9208,0x10cdd70c0,12,TemporalPlainTimePrototypeMicrosecond
code-creation,Builtin,2,9214,0x10cdd7100,12,TemporalPlainTimePrototypeNanosecond
code-creation,Builtin,2,9220,0x10cdd7140,12,TemporalPlainTimePrototypeAdd
code-creation,Builtin,2,9225,0x10cdd7180,12,TemporalPlainTimePrototypeSubtract
code-creation,Builtin,2,9232,0x10cdd71c0,12,TemporalPlainTimePrototypeWith
code-creation,Builtin,2,9239,0x10cdd7200,12,TemporalPlainTimePrototypeUntil
code-creation,Builtin,2,9245,0x10cdd7240,12,TemporalPlainTimePrototypeSince
code-creation,Builtin,2,9251,0x10cdd7280,12,TemporalPlainTimePrototypeRound
code-creation,Builtin,2,9256,0x10cdd72c0,12,TemporalPlainTimePrototypeEquals
code-creation,Builtin,2,9262,0x10cdd7300,12,TemporalPlainTimePrototypeToPlainDateTime
code-creation,Builtin,2,9268,0x10cdd7340,12,TemporalPlainTimePrototypeToZonedDateTime
code-creation,Builtin,2,9274,0x10cdd7380,12,TemporalPlainTimePrototypeGetISOFields
code-creation,Builtin,2,9280,0x10cdd73c0,12,TemporalPlainTimePrototypeToString
code-creation,Builtin,2,9287,0x10cdd7400,12,TemporalPlainTimePrototypeToJSON
code-creation,Builtin,2,9295,0x10cdd7440,12,TemporalPlainTimePrototypeToLocaleString
code-creation,Builtin,2,9302,0x10cdd7480,12,TemporalPlainTimePrototypeValueOf
code-creation,Builtin,2,9308,0x10cdd74c0,12,TemporalPlainDateTimeConstructor
code-creation,Builtin,2,9314,0x10cdd7500,12,TemporalPlainDateTimeFrom
code-creation,Builtin,2,9319,0x10cdd7540,12,TemporalPlainDateTimeCompare
code-creation,Builtin,2,9324,0x10cdd7580,12,TemporalPlainDateTimePrototypeCalendar
code-creation,Builtin,2,9330,0x10cdd75c0,12,TemporalPlainDateTimePrototypeYear
code-creation,Builtin,2,9336,0x10cdd7600,12,TemporalPlainDateTimePrototypeMonth
code-creation,Builtin,2,9342,0x10cdd7640,12,TemporalPlainDateTimePrototypeMonthCode
code-creation,Builtin,2,9350,0x10cdd7680,12,TemporalPlainDateTimePrototypeDay
code-creation,Builtin,2,9356,0x10cdd76c0,12,TemporalPlainDateTimePrototypeHour
code-creation,Builtin,2,9363,0x10cdd7700,12,TemporalPlainDateTimePrototypeMinute
code-creation,Builtin,2,9369,0x10cdd7740,12,TemporalPlainDateTimePrototypeSecond
code-creation,Builtin,2,9375,0x10cdd7780,12,TemporalPlainDateTimePrototypeMillisecond
code-creation,Builtin,2,9381,0x10cdd77c0,12,TemporalPlainDateTimePrototypeMicrosecond
code-creation,Builtin,2,9389,0x10cdd7800,12,TemporalPlainDateTimePrototypeNanosecond
code-creation,Builtin,2,9395,0x10cdd7840,12,TemporalPlainDateTimePrototypeDayOfWeek
code-creation,Builtin,2,9401,0x10cdd7880,12,TemporalPlainDateTimePrototypeDayOfYear
code-creation,Builtin,2,9409,0x10cdd78c0,12,TemporalPlainDateTimePrototypeWeekOfYear
code-creation,Builtin,2,9416,0x10cdd7900,12,TemporalPlainDateTimePrototypeDaysInWeek
code-creation,Builtin,2,9424,0x10cdd7940,12,TemporalPlainDateTimePrototypeDaysInMonth
code-creation,Builtin,2,9430,0x10cdd7980,12,TemporalPlainDateTimePrototypeDaysInYear
code-creation,Builtin,2,9436,0x10cdd79c0,12,TemporalPlainDateTimePrototypeMonthsInYear
code-creation,Builtin,2,9442,0x10cdd7a00,12,TemporalPlainDateTimePrototypeInLeapYear
code-creation,Builtin,2,9448,0x10cdd7a40,12,TemporalPlainDateTimePrototypeWith
code-creation,Builtin,2,9454,0x10cdd7a80,12,TemporalPlainDateTimePrototypeWithPlainTime
code-creation,Builtin,2,9462,0x10cdd7ac0,12,TemporalPlainDateTimePrototypeWithPlainDate
code-creation,Builtin,2,9470,0x10cdd7b00,12,TemporalPlainDateTimePrototypeWithCalendar
code-creation,Builtin,2,9478,0x10cdd7b40,12,TemporalPlainDateTimePrototypeAdd
code-creation,Builtin,2,9492,0x10cdd7b80,12,TemporalPlainDateTimePrototypeSubtract
code-creation,Builtin,2,9500,0x10cdd7bc0,12,TemporalPlainDateTimePrototypeUntil
code-creation,Builtin,2,9507,0x10cdd7c00,12,TemporalPlainDateTimePrototypeSince
code-creation,Builtin,2,9515,0x10cdd7c40,12,TemporalPlainDateTimePrototypeRound
code-creation,Builtin,2,9522,0x10cdd7c80,12,TemporalPlainDateTimePrototypeEquals
code-creation,Builtin,2,9530,0x10cdd7cc0,12,TemporalPlainDateTimePrototypeToString
code-creation,Builtin,2,9538,0x10cdd7d00,12,TemporalPlainDateTimePrototypeToJSON
code-creation,Builtin,2,9545,0x10cdd7d40,12,TemporalPlainDateTimePrototypeToLocaleString
code-creation,Builtin,2,9554,0x10cdd7d80,12,TemporalPlainDateTimePrototypeValueOf
code-creation,Builtin,2,9561,0x10cdd7dc0,12,TemporalPlainDateTimePrototypeToZonedDateTime
code-creation,Builtin,2,9569,0x10cdd7e00,12,TemporalPlainDateTimePrototypeToPlainDate
code-creation,Builtin,2,9577,0x10cdd7e40,12,TemporalPlainDateTimePrototypeToPlainYearMonth
code-creation,Builtin,2,9585,0x10cdd7e80,12,TemporalPlainDateTimePrototypeToPlainMonthDay
code-creation,Builtin,2,9593,0x10cdd7ec0,12,TemporalPlainDateTimePrototypeToPlainTime
code-creation,Builtin,2,9601,0x10cdd7f00,12,TemporalPlainDateTimePrototypeGetISOFields
code-creation,Builtin,2,9609,0x10cdd7f40,12,TemporalZonedDateTimeConstructor
code-creation,Builtin,2,9617,0x10cdd7f80,12,TemporalZonedDateTimeFrom
code-creation,Builtin,2,9624,0x10cdd7fc0,12,TemporalZonedDateTimeCompare
code-creation,Builtin,2,9631,0x10cdd8000,12,TemporalZonedDateTimePrototypeCalendar
code-creation,Builtin,2,9639,0x10cdd8040,12,TemporalZonedDateTimePrototypeTimeZone
code-creation,Builtin,2,9647,0x10cdd8080,12,TemporalZonedDateTimePrototypeYear
code-creation,Builtin,2,9654,0x10cdd80c0,12,TemporalZonedDateTimePrototypeMonth
code-creation,Builtin,2,9662,0x10cdd8100,12,TemporalZonedDateTimePrototypeMonthCode
code-creation,Builtin,2,9670,0x10cdd8140,12,TemporalZonedDateTimePrototypeDay
code-creation,Builtin,2,9677,0x10cdd8180,12,TemporalZonedDateTimePrototypeHour
code-creation,Builtin,2,9685,0x10cdd81c0,12,TemporalZonedDateTimePrototypeMinute
code-creation,Builtin,2,9693,0x10cdd8200,12,TemporalZonedDateTimePrototypeSecond
code-creation,Builtin,2,9700,0x10cdd8240,12,TemporalZonedDateTimePrototypeMillisecond
code-creation,Builtin,2,9708,0x10cdd8280,12,TemporalZonedDateTimePrototypeMicrosecond
code-creation,Builtin,2,9716,0x10cdd82c0,12,TemporalZonedDateTimePrototypeNanosecond
code-creation,Builtin,2,9724,0x10cdd8300,12,TemporalZonedDateTimePrototypeEpochSeconds
code-creation,Builtin,2,9732,0x10cdd8340,12,TemporalZonedDateTimePrototypeEpochMilliseconds
code-creation,Builtin,2,9740,0x10cdd8380,12,TemporalZonedDateTimePrototypeEpochMicroseconds
code-creation,Builtin,2,9749,0x10cdd83c0,12,TemporalZonedDateTimePrototypeEpochNanoseconds
code-creation,Builtin,2,9757,0x10cdd8400,12,TemporalZonedDateTimePrototypeDayOfWeek
code-creation,Builtin,2,9765,0x10cdd8440,12,TemporalZonedDateTimePrototypeDayOfYear
code-creation,Builtin,2,9772,0x10cdd8480,12,TemporalZonedDateTimePrototypeWeekOfYear
tick,0x7ff8092cbace,9786,0,0x0,6
tick,0x7ff8091420e4,9802,0,0x0,6
code-creation,Builtin,2,9811,0x10cdd84c0,12,TemporalZonedDateTimePrototypeHoursInDay
code-creation,Builtin,2,9819,0x10cdd8500,12,TemporalZonedDateTimePrototypeDaysInWeek
code-creation,Builtin,2,9826,0x10cdd8540,12,TemporalZonedDateTimePrototypeDaysInMonth
code-creation,Builtin,2,9832,0x10cdd8580,12,TemporalZonedDateTimePrototypeDaysInYear
code-creation,Builtin,2,9838,0x10cdd85c0,12,TemporalZonedDateTimePrototypeMonthsInYear
code-creation,Builtin,2,9845,0x10cdd8600,12,TemporalZonedDateTimePrototypeInLeapYear
code-creation,Builtin,2,9851,0x10cdd8640,12,TemporalZonedDateTimePrototypeOffsetNanoseconds
code-creation,Builtin,2,9857,0x10cdd8680,12,TemporalZonedDateTimePrototypeOffset
code-creation,Builtin,2,9863,0x10cdd86c0,12,TemporalZonedDateTimePrototypeWith
code-creation,Builtin,2,9869,0x10cdd8700,12,TemporalZonedDateTimePrototypeWithPlainTime
code-creation,Builtin,2,9876,0x10cdd8740,12,TemporalZonedDateTimePrototypeWithPlainDate
code-creation,Builtin,2,9892,0x10cdd8780,12,TemporalZonedDateTimePrototypeWithTimeZone
code-creation,Builtin,2,9899,0x10cdd87c0,12,TemporalZonedDateTimePrototypeWithCalendar
code-creation,Builtin,2,9905,0x10cdd8800,12,TemporalZonedDateTimePrototypeAdd
code-creation,Builtin,2,9911,0x10cdd8840,12,TemporalZonedDateTimePrototypeSubtract
code-creation,Builtin,2,9917,0x10cdd8880,12,TemporalZonedDateTimePrototypeUntil
code-creation,Builtin,2,9923,0x10cdd88c0,12,TemporalZonedDateTimePrototypeSince
code-creation,Builtin,2,9929,0x10cdd8900,12,TemporalZonedDateTimePrototypeRound
code-creation,Builtin,2,9935,0x10cdd8940,12,TemporalZonedDateTimePrototypeEquals
code-creation,Builtin,2,9941,0x10cdd8980,12,TemporalZonedDateTimePrototypeToString
code-creation,Builtin,2,9947,0x10cdd89c0,12,TemporalZonedDateTimePrototypeToJSON
code-creation,Builtin,2,9953,0x10cdd8a00,12,TemporalZonedDateTimePrototypeToLocaleString
code-creation,Builtin,2,9959,0x10cdd8a40,12,TemporalZonedDateTimePrototypeValueOf
code-creation,Builtin,2,9965,0x10cdd8a80,12,TemporalZonedDateTimePrototypeStartOfDay
code-creation,Builtin,2,9971,0x10cdd8ac0,12,TemporalZonedDateTimePrototypeToInstant
code-creation,Builtin,2,9977,0x10cdd8b00,12,TemporalZonedDateTimePrototypeToPlainDate
code-creation,Builtin,2,9983,0x10cdd8b40,12,TemporalZonedDateTimePrototypeToPlainTime
code-creation,Builtin,2,9989,0x10cdd8b80,12,TemporalZonedDateTimePrototypeToPlainDateTime
code-creation,Builtin,2,9996,0x10cdd8bc0,12,TemporalZonedDateTimePrototypeToPlainYearMonth
code-creation,Builtin,2,10002,0x10cdd8c00,12,TemporalZonedDateTimePrototypeToPlainMonthDay
code-creation,Builtin,2,10008,0x10cdd8c40,12,TemporalZonedDateTimePrototypeGetISOFields
code-creation,Builtin,2,10015,0x10cdd8c80,12,TemporalDurationConstructor
code-creation,Builtin,2,10020,0x10cdd8cc0,12,TemporalDurationFrom
code-creation,Builtin,2,10025,0x10cdd8d00,12,TemporalDurationCompare
code-creation,Builtin,2,10031,0x10cdd8d40,12,TemporalDurationPrototypeYears
code-creation,Builtin,2,10036,0x10cdd8d80,12,TemporalDurationPrototypeMonths
code-creation,Builtin,2,10042,0x10cdd8dc0,12,TemporalDurationPrototypeWeeks
code-creation,Builtin,2,10048,0x10cdd8e00,12,TemporalDurationPrototypeDays
code-creation,Builtin,2,10053,0x10cdd8e40,12,TemporalDurationPrototypeHours
code-creation,Builtin,2,10059,0x10cdd8e80,12,TemporalDurationPrototypeMinutes
code-creation,Builtin,2,10064,0x10cdd8ec0,12,TemporalDurationPrototypeSeconds
code-creation,Builtin,2,10070,0x10cdd8f00,12,TemporalDurationPrototypeMilliseconds
code-creation,Builtin,2,10076,0x10cdd8f40,12,TemporalDurationPrototypeMicroseconds
code-creation,Builtin,2,10082,0x10cdd8f80,12,TemporalDurationPrototypeNanoseconds
code-creation,Builtin,2,10088,0x10cdd8fc0,12,TemporalDurationPrototypeSign
code-creation,Builtin,2,10093,0x10cdd9000,12,TemporalDurationPrototypeBlank
code-creation,Builtin,2,10099,0x10cdd9040,12,TemporalDurationPrototypeWith
code-creation,Builtin,2,10104,0x10cdd9080,12,TemporalDurationPrototypeNegated
code-creation,Builtin,2,10110,0x10cdd90c0,12,TemporalDurationPrototypeAbs
code-creation,Builtin,2,10116,0x10cdd9100,12,TemporalDurationPrototypeAdd
code-creation,Builtin,2,10121,0x10cdd9140,12,TemporalDurationPrototypeSubtract
code-creation,Builtin,2,10127,0x10cdd9180,12,TemporalDurationPrototypeRound
code-creation,Builtin,2,10133,0x10cdd91c0,12,TemporalDurationPrototypeTotal
code-creation,Builtin,2,10140,0x10cdd9200,12,TemporalDurationPrototypeToString
code-creation,Builtin,2,10146,0x10cdd9240,12,TemporalDurationPrototypeToJSON
code-creation,Builtin,2,10152,0x10cdd9280,12,TemporalDurationPrototypeToLocaleString
code-creation,Builtin,2,10161,0x10cdd92c0,12,TemporalDurationPrototypeValueOf
code-creation,Builtin,2,10167,0x10cdd9300,12,TemporalInstantConstructor
code-creation,Builtin,2,10172,0x10cdd9340,12,TemporalInstantFrom
code-creation,Builtin,2,10178,0x10cdd9380,12,TemporalInstantFromEpochSeconds
code-creation,Builtin,2,10184,0x10cdd93c0,12,TemporalInstantFromEpochMilliseconds
code-creation,Builtin,2,10190,0x10cdd9400,12,TemporalInstantFromEpochMicroseconds
code-creation,Builtin,2,10196,0x10cdd9440,12,TemporalInstantFromEpochNanoseconds
code-creation,Builtin,2,10208,0x10cdd9480,12,TemporalInstantCompare
code-creation,Builtin,2,10214,0x10cdd94c0,12,TemporalInstantPrototypeEpochSeconds
code-creation,Builtin,2,10220,0x10cdd9500,12,TemporalInstantPrototypeEpochMilliseconds
code-creation,Builtin,2,10227,0x10cdd9540,12,TemporalInstantPrototypeEpochMicroseconds
code-creation,Builtin,2,10233,0x10cdd9580,12,TemporalInstantPrototypeEpochNanoseconds
code-creation,Builtin,2,10239,0x10cdd95c0,12,TemporalInstantPrototypeAdd
code-creation,Builtin,2,10244,0x10cdd9600,12,TemporalInstantPrototypeSubtract
code-creation,Builtin,2,10251,0x10cdd9640,12,TemporalInstantPrototypeUntil
code-creation,Builtin,2,10257,0x10cdd9680,12,TemporalInstantPrototypeSince
code-creation,Builtin,2,10262,0x10cdd96c0,12,TemporalInstantPrototypeRound
code-creation,Builtin,2,10268,0x10cdd9700,12,TemporalInstantPrototypeEquals
code-creation,Builtin,2,10274,0x10cdd9740,12,TemporalInstantPrototypeToString
code-creation,Builtin,2,10279,0x10cdd9780,12,TemporalInstantPrototypeToJSON
code-creation,Builtin,2,10285,0x10cdd97c0,12,TemporalInstantPrototypeToLocaleString
code-creation,Builtin,2,10291,0x10cdd9800,12,TemporalInstantPrototypeValueOf
code-creation,Builtin,2,10296,0x10cdd9840,12,TemporalInstantPrototypeToZonedDateTime
code-creation,Builtin,2,10303,0x10cdd9880,12,TemporalInstantPrototypeToZonedDateTimeISO
code-creation,Builtin,2,10309,0x10cdd98c0,12,TemporalPlainYearMonthConstructor
code-creation,Builtin,2,10315,0x10cdd9900,12,TemporalPlainYearMonthFrom
code-creation,Builtin,2,10320,0x10cdd9940,12,TemporalPlainYearMonthCompare
code-creation,Builtin,2,10326,0x10cdd9980,12,TemporalPlainYearMonthPrototypeCalendar
code-creation,Builtin,2,10332,0x10cdd99c0,12,TemporalPlainYearMonthPrototypeYear
code-creation,Builtin,2,10338,0x10cdd9a00,12,TemporalPlainYearMonthPrototypeMonth
code-creation,Builtin,2,10344,0x10cdd9a40,12,TemporalPlainYearMonthPrototypeMonthCode
code-creation,Builtin,2,10350,0x10cdd9a80,12,TemporalPlainYearMonthPrototypeDaysInYear
code-creation,Builtin,2,10356,0x10cdd9ac0,12,TemporalPlainYearMonthPrototypeDaysInMonth
code-creation,Builtin,2,10362,0x10cdd9b00,12,TemporalPlainYearMonthPrototypeMonthsInYear
code-creation,Builtin,2,10368,0x10cdd9b40,12,TemporalPlainYearMonthPrototypeInLeapYear
code-creation,Builtin,2,10375,0x10cdd9b80,12,TemporalPlainYearMonthPrototypeWith
code-creation,Builtin,2,10380,0x10cdd9bc0,12,TemporalPlainYearMonthPrototypeAdd
code-creation,Builtin,2,10386,0x10cdd9c00,12,TemporalPlainYearMonthPrototypeSubtract
code-creation,Builtin,2,10392,0x10cdd9c40,12,TemporalPlainYearMonthPrototypeUntil
code-creation,Builtin,2,10398,0x10cdd9c80,12,TemporalPlainYearMonthPrototypeSince
code-creation,Builtin,2,10404,0x10cdd9cc0,12,TemporalPlainYearMonthPrototypeEquals
code-creation,Builtin,2,10410,0x10cdd9d00,12,TemporalPlainYearMonthPrototypeToString
code-creation,Builtin,2,10416,0x10cdd9d40,12,TemporalPlainYearMonthPrototypeToJSON
code-creation,Builtin,2,10422,0x10cdd9d80,12,TemporalPlainYearMonthPrototypeToLocaleString
code-creation,Builtin,2,10428,0x10cdd9dc0,12,TemporalPlainYearMonthPrototypeValueOf
code-creation,Builtin,2,10434,0x10cdd9e00,12,TemporalPlainYearMonthPrototypeToPlainDate
code-creation,Builtin,2,10441,0x10cdd9e40,12,TemporalPlainYearMonthPrototypeGetISOFields
code-creation,Builtin,2,10447,0x10cdd9e80,12,TemporalPlainMonthDayConstructor
code-creation,Builtin,2,10452,0x10cdd9ec0,12,TemporalPlainMonthDayFrom
code-creation,Builtin,2,10458,0x10cdd9f00,12,TemporalPlainMonthDayPrototypeCalendar
code-creation,Builtin,2,10464,0x10cdd9f40,12,TemporalPlainMonthDayPrototypeMonthCode
code-creation,Builtin,2,10470,0x10cdd9f80,12,TemporalPlainMonthDayPrototypeDay
code-creation,Builtin,2,10476,0x10cdd9fc0,12,TemporalPlainMonthDayPrototypeWith
code-creation,Builtin,2,10481,0x10cdda000,12,TemporalPlainMonthDayPrototypeEquals
code-creation,Builtin,2,10487,0x10cdda040,12,TemporalPlainMonthDayPrototypeToString
code-creation,Builtin,2,10493,0x10cdda080,12,TemporalPlainMonthDayPrototypeToJSON
code-creation,Builtin,2,10499,0x10cdda0c0,12,TemporalPlainMonthDayPrototypeToLocaleString
code-creation,Builtin,2,10512,0x10cdda100,12,TemporalPlainMonthDayPrototypeValueOf
code-creation,Builtin,2,10519,0x10cdda140,12,TemporalPlainMonthDayPrototypeToPlainDate
code-creation,Builtin,2,10525,0x10cdda180,12,TemporalPlainMonthDayPrototypeGetISOFields
code-creation,Builtin,2,10531,0x10cdda1c0,12,TemporalTimeZoneConstructor
code-creation,Builtin,2,10536,0x10cdda200,12,TemporalTimeZoneFrom
code-creation,Builtin,2,10542,0x10cdda240,12,TemporalTimeZonePrototypeId
code-creation,Builtin,2,10547,0x10cdda280,12,TemporalTimeZonePrototypeGetOffsetNanosecondsFor
code-creation,Builtin,2,10554,0x10cdda2c0,12,TemporalTimeZonePrototypeGetOffsetStringFor
code-creation,Builtin,2,10560,0x10cdda300,12,TemporalTimeZonePrototypeGetPlainDateTimeFor
code-creation,Builtin,2,10566,0x10cdda340,12,TemporalTimeZonePrototypeGetInstantFor
code-creation,Builtin,2,10572,0x10cdda380,12,TemporalTimeZonePrototypeGetPossibleInstantsFor
code-creation,Builtin,2,10578,0x10cdda3c0,12,TemporalTimeZonePrototypeGetNextTransition
code-creation,Builtin,2,10584,0x10cdda400,12,TemporalTimeZonePrototypeGetPreviousTransition
code-creation,Builtin,2,10591,0x10cdda440,12,TemporalTimeZonePrototypeToString
code-creation,Builtin,2,10596,0x10cdda480,12,TemporalTimeZonePrototypeToJSON
code-creation,Builtin,2,10602,0x10cdda4c0,12,TemporalCalendarConstructor
code-creation,Builtin,2,10608,0x10cdda500,12,TemporalCalendarFrom
code-creation,Builtin,2,10613,0x10cdda540,12,TemporalCalendarPrototypeId
code-creation,Builtin,2,10618,0x10cdda580,12,TemporalCalendarPrototypeDateFromFields
code-creation,Builtin,2,10624,0x10cdda5c0,12,TemporalCalendarPrototypeYearMonthFromFields
code-creation,Builtin,2,10631,0x10cdda600,12,TemporalCalendarPrototypeMonthDayFromFields
code-creation,Builtin,2,10637,0x10cdda640,12,TemporalCalendarPrototypeDateAdd
code-creation,Builtin,2,10643,0x10cdda680,12,TemporalCalendarPrototypeDateUntil
code-creation,Builtin,2,10648,0x10cdda6c0,12,TemporalCalendarPrototypeYear
code-creation,Builtin,2,10654,0x10cdda700,12,TemporalCalendarPrototypeMonth
code-creation,Builtin,2,10659,0x10cdda740,12,TemporalCalendarPrototypeMonthCode
code-creation,Builtin,2,10665,0x10cdda780,12,TemporalCalendarPrototypeDay
code-creation,Builtin,2,10671,0x10cdda7c0,12,TemporalCalendarPrototypeDayOfWeek
code-creation,Builtin,2,10677,0x10cdda800,12,TemporalCalendarPrototypeDayOfYear
code-creation,Builtin,2,10682,0x10cdda840,12,TemporalCalendarPrototypeWeekOfYear
code-creation,Builtin,2,10688,0x10cdda880,12,TemporalCalendarPrototypeDaysInWeek
code-creation,Builtin,2,10694,0x10cdda8c0,12,TemporalCalendarPrototypeDaysInMonth
code-creation,Builtin,2,10700,0x10cdda900,12,TemporalCalendarPrototypeDaysInYear
code-creation,Builtin,2,10706,0x10cdda940,12,TemporalCalendarPrototypeMonthsInYear
code-creation,Builtin,2,10712,0x10cdda980,12,TemporalCalendarPrototypeInLeapYear
code-creation,Builtin,2,10717,0x10cdda9c0,3456,TemporalCalendarPrototypeFields
code-creation,Builtin,2,10723,0x10cddb780,12,TemporalCalendarPrototypeMergeFields
code-creation,Builtin,2,10729,0x10cddb7c0,12,TemporalCalendarPrototypeToString
code-creation,Builtin,2,10735,0x10cddb800,12,TemporalCalendarPrototypeToJSON
code-creation,Builtin,2,10740,0x10cddb840,12,DatePrototypeToTemporalInstant
code-creation,Builtin,2,10746,0x10cddb880,1716,StringFixedArrayFromIterable
code-creation,Builtin,2,10751,0x10cddbf40,1716,TemporalInstantFixedArrayFromIterable
code-creation,Builtin,2,10757,0x10cddc600,260,AggregateErrorConstructor
code-creation,Builtin,2,10763,0x10cddc740,844,ArrayPrototypeAt
code-creation,Builtin,2,10768,0x10cddcac0,552,ArrayPrototypeConcat
code-creation,Builtin,2,10773,0x10cddcd00,5092,ArrayPrototypeCopyWithin
code-creation,Builtin,2,10778,0x10cdde100,212,ArrayEveryLoopEagerDeoptContinuation
code-creation,Builtin,2,10784,0x10cdde200,568,ArrayEveryLoopLazyDeoptContinuation
code-creation,Builtin,2,10790,0x10cdde440,4024,ArrayEveryLoopContinuation
code-creation,Builtin,2,10795,0x10cddf400,1452,ArrayEvery
code-creation,Builtin,2,10800,0x10cddf9c0,276,ArrayFilterLoopEagerDeoptContinuation
code-creation,Builtin,2,10812,0x10cddfb00,860,ArrayFilterLoopLazyDeoptContinuation
code-creation,Builtin,2,10819,0x10cddfe80,4280,ArrayFilterLoopContinuation
code-creation,Builtin,2,10824,0x10cde0f40,4264,ArrayFilter
code-creation,Builtin,2,10829,0x10cde2000,204,ArrayFindLoopEagerDeoptContinuation
code-creation,Builtin,2,10834,0x10cde2100,32,ArrayFindLoopLazyDeoptContinuation
code-creation,Builtin,2,10840,0x10cde2140,308,ArrayFindLoopAfterCallbackLazyDeoptContinuation
code-creation,Builtin,2,10847,0x10cde2280,496,ArrayFindLoopContinuation
code-creation,Builtin,2,10852,0x10cde2480,1428,ArrayPrototypeFind
code-creation,Builtin,2,10857,0x10cde2a40,204,ArrayFindIndexLoopEagerDeoptContinuation
code-creation,Builtin,2,10865,0x10cde2b40,32,ArrayFindIndexLoopLazyDeoptContinuation
code-creation,Builtin,2,10871,0x10cde2b80,308,ArrayFindIndexLoopAfterCallbackLazyDeoptContinuation
code-creation,Builtin,2,10878,0x10cde2cc0,492,ArrayFindIndexLoopContinuation
code-creation,Builtin,2,10883,0x10cde2ec0,1432,ArrayPrototypeFindIndex
code-creation,Builtin,2,10889,0x10cde3480,428,ArrayFindLastLoopContinuation
code-creation,Builtin,2,10894,0x10cde3640,1624,ArrayPrototypeFindLast
code-creation,Builtin,2,10900,0x10cde3cc0,424,ArrayFindLastIndexLoopContinuation
code-creation,Builtin,2,10905,0x10cde3e80,1620,ArrayPrototypeFindLastIndex
code-creation,Builtin,2,10911,0x10cde4500,212,ArrayForEachLoopEagerDeoptContinuation
code-creation,Builtin,2,10917,0x10cde4600,212,ArrayForEachLoopLazyDeoptContinuation
code-creation,Builtin,2,10923,0x10cde4700,3904,ArrayForEachLoopContinuation
code-creation,Builtin,2,10928,0x10cde5680,1292,ArrayForEach
code-creation,Builtin,2,10933,0x10cde5bc0,4288,ArrayFrom
code-creation,Builtin,2,10938,0x10cde6cc0,168,ArrayIsArray
code-creation,Builtin,2,10942,0x10cde6d80,392,LoadJoinElement_DictionaryElements_0
code-creation,Builtin,2,10948,0x10cde6f40,40,LoadJoinElement_FastSmiOrObjectElements_0
code-creation,Builtin,2,10954,0x10cde6f80,132,LoadJoinElement_FastDoubleElements_0
code-creation,Builtin,2,10960,0x10cde7040,208,ConvertToLocaleString
code-creation,Builtin,2,10965,0x10cde7140,728,JoinStackPush
code-creation,Builtin,2,10970,0x10cde7440,272,JoinStackPop
code-creation,Builtin,2,10975,0x10cde7580,9092,ArrayPrototypeJoin
code-creation,Builtin,2,10980,0x10cde9940,5868,ArrayPrototypeToLocaleString
code-creation,Builtin,2,10985,0x10cdeb040,236,ArrayPrototypeToString
code-creation,Builtin,2,10991,0x10cdeb140,8928,TypedArrayPrototypeJoin
code-creation,Builtin,2,10996,0x10cded440,5664,TypedArrayPrototypeToLocaleString
code-creation,Builtin,2,11002,0x10cdeea80,4296,ArrayPrototypeLastIndexOf
code-creation,Builtin,2,11007,0x10cdefb80,256,ArrayMapPreLoopLazyDeoptContinuation
code-creation,Builtin,2,11047,0x10cdefcc0,244,ArrayMapLoopEagerDeoptContinuation
code-creation,Builtin,2,11056,0x10cdefdc0,468,ArrayMapLoopLazyDeoptContinuation
code-creation,Builtin,2,11065,0x10cdeffc0,3932,ArrayMapLoopContinuation
code-creation,Builtin,2,11073,0x10cdf0f40,3696,ArrayMap
code-creation,Builtin,2,11080,0x10cdf1dc0,1396,ArrayOf
code-creation,Builtin,2,11085,0x10cdf2340,412,ArrayReduceRightPreLoopEagerDeoptContinuation
code-creation,Builtin,2,11093,0x10cdf2500,204,ArrayReduceRightLoopEagerDeoptContinuation
code-creation,Builtin,2,11101,0x10cdf2600,204,ArrayReduceRightLoopLazyDeoptContinuation
code-creation,Builtin,2,11110,0x10cdf2700,3920,ArrayReduceRightLoopContinuation
code-creation,Builtin,2,11118,0x10cdf3680,1880,ArrayReduceRight
code-creation,Builtin,2,11123,0x10cdf3e00,180,ArrayReducePreLoopEagerDeoptContinuation
code-creation,Builtin,2,11129,0x10cdf3ec0,204,ArrayReduceLoopEagerDeoptContinuation
code-creation,Builtin,2,11137,0x10cdf3fc0,204,ArrayReduceLoopLazyDeoptContinuation
code-creation,Builtin,2,11143,0x10cdf40c0,3980,ArrayReduceLoopContinuation
code-creation,Builtin,2,11150,0x10cdf5080,1516,ArrayReduce
code-creation,Builtin,2,11155,0x10cdf5680,3464,ArrayPrototypeReverse
code-creation,Builtin,2,11162,0x10cdf6440,3724,ArrayPrototypeShift
code-creation,Builtin,2,11167,0x10cdf7300,5412,ArrayPrototypeSlice
code-creation,Builtin,2,11176,0x10cdf8840,212,ArraySomeLoopEagerDeoptContinuation
code-creation,Builtin,2,11196,0x10cdf8940,532,ArraySomeLoopLazyDeoptContinuation
code-creation,Builtin,2,11205,0x10cdf8b80,4012,ArraySomeLoopContinuation
code-creation,Builtin,2,11211,0x10cdf9b40,1436,ArraySome
code-creation,Builtin,2,11215,0x10cdfa100,14400,ArrayPrototypeSplice
code-creation,Builtin,2,11220,0x10cdfd980,1652,GenericArrayToReversed
code-creation,Builtin,2,11227,0x10cdfe000,2748,ArrayPrototypeToReversed
code-creation,Builtin,2,11233,0x10cdfeac0,5076,ArrayTimSortIntoCopy
code-creation,Builtin,2,11238,0x10cdffec0,2148,ArrayPrototypeToSorted
code-creation,Builtin,2,11245,0x10ce00740,8568,ArrayPrototypeToSpliced
code-creation,Builtin,2,11252,0x10ce028c0,3036,ArrayPrototypeUnshift
code-creation,Builtin,2,11259,0x10ce034c0,1004,GenericArrayWith
code-creation,Builtin,2,11266,0x10ce038c0,1132,ArrayPrototypeWith
code-creation,Builtin,2,11273,0x10ce03d40,324,ArrayBufferPrototypeGetByteLength
code-creation,Builtin,2,11280,0x10ce03ec0,484,ArrayBufferPrototypeGetMaxByteLength
code-creation,Builtin,2,11288,0x10ce040c0,216,ArrayBufferPrototypeGetResizable
code-creation,Builtin,2,11296,0x10ce041c0,216,ArrayBufferPrototypeGetDetached
code-creation,Builtin,2,11303,0x10ce042c0,324,SharedArrayBufferPrototypeGetMaxByteLength
code-creation,Builtin,2,11311,0x10ce04440,216,SharedArrayBufferPrototypeGetGrowable
code-creation,Builtin,2,11319,0x10ce04540,100,ArrayBufferIsView
code-creation,Builtin,2,11326,0x10ce045c0,388,ToInteger
code-creation,Builtin,2,11332,0x10ce04780,3080,FastCreateDataProperty
code-creation,Builtin,2,11340,0x10ce053c0,640,CheckSameObject
code-creation,Builtin,2,11346,0x10ce05680,1048,BooleanConstructor
code-creation,Builtin,2,11353,0x10ce05ac0,164,BooleanPrototypeToString
code-creation,Builtin,2,11360,0x10ce05b80,160,BooleanPrototypeValueOf
code-creation,Builtin,2,11368,0x10ce05c40,1068,BigIntAddNoThrow
code-creation,Builtin,2,11374,0x10ce06080,1144,BigIntAdd
code-creation,Builtin,2,11381,0x10ce06500,1068,BigIntSubtractNoThrow
code-creation,Builtin,2,11388,0x10ce06940,1144,BigIntSubtract
code-creation,Builtin,2,11395,0x10ce06dc0,328,BigIntMultiplyNoThrow
code-creation,Builtin,2,11402,0x10ce06f40,444,BigIntMultiply
code-creation,Builtin,2,11408,0x10ce07100,544,BigIntDivideNoThrow
code-creation,Builtin,2,11415,0x10ce07340,652,BigIntDivide
code-creation,Builtin,2,11422,0x10ce07600,464,BigIntModulusNoThrow
code-creation,Builtin,2,11429,0x10ce07800,568,BigIntModulus
code-creation,Builtin,2,11436,0x10ce07a40,964,BigIntBitwiseAndNoThrow
code-creation,Builtin,2,11443,0x10ce07e40,1108,BigIntBitwiseAnd
code-creation,Builtin,2,11450,0x10ce082c0,936,BigIntBitwiseOrNoThrow
code-creation,Builtin,2,11457,0x10ce08680,1052,BigIntBitwiseOr
code-creation,Builtin,2,11463,0x10ce08ac0,976,BigIntBitwiseXorNoThrow
code-creation,Builtin,2,11470,0x10ce08ec0,1124,BigIntBitwiseXor
code-creation,Builtin,2,11477,0x10ce09340,1296,BigIntShiftLeftNoThrow
code-creation,Builtin,2,11484,0x10ce09880,1420,BigIntShiftLeft
code-creation,Builtin,2,11491,0x10ce09e40,1296,BigIntShiftRightNoThrow
code-creation,Builtin,2,11498,0x10ce0a380,1420,BigIntShiftRight
code-creation,Builtin,2,11503,0x10ce0a940,108,BigIntEqual
code-creation,Builtin,2,11510,0x10ce0a9c0,168,BigIntLessThan
code-creation,Builtin,2,11516,0x10ce0aa80,168,BigIntGreaterThan
code-creation,Builtin,2,11523,0x10ce0ab40,168,BigIntLessThanOrEqual
code-creation,Builtin,2,11530,0x10ce0ac00,168,BigIntGreaterThanOrEqual
code-creation,Builtin,2,11537,0x10ce0acc0,264,BigIntUnaryMinus
code-creation,Builtin,2,11544,0x10ce0ae00,1988,ToString
code-creation,Builtin,2,11551,0x10ce0b600,160,StringPrototypeToString
code-creation,Builtin,2,11558,0x10ce0b6c0,160,StringPrototypeValueOf
code-creation,Builtin,2,11563,0x10ce0b780,2228,StringToList
code-creation,Builtin,2,11568,0x10ce0c040,788,StringPrototypeCharAt
code-creation,Builtin,2,11575,0x10ce0c380,680,StringPrototypeCharCodeAt
code-creation,Builtin,2,11581,0x10ce0c640,1188,StringPrototypeCodePointAt
code-creation,Builtin,2,11586,0x10ce0cb00,416,StringPrototypeConcat
code-creation,Builtin,2,11591,0x10ce0ccc0,1048,StringConstructor
code-creation,Builtin,2,11607,0x10ce0d100,2060,StringAddConvertLeft
code-creation,Builtin,2,11614,0x10ce0d940,2084,StringAddConvertRight
code-creation,Builtin,2,11619,0x10ce0e180,572,StringCharAt
code-creation,Builtin,2,11624,0x10ce0e3c0,16,FastNewClosureBaseline
code-creation,Builtin,2,11629,0x10ce0e400,228,FastNewFunctionContextEval
code-creation,Builtin,2,11634,0x10ce0e500,228,FastNewFunctionContextFunction
code-creation,Builtin,2,11641,0x10ce0e600,240,CreateRegExpLiteral
code-creation,Builtin,2,11649,0x10ce0e700,1208,CreateShallowArrayLiteral
code-creation,Builtin,2,11656,0x10ce0ebc0,484,CreateEmptyArrayLiteral
code-creation,Builtin,2,11661,0x10ce0edc0,2004,CreateShallowObjectLiteral
code-creation,Builtin,2,11668,0x10ce0f5c0,392,ObjectConstructor
code-creation,Builtin,2,11675,0x10ce0f780,188,CreateEmptyLiteralObject
code-creation,Builtin,2,11681,0x10ce0f840,540,NumberConstructor
code-creation,Builtin,2,11688,0x10ce0fa80,60,GenericLazyDeoptContinuation
code-creation,Builtin,2,11695,0x10ce0fac0,60,StringToNumber
code-creation,Builtin,2,11702,0x10ce0fb00,188,NonNumberToNumber
code-creation,Builtin,2,11709,0x10ce0fbc0,244,NonNumberToNumeric
code-creation,Builtin,2,11717,0x10ce0fcc0,36,ToNumeric
code-creation,Builtin,2,11723,0x10ce0fd00,1268,NumberToString
code-creation,Builtin,2,11730,0x10ce10200,108,ToBoolean
code-creation,Builtin,2,11736,0x10ce10280,104,ToBooleanForBaselineJump
code-creation,Builtin,2,11743,0x10ce10300,600,ToLength
code-creation,Builtin,2,11750,0x10ce10580,1312,ToName
code-creation,Builtin,2,11756,0x10ce10ac0,864,ToObject
code-creation,Builtin,2,11763,0x10ce10e40,236,NonPrimitiveToPrimitive_Default
code-creation,Builtin,2,11770,0x10ce10f40,236,NonPrimitiveToPrimitive_Number
code-creation,Builtin,2,11778,0x10ce11040,584,NonPrimitiveToPrimitive_String
code-creation,Builtin,2,11785,0x10ce112c0,20,OrdinaryToPrimitive_Number
code-creation,Builtin,2,11792,0x10ce11300,380,OrdinaryToPrimitive_Number_Inline
code-creation,Builtin,2,11800,0x10ce11480,380,OrdinaryToPrimitive_String
code-creation,Builtin,2,11807,0x10ce11600,224,FastConsoleAssert
code-creation,Builtin,2,11814,0x10ce11700,184,DataViewPrototypeGetBuffer
code-creation,Builtin,2,11821,0x10ce117c0,764,DataViewPrototypeGetByteLength
code-creation,Builtin,2,11829,0x10ce11ac0,440,DataViewPrototypeGetByteOffset
code-creation,Builtin,2,11836,0x10ce11c80,848,DataViewPrototypeGetUint8
code-creation,Builtin,2,11844,0x10ce12000,848,DataViewPrototypeGetInt8
code-creation,Builtin,2,11852,0x10ce12380,924,DataViewPrototypeGetUint16
code-creation,Builtin,2,11859,0x10ce12740,920,DataViewPrototypeGetInt16
code-creation,Builtin,2,11866,0x10ce12b00,1076,DataViewPrototypeGetUint32
code-creation,Builtin,2,11873,0x10ce12f40,956,DataViewPrototypeGetInt32
code-creation,Builtin,2,11878,0x10ce13300,1112,DataViewPrototypeGetFloat32
code-creation,Builtin,2,11886,0x10ce13780,1176,DataViewPrototypeGetFloat64
code-creation,Builtin,2,11893,0x10ce13c40,1232,DataViewPrototypeGetBigUint64
code-creation,Builtin,2,11900,0x10ce14140,1256,DataViewPrototypeGetBigInt64
code-creation,Builtin,2,11907,0x10ce14640,1264,DataViewPrototypeSetUint8
code-creation,Builtin,2,11912,0x10ce14b40,1264,DataViewPrototypeSetInt8
code-creation,Builtin,2,11920,0x10ce15040,1348,DataViewPrototypeSetUint16
code-creation,Builtin,2,11927,0x10ce155c0,1348,DataViewPrototypeSetInt16
code-creation,Builtin,2,11933,0x10ce15b40,1388,DataViewPrototypeSetUint32
code-creation,Builtin,2,11938,0x10ce160c0,1388,DataViewPrototypeSetInt32
code-creation,Builtin,2,11944,0x10ce16640,1356,DataViewPrototypeSetFloat32
code-creation,Builtin,2,11949,0x10ce16bc0,1412,DataViewPrototypeSetFloat64
code-creation,Builtin,2,11955,0x10ce17180,1264,DataViewPrototypeSetBigUint64
code-creation,Builtin,2,11960,0x10ce17680,1264,DataViewPrototypeSetBigInt64
code-creation,Builtin,2,11974,0x10ce17b80,928,FinalizationRegistryConstructor
code-creation,Builtin,2,11982,0x10ce17f40,1220,FinalizationRegistryRegister
code-creation,Builtin,2,11988,0x10ce18440,664,FinalizationRegistryPrototypeCleanupSome
code-creation,Builtin,2,12007,0x10ce18700,340,FunctionPrototypeHasInstance
code-creation,Builtin,2,12045,0x10ce18880,940,FastFunctionPrototypeBind
code-creation,Builtin,2,12055,0x10ce18c40,92,IncBlockCounter
code-creation,Builtin,2,12062,0x10ce18cc0,240,GetTemplateObject
code-creation,Builtin,2,12070,0x10ce18dc0,92,ForInNext
code-creation,Builtin,2,12079,0x10ce18e40,136,GetImportMetaObjectBaseline
code-creation,Builtin,2,12087,0x10ce18f00,112,GetIteratorWithFeedback
code-creation,Builtin,2,12094,0x10ce18f80,100,GetIteratorBaseline
code-creation,Builtin,2,12101,0x10ce19000,296,CreateAsyncFromSyncIteratorBaseline
code-creation,Builtin,2,12109,0x10ce19140,1068,CallIteratorWithFeedback
code-creation,Builtin,2,12116,0x10ce19580,916,IteratorConstructor
code-creation,Builtin,2,12123,0x10ce19940,1012,IteratorFrom
code-creation,Builtin,2,12130,0x10ce19d40,160,WrapForValidIteratorPrototypeNext
code-creation,Builtin,2,12137,0x10ce19e00,408,WrapForValidIteratorPrototypeReturn
code-creation,Builtin,2,12145,0x10ce19fc0,256,IteratorHelperPrototypeNext
code-creation,Builtin,2,12152,0x10ce1a100,400,IteratorHelperPrototypeReturn
code-creation,Builtin,2,12159,0x10ce1a2c0,440,IteratorPrototypeMap
code-creation,Builtin,2,12166,0x10ce1a480,1200,IteratorMapHelperNext
code-creation,Builtin,2,12173,0x10ce1a940,440,IteratorPrototypeFilter
code-creation,Builtin,2,12180,0x10ce1ab00,1352,IteratorFilterHelperNext
code-creation,Builtin,2,12187,0x10ce1b080,568,IteratorPrototypeTake
code-creation,Builtin,2,12194,0x10ce1b2c0,1356,IteratorTakeHelperNext
code-creation,Builtin,2,12201,0x10ce1b840,568,IteratorPrototypeDrop
code-creation,Builtin,2,12209,0x10ce1ba80,1540,IteratorDropHelperNext
code-creation,Builtin,2,12217,0x10ce1c0c0,272,MathAbs
code-creation,Builtin,2,12221,0x10ce1c200,420,MathCeil
code-creation,Builtin,2,12229,0x10ce1c3c0,424,MathFloor
code-creation,Builtin,2,12236,0x10ce1c580,472,MathRound
code-creation,Builtin,2,12243,0x10ce1c780,420,MathTrunc
code-creation,Builtin,2,12250,0x10ce1c940,360,MathPow
code-creation,Builtin,2,12256,0x10ce1cac0,408,MathMax
code-creation,Builtin,2,12262,0x10ce1cc80,412,MathMin
code-creation,Builtin,2,12269,0x10ce1ce40,312,MathAcos
code-creation,Builtin,2,12275,0x10ce1cf80,312,MathAcosh
code-creation,Builtin,2,12281,0x10ce1d0c0,312,MathAsin
code-creation,Builtin,2,12288,0x10ce1d200,312,MathAsinh
code-creation,Builtin,2,12294,0x10ce1d340,312,MathAtan
code-creation,Builtin,2,12300,0x10ce1d480,404,MathAtan2
code-creation,Builtin,2,12307,0x10ce1d640,312,MathAtanh
code-creation,Builtin,2,12313,0x10ce1d780,312,MathCbrt
code-creation,Builtin,2,12320,0x10ce1d8c0,168,MathClz32
code-creation,Builtin,2,12325,0x10ce1d980,312,MathCos
code-creation,Builtin,2,12329,0x10ce1dac0,312,MathCosh
code-creation,Builtin,2,12334,0x10ce1dc00,312,MathExp
code-creation,Builtin,2,12338,0x10ce1dd40,312,MathExpm1
code-creation,Builtin,2,12343,0x10ce1de80,264,MathFround
code-creation,Builtin,2,12347,0x10ce1dfc0,304,MathImul
code-creation,Builtin,2,12351,0x10ce1e100,312,MathLog
code-creation,Builtin,2,12356,0x10ce1e240,312,MathLog1p
code-creation,Builtin,2,12363,0x10ce1e380,312,MathLog10
code-creation,Builtin,2,12369,0x10ce1e4c0,312,MathLog2
code-creation,Builtin,2,12375,0x10ce1e600,312,MathSin
tick,0x7ff809303823,12388,0,0x0,6
tick,0x7ff8092cbace,12407,0,0x0,6
code-creation,Builtin,2,12419,0x10ce1e740,176,MathSign
code-creation,Builtin,2,12427,0x10ce1e800,312,MathSinh
code-creation,Builtin,2,12432,0x10ce1e940,260,MathSqrt
code-creation,Builtin,2,12437,0x10ce1ea80,312,MathTan
code-creation,Builtin,2,12442,0x10ce1ebc0,312,MathTanh
code-creation,Builtin,2,12446,0x10ce1ed00,1016,MathHypot
code-creation,Builtin,2,12451,0x10ce1f100,320,MathRandom
code-creation,Builtin,2,12456,0x10ce1f280,2532,NumberPrototypeToString
code-creation,Builtin,2,12461,0x10ce1fc80,132,NumberIsFinite
code-creation,Builtin,2,12466,0x10ce1fd40,332,NumberIsInteger
code-creation,Builtin,2,12471,0x10ce1fec0,128,NumberIsNaN
code-creation,Builtin,2,12476,0x10ce1ff80,364,NumberIsSafeInteger
code-creation,Builtin,2,12481,0x10ce20100,160,NumberPrototypeValueOf
code-creation,Builtin,2,12486,0x10ce201c0,200,NumberParseFloat
code-creation,Builtin,2,12501,0x10ce202c0,248,ParseInt
code-creation,Builtin,2,12507,0x10ce203c0,84,NumberParseInt
code-creation,Builtin,2,12512,0x10ce20440,816,Add
code-creation,Builtin,2,12516,0x10ce20780,428,Subtract
code-creation,Builtin,2,12521,0x10ce20940,556,Multiply
code-creation,Builtin,2,12525,0x10ce20b80,500,Divide
code-creation,Builtin,2,12530,0x10ce20d80,548,Modulus
code-creation,Builtin,2,12534,0x10ce20fc0,516,Exponentiate
code-creation,Builtin,2,12539,0x10ce21200,336,Negate
code-creation,Builtin,2,12543,0x10ce21380,160,BitwiseNot
code-creation,Builtin,2,12548,0x10ce21440,112,Decrement
code-creation,Builtin,2,12553,0x10ce214c0,112,Increment
code-creation,Builtin,2,12557,0x10ce21540,516,ShiftLeft
code-creation,Builtin,2,12562,0x10ce21780,516,ShiftRight
code-creation,Builtin,2,12567,0x10ce219c0,588,ShiftRightLogical
code-creation,Builtin,2,12572,0x10ce21c40,304,BitwiseAnd
code-creation,Builtin,2,12576,0x10ce21d80,304,BitwiseOr
code-creation,Builtin,2,12581,0x10ce21ec0,304,BitwiseXor
code-creation,Builtin,2,12586,0x10ce22000,948,LessThan
code-creation,Builtin,2,12590,0x10ce223c0,948,LessThanOrEqual
code-creation,Builtin,2,12595,0x10ce22780,948,GreaterThan
code-creation,Builtin,2,12600,0x10ce22b40,948,GreaterThanOrEqual
code-creation,Builtin,2,12605,0x10ce22f00,1060,Equal
code-creation,Builtin,2,12609,0x10ce23340,512,StrictEqual
code-creation,Builtin,2,12614,0x10ce23580,3236,ObjectFromEntries
code-creation,Builtin,2,12619,0x10ce24240,820,CreateObjectWithoutProperties
code-creation,Builtin,2,12625,0x10ce24580,144,ObjectIsExtensible
code-creation,Builtin,2,12630,0x10ce24640,152,ObjectPreventExtensions
code-creation,Builtin,2,12635,0x10ce24700,148,ObjectGetPrototypeOf
code-creation,Builtin,2,12640,0x10ce247c0,304,ObjectSetPrototypeOf
code-creation,Builtin,2,12645,0x10ce24900,80,ObjectPrototypeToString
code-creation,Builtin,2,12651,0x10ce24980,100,ObjectPrototypeValueOf
code-creation,Builtin,2,12656,0x10ce24a00,176,ObjectPrototypeToLocaleString
code-creation,Builtin,2,12662,0x10ce24ac0,876,FulfillPromise
code-creation,Builtin,2,12667,0x10ce24e40,1012,RejectPromise
code-creation,Builtin,2,12671,0x10ce25240,2500,NewPromiseCapability
code-creation,Builtin,2,12677,0x10ce25c40,192,PromiseCapabilityDefaultReject
code-creation,Builtin,2,12682,0x10ce25d40,172,PromiseCapabilityDefaultResolve
code-creation,Builtin,2,12688,0x10ce25e00,1332,PerformPromiseThen
code-creation,Builtin,2,12693,0x10ce26340,668,PromiseReject
code-creation,Builtin,2,12698,0x10ce26600,304,PromiseGetCapabilitiesExecutor
code-creation,Builtin,2,12703,0x10ce26740,108,PromiseConstructorLazyDeoptContinuation
code-creation,Builtin,2,12709,0x10ce267c0,4516,PromiseAll
code-creation,Builtin,2,12714,0x10ce27980,4856,PromiseAllSettled
code-creation,Builtin,2,12719,0x10ce28c80,1092,PromiseAllResolveElementClosure
code-creation,Builtin,2,12725,0x10ce29100,1436,PromiseAllSettledResolveElementClosure
code-creation,Builtin,2,12731,0x10ce296c0,1444,PromiseAllSettledRejectElementClosure
code-creation,Builtin,2,12737,0x10ce29c80,1168,PromiseAnyRejectElementClosure
code-creation,Builtin,2,12742,0x10ce2a140,2724,PromiseAny
code-creation,Builtin,2,12747,0x10ce2ac00,3040,PromiseConstructor
code-creation,Builtin,2,12752,0x10ce2b800,292,PromisePrototypeCatch
code-creation,Builtin,2,12757,0x10ce2b940,92,PromiseValueThunkFinally
code-creation,Builtin,2,12763,0x10ce2b9c0,84,PromiseThrowerFinally
code-creation,Builtin,2,12768,0x10ce2ba40,988,PromiseCatchFinally
code-creation,Builtin,2,12773,0x10ce2be40,988,PromiseThenFinally
code-creation,Builtin,2,12778,0x10ce2c240,1676,PromisePrototypeFinally
code-creation,Builtin,2,12783,0x10ce2c900,1524,PromiseRace
code-creation,Builtin,2,12788,0x10ce2cf00,348,PromiseFulfillReactionJob
code-creation,Builtin,2,12793,0x10ce2d080,468,PromiseRejectReactionJob
code-creation,Builtin,2,12799,0x10ce2d280,156,PromiseResolveTrampoline
code-creation,Builtin,2,12804,0x10ce2d340,704,PromiseResolve
code-creation,Builtin,2,12809,0x10ce2d640,716,ResolvePromise
code-creation,Builtin,2,12814,0x10ce2d940,2288,PromisePrototypeThen
code-creation,Builtin,2,12819,0x10ce2e240,1260,PromiseResolveThenableJob
code-creation,Builtin,2,12831,0x10ce2e740,440,ProxyConstructor
code-creation,Builtin,2,12836,0x10ce2e900,2472,ProxyDeleteProperty
code-creation,Builtin,2,12842,0x10ce2f2c0,2792,ProxyGetProperty
code-creation,Builtin,2,12847,0x10ce2fdc0,1088,ProxyGetPrototypeOf
code-creation,Builtin,2,12852,0x10ce30240,2396,ProxyHasProperty
code-creation,Builtin,2,12857,0x10ce30bc0,776,ProxyIsExtensible
code-creation,Builtin,2,12862,0x10ce30f00,828,ProxyPreventExtensions
code-creation,Builtin,2,12867,0x10ce31240,1136,ProxyRevocable
code-creation,Builtin,2,12872,0x10ce316c0,136,ProxyRevoke
code-creation,Builtin,2,12877,0x10ce31780,2988,ProxySetProperty
code-creation,Builtin,2,12881,0x10ce32340,1344,ProxySetPrototypeOf
code-creation,Builtin,2,12887,0x10ce328c0,208,ReflectIsExtensible
code-creation,Builtin,2,12892,0x10ce329c0,216,ReflectPreventExtensions
code-creation,Builtin,2,12897,0x10ce32ac0,188,ReflectGetPrototypeOf
code-creation,Builtin,2,12902,0x10ce32b80,332,ReflectSetPrototypeOf
code-creation,Builtin,2,12908,0x10ce32d00,288,ReflectGet
code-creation,Builtin,2,12913,0x10ce32e40,156,ReflectDeleteProperty
code-creation,Builtin,2,12918,0x10ce32f00,144,ReflectHas
code-creation,Builtin,2,12922,0x10ce32fc0,4644,ReflectGetOwnPropertyDescriptor
code-creation,Builtin,2,12928,0x10ce34200,5132,RegExpPrototypeExecSlow
code-creation,Builtin,2,12933,0x10ce35640,5172,RegExpPrototypeExec
code-creation,Builtin,2,12938,0x10ce36a80,2596,RegExpPrototypeMatchAll
code-creation,Builtin,2,12944,0x10ce374c0,9248,RegExpStringIteratorPrototypeNext
code-creation,Builtin,2,12950,0x10ce39900,8680,RegExpMatchFast
code-creation,Builtin,2,12954,0x10ce3bb00,3668,RegExpPrototypeMatch
code-creation,Builtin,2,12960,0x10ce3c980,5876,RegExpReplace
code-creation,Builtin,2,12964,0x10ce3e080,508,RegExpPrototypeReplace
code-creation,Builtin,2,12970,0x10ce3e280,1352,RegExpSearchFast
code-creation,Builtin,2,12975,0x10ce3e800,1660,RegExpPrototypeSearch
code-creation,Builtin,2,12980,0x10ce3ee80,200,RegExpPrototypeSourceGetter
code-creation,Builtin,2,12985,0x10ce3ef80,5840,RegExpSplit
code-creation,Builtin,2,12990,0x10ce40680,468,RegExpPrototypeSplit
code-creation,Builtin,2,12995,0x10ce40880,2236,RegExpPrototypeTest
code-creation,Builtin,2,13000,0x10ce41140,1284,RegExpPrototypeTestFast
code-creation,Builtin,2,13006,0x10ce41680,236,RegExpPrototypeGlobalGetter
code-creation,Builtin,2,13011,0x10ce41780,252,RegExpPrototypeIgnoreCaseGetter
code-creation,Builtin,2,13017,0x10ce41880,252,RegExpPrototypeMultilineGetter
code-creation,Builtin,2,13022,0x10ce41980,252,RegExpPrototypeHasIndicesGetter
code-creation,Builtin,2,13028,0x10ce41a80,252,RegExpPrototypeLinearGetter
code-creation,Builtin,2,13034,0x10ce41b80,252,RegExpPrototypeDotAllGetter
code-creation,Builtin,2,13039,0x10ce41c80,284,RegExpPrototypeStickyGetter
code-creation,Builtin,2,13045,0x10ce41dc0,284,RegExpPrototypeUnicodeGetter
code-creation,Builtin,2,13050,0x10ce41f00,252,RegExpPrototypeUnicodeSetsGetter
code-creation,Builtin,2,13056,0x10ce42000,2556,RegExpPrototypeFlagsGetter
code-creation,Builtin,2,13062,0x10ce42a00,1244,StringPrototypeAt
code-creation,Builtin,2,13067,0x10ce42f00,3016,StringPrototypeEndsWith
code-creation,Builtin,2,13072,0x10ce43b00,496,CreateHTML
code-creation,Builtin,2,13077,0x10ce43d00,140,StringPrototypeAnchor
code-creation,Builtin,2,13082,0x10ce43dc0,120,StringPrototypeBig
code-creation,Builtin,2,13087,0x10ce43e40,120,StringPrototypeBlink
code-creation,Builtin,2,13092,0x10ce43ec0,120,StringPrototypeBold
code-creation,Builtin,2,13097,0x10ce43f40,148,StringPrototypeFontcolor
code-creation,Builtin,2,13102,0x10ce44000,148,StringPrototypeFontsize
code-creation,Builtin,2,13108,0x10ce440c0,120,StringPrototypeFixed
code-creation,Builtin,2,13113,0x10ce44140,120,StringPrototypeItalics
code-creation,Builtin,2,13118,0x10ce441c0,148,StringPrototypeLink
code-creation,Builtin,2,13123,0x10ce44280,120,StringPrototypeSmall
code-creation,Builtin,2,13128,0x10ce44300,120,StringPrototypeStrike
code-creation,Builtin,2,13133,0x10ce44380,120,StringPrototypeSub
code-creation,Builtin,2,13138,0x10ce44400,120,StringPrototypeSup
code-creation,Builtin,2,13150,0x10ce44480,1024,StringPrototypeIncludes
code-creation,Builtin,2,13155,0x10ce448c0,648,StringPrototypeIndexOf
code-creation,Builtin,2,13161,0x10ce44b80,616,StringPrototypeIsWellFormed
code-creation,Builtin,2,13166,0x10ce44e00,348,StringPrototypeIterator
code-creation,Builtin,2,13171,0x10ce44f80,1692,StringIteratorPrototypeNext
code-creation,Builtin,2,13177,0x10ce45640,1372,StringPrototypeMatch
code-creation,Builtin,2,13182,0x10ce45bc0,1372,StringPrototypeSearch
code-creation,Builtin,2,13187,0x10ce46140,768,StringPrototypePadStart
code-creation,Builtin,2,13192,0x10ce46480,772,StringPrototypePadEnd
code-creation,Builtin,2,13198,0x10ce467c0,120,StringRepeat
code-creation,Builtin,2,13202,0x10ce46840,408,StringPrototypeRepeat
code-creation,Builtin,2,13207,0x10ce46a00,10504,StringPrototypeReplaceAll
code-creation,Builtin,2,13213,0x10ce49340,3212,StringPrototypeSlice
code-creation,Builtin,2,13218,0x10ce4a000,3016,StringPrototypeStartsWith
code-creation,Builtin,2,13223,0x10ce4ac00,3140,StringPrototypeSubstr
code-creation,Builtin,2,13228,0x10ce4b880,3064,StringPrototypeSubstring
code-creation,Builtin,2,13234,0x10ce4c480,924,StringPrototypeToWellFormed
code-creation,Builtin,2,13239,0x10ce4c840,6444,StringPrototypeTrim
code-creation,Builtin,2,13255,0x10ce4e180,5932,StringPrototypeTrimStart
code-creation,Builtin,2,13267,0x10ce4f8c0,5504,StringPrototypeTrimEnd
code-creation,Builtin,2,13279,0x10ce50e80,164,SymbolPrototypeDescriptionGetter
code-creation,Builtin,2,13287,0x10ce50f40,160,SymbolPrototypeToPrimitive
code-creation,Builtin,2,13295,0x10ce51000,180,SymbolPrototypeToString
code-creation,Builtin,2,13302,0x10ce510c0,160,SymbolPrototypeValueOf
code-creation,Builtin,2,13309,0x10ce51180,1136,TypedArrayPrototypeAt
code-creation,Builtin,2,13316,0x10ce51600,10528,CreateTypedArray
code-creation,Builtin,2,13323,0x10ce53f40,1720,TypedArrayPrototypeEvery
code-creation,Builtin,2,13330,0x10ce54600,412,TypedArrayPrototypeEntries
code-creation,Builtin,2,13336,0x10ce547c0,4440,TypedArrayPrototypeFilter
code-creation,Builtin,2,13344,0x10ce55940,1720,TypedArrayPrototypeFind
code-creation,Builtin,2,13349,0x10ce56000,1728,TypedArrayPrototypeFindIndex
code-creation,Builtin,2,13355,0x10ce56700,1728,TypedArrayPrototypeFindLast
code-creation,Builtin,2,13360,0x10ce56e00,1736,TypedArrayPrototypeFindLastIndex
code-creation,Builtin,2,13366,0x10ce57500,1588,TypedArrayPrototypeForEach
code-creation,Builtin,2,13373,0x10ce57b40,3048,TypedArrayFrom
code-creation,Builtin,2,13380,0x10ce58740,404,TypedArrayPrototypeKeys
code-creation,Builtin,2,13387,0x10ce58900,1388,TypedArrayOf
code-creation,Builtin,2,13393,0x10ce58e80,1672,TypedArrayPrototypeReduce
code-creation,Builtin,2,13401,0x10ce59540,1672,TypedArrayPrototypeReduceRight
code-creation,Builtin,2,13408,0x10ce59c00,3304,TypedArrayPrototypeSet
code-creation,Builtin,2,13415,0x10ce5a900,4096,TypedArrayPrototypeSlice
code-creation,Builtin,2,13423,0x10ce5b940,1724,TypedArrayPrototypeSome
code-creation,Builtin,2,13430,0x10ce5c000,892,TypedArrayMergeSort
code-creation,Builtin,2,13436,0x10ce5c380,2252,TypedArrayPrototypeSort
code-creation,Builtin,2,13444,0x10ce5cc80,3088,TypedArrayPrototypeSubArray
code-creation,Builtin,2,13451,0x10ce5d8c0,1740,TypedArrayPrototypeToReversed
code-creation,Builtin,2,13458,0x10ce5dfc0,3244,TypedArrayPrototypeToSorted
code-creation,Builtin,2,13466,0x10ce5ec80,412,TypedArrayPrototypeValues
code-creation,Builtin,2,13473,0x10ce5ee40,3144,TypedArrayPrototypeWith
code-creation,Builtin,2,13480,0x10ce5fac0,1104,WeakRefConstructor
code-creation,Builtin,2,13487,0x10ce5ff40,188,WeakRefDeref
code-creation,Builtin,2,13494,0x10ce60000,644,NewSloppyArgumentsElements
code-creation,Builtin,2,13501,0x10ce602c0,296,NewStrictArgumentsElements
code-creation,Builtin,2,13508,0x10ce60400,320,NewRestArgumentsElements
code-creation,Builtin,2,13515,0x10ce60580,1400,FastNewSloppyArguments
code-creation,Builtin,2,13522,0x10ce60b00,508,FastNewStrictArguments
code-creation,Builtin,2,13529,0x10ce60d00,552,FastNewRestArguments
code-creation,Builtin,2,13536,0x10ce60f40,664,StringSlowFlatten
code-creation,Builtin,2,13550,0x10ce61200,1980,StringIndexOf
code-creation,Builtin,2,13558,0x10ce619c0,2028,TestTurbofanType
code-creation,Builtin,2,13565,0x10ce621c0,192,CheckTurbofanType
code-creation,Builtin,2,13572,0x10ce622c0,520,CheckTurboshaftWord32Type
code-creation,Builtin,2,13579,0x10ce62500,952,CheckTurboshaftWord64Type
code-creation,Builtin,2,13586,0x10ce628c0,652,CheckTurboshaftFloat32Type
code-creation,Builtin,2,13594,0x10ce62b80,620,CheckTurboshaftFloat64Type
code-creation,Builtin,2,13601,0x10ce62e00,4,GenericBuiltinTest_JSAny_0
code-creation,Builtin,2,13608,0x10ce62e40,20,TestHelperPlus1
code-creation,Builtin,2,13615,0x10ce62e80,20,TestHelperPlus2
code-creation,Builtin,2,13622,0x10ce62ec0,92,NewSmiBox
code-creation,Builtin,2,13629,0x10ce62f40,24,ReturnTwoValues
code-creation,Builtin,2,13635,0x10ce62f80,28,Load_FastSmiElements_0
code-creation,Builtin,2,13643,0x10ce62fc0,28,Load_FastObjectElements_0
code-creation,Builtin,2,13650,0x10ce63000,140,Load_FastDoubleElements_0
code-creation,Builtin,2,13657,0x10ce630c0,28,Store_FastSmiElements_0
code-creation,Builtin,2,13664,0x10ce63100,92,Store_FastObjectElements_0
code-creation,Builtin,2,13672,0x10ce63180,44,Store_FastDoubleElements_0
code-creation,Builtin,2,13679,0x10ce631c0,36,Delete_FastSmiElements_0
code-creation,Builtin,2,13686,0x10ce63200,36,Delete_FastObjectElements_0
code-creation,Builtin,2,13694,0x10ce63240,40,Delete_FastDoubleElements_0
code-creation,Builtin,2,13701,0x10ce63280,200,SortCompareDefault
code-creation,Builtin,2,13708,0x10ce63380,96,SortCompareUserFn
code-creation,Builtin,2,13715,0x10ce63400,12,CanUseSameAccessor_GenericElementsAccessor_0
code-creation,Builtin,2,13723,0x10ce63440,296,Copy
code-creation,Builtin,2,13729,0x10ce63580,5676,MergeAt
code-creation,Builtin,2,13736,0x10ce64bc0,824,GallopLeft
code-creation,Builtin,2,13741,0x10ce64f00,868,GallopRight
code-creation,Builtin,2,13746,0x10ce65280,3712,ArrayTimSort
code-creation,Builtin,2,13752,0x10ce66140,2020,ArrayPrototypeSort
code-creation,Builtin,2,13759,0x10ce66940,3532,StringFastLocaleCompare
code-creation,Builtin,2,13765,0x10ce67740,92,WasmInt32ToHeapNumber
code-creation,Builtin,2,13772,0x10ce677c0,32,WasmFuncRefToJS
code-creation,Builtin,2,13777,0x10ce67800,124,WasmTaggedNonSmiToInt32
code-creation,Builtin,2,13782,0x10ce67880,76,WasmTaggedToFloat64
code-creation,Builtin,2,13787,0x10ce67900,72,WasmMemoryGrow
code-creation,Builtin,2,13792,0x10ce67980,88,WasmTableInit
code-creation,Builtin,2,13797,0x10ce67a00,88,WasmTableCopy
tick,0x7ff8092cbace,13806,0,0x0,6
code-creation,Builtin,2,13826,0x10ce67a80,76,WasmTableFill
code-creation,Builtin,2,13834,0x10ce67b00,68,WasmTableGrow
code-creation,Builtin,2,13840,0x10ce67b80,76,WasmTableGet
code-creation,Builtin,2,13846,0x10ce67c00,148,WasmTableSet
code-creation,Builtin,2,13851,0x10ce67cc0,144,WasmTableGetFuncRef
code-creation,Builtin,2,13856,0x10ce67d80,104,WasmTableSetFuncRef
code-creation,Builtin,2,13861,0x10ce67e00,80,WasmRefFunc
code-creation,Builtin,2,13866,0x10ce67e80,136,WasmAllocateFixedArray
code-creation,Builtin,2,13872,0x10ce67f40,44,WasmThrow
code-creation,Builtin,2,13877,0x10ce67f80,56,WasmRethrow
code-creation,Builtin,2,13882,0x10ce67fc0,44,WasmRethrowExplicitContext
code-creation,Builtin,2,13887,0x10ce68000,44,WasmTriggerTierUp
code-creation,Builtin,2,13892,0x10ce68040,32,WasmStackGuard
code-creation,Builtin,2,13897,0x10ce68080,32,WasmStackOverflow
code-creation,Builtin,2,13902,0x10ce680c0,40,WasmTraceMemory
code-creation,Builtin,2,13907,0x10ce68100,32,WasmTraceEnter
code-creation,Builtin,2,13912,0x10ce68140,40,WasmTraceExit
code-creation,Builtin,2,13917,0x10ce68180,340,WasmAllocateJSArray
code-creation,Builtin,2,13922,0x10ce68300,100,WasmAllocateStructWithRtt
code-creation,Builtin,2,13927,0x10ce68380,128,WasmAllocateArray_Uninitialized
code-creation,Builtin,2,13933,0x10ce68440,84,WasmArrayNewSegment
code-creation,Builtin,2,13938,0x10ce684c0,136,WasmArrayCopyWithChecks
code-creation,Builtin,2,13943,0x10ce68580,100,WasmArrayCopy
code-creation,Builtin,2,13948,0x10ce68600,260,WasmAllocateObjectWrapper
code-creation,Builtin,2,13965,0x10ce68740,48,WasmSubtypeCheck
code-creation,Builtin,2,13970,0x10ce68780,8,WasmInt32ToNumber
code-creation,Builtin,2,13975,0x10ce687c0,108,WasmUint32ToNumber
code-creation,Builtin,2,13981,0x10ce68840,140,UintPtr53ToNumber
code-creation,Builtin,2,13986,0x10ce68900,92,WasmAtomicNotify
code-creation,Builtin,2,13991,0x10ce68980,100,WasmI32AtomicWait
code-creation,Builtin,2,13996,0x10ce68a00,88,WasmI64AtomicWait
code-creation,Builtin,2,14001,0x10ce68a80,1216,CallRefIC
code-creation,Builtin,2,14006,0x10ce68f80,1572,WasmGetOwnProperty
code-creation,Builtin,2,14011,0x10ce695c0,76,WasmTrap
code-creation,Builtin,2,14015,0x10ce69640,16,ThrowWasmTrapUnreachable
code-creation,Builtin,2,14021,0x10ce69680,16,ThrowWasmTrapMemOutOfBounds
code-creation,Builtin,2,14026,0x10ce696c0,16,ThrowWasmTrapUnalignedAccess
code-creation,Builtin,2,14032,0x10ce69700,16,ThrowWasmTrapDivByZero
code-creation,Builtin,2,14037,0x10ce69740,16,ThrowWasmTrapDivUnrepresentable
code-creation,Builtin,2,14043,0x10ce69780,16,ThrowWasmTrapRemByZero
code-creation,Builtin,2,14048,0x10ce697c0,16,ThrowWasmTrapFloatUnrepresentable
code-creation,Builtin,2,14054,0x10ce69800,16,ThrowWasmTrapFuncSigMismatch
code-creation,Builtin,2,14059,0x10ce69840,16,ThrowWasmTrapDataSegmentOutOfBounds
code-creation,Builtin,2,14065,0x10ce69880,16,ThrowWasmTrapElementSegmentOutOfBounds
code-creation,Builtin,2,14071,0x10ce698c0,16,ThrowWasmTrapTableOutOfBounds
code-creation,Builtin,2,14077,0x10ce69900,16,ThrowWasmTrapRethrowNull
code-creation,Builtin,2,14082,0x10ce69940,16,ThrowWasmTrapNullDereference
code-creation,Builtin,2,14088,0x10ce69980,16,ThrowWasmTrapIllegalCast
code-creation,Builtin,2,14093,0x10ce699c0,16,ThrowWasmTrapArrayOutOfBounds
code-creation,Builtin,2,14098,0x10ce69a00,16,ThrowWasmTrapArrayTooLarge
code-creation,Builtin,2,14104,0x10ce69a40,16,ThrowWasmTrapStringOffsetOutOfBounds
code-creation,Builtin,2,14110,0x10ce69a80,1016,ExperimentalWasmConvertArrayToString
code-creation,Builtin,2,14116,0x10ce69e80,832,ExperimentalWasmConvertStringToArray
code-creation,Builtin,2,14122,0x10ce6a200,148,WasmStringNewWtf8
code-creation,Builtin,2,14127,0x10ce6a2c0,104,WasmStringNewWtf8Array
code-creation,Builtin,2,14132,0x10ce6a340,140,WasmStringNewWtf16
code-creation,Builtin,2,14137,0x10ce6a400,868,WasmStringNewWtf16Array
code-creation,Builtin,2,14143,0x10ce6a780,52,WasmStringAsWtf16
code-creation,Builtin,2,14147,0x10ce6a7c0,48,WasmStringConst
code-creation,Builtin,2,14152,0x10ce6a800,108,WasmStringMeasureUtf8
code-creation,Builtin,2,14158,0x10ce6a880,108,WasmStringMeasureWtf8
code-creation,Builtin,2,14163,0x10ce6a900,156,WasmStringEncodeWtf8
code-creation,Builtin,2,14168,0x10ce6a9c0,148,WasmStringEncodeWtf8Array
code-creation,Builtin,2,14173,0x10ce6aa80,104,WasmStringEncodeWtf16
code-creation,Builtin,2,14179,0x10ce6ab00,724,WasmStringEncodeWtf16Array
code-creation,Builtin,2,14184,0x10ce6ae00,68,ThrowToLowerCaseCalledOnNull
code-creation,Builtin,2,14190,0x10ce6ae80,20,WasmStringConcat
code-creation,Builtin,2,14195,0x10ce6aec0,60,WasmStringEqual
code-creation,Builtin,2,14200,0x10ce6af00,140,WasmStringIsUSVSequence
code-creation,Builtin,2,14205,0x10ce6afc0,40,WasmStringAsWtf8
code-creation,Builtin,2,14210,0x10ce6b000,224,WasmStringViewWtf8Advance
code-creation,Builtin,2,14215,0x10ce6b100,168,WasmStringViewWtf8Encode
code-creation,Builtin,2,14221,0x10ce6b1c0,172,WasmStringViewWtf8Slice
code-creation,Builtin,2,14226,0x10ce6b280,512,WasmStringViewWtf16GetCodeUnit
code-creation,Builtin,2,14232,0x10ce6b4c0,140,WasmStringViewWtf16Encode
code-creation,Builtin,2,14237,0x10ce6b580,2420,WasmStringViewWtf16Slice
code-creation,Builtin,2,14242,0x10ce6bf00,100,WasmStringAsIter
code-creation,Builtin,2,14247,0x10ce6bf80,1124,WasmStringViewIterNext
code-creation,Builtin,2,14253,0x10ce6c400,1224,WasmStringViewIterAdvance
code-creation,Builtin,2,14258,0x10ce6c900,1204,WasmStringViewIterRewind
code-creation,Builtin,2,14263,0x10ce6cdc0,3252,WasmStringViewIterSlice
code-creation,Builtin,2,14269,0x10ce6da80,80,WasmStringFromCodePoint
code-creation,Builtin,2,14274,0x10ce6db00,36,WasmStringHash
code-creation,Builtin,2,14286,0x10ce6db40,60,WasmExternInternalize
code-creation,Builtin,2,14291,0x10ce6db80,164,LoadJoinElement_GenericElementsAccessor_0
code-creation,Builtin,2,14298,0x10ce6dc40,24,LoadJoinTypedElement_Int32Elements_0
code-creation,Builtin,2,14304,0x10ce6dc80,108,LoadJoinTypedElement_Float32Elements_0
code-creation,Builtin,2,14310,0x10ce6dd00,104,LoadJoinTypedElement_Float64Elements_0
code-creation,Builtin,2,14316,0x10ce6dd80,24,LoadJoinTypedElement_Uint8ClampedElements_0
code-creation,Builtin,2,14322,0x10ce6ddc0,208,LoadJoinTypedElement_BigUint64Elements_0
code-creation,Builtin,2,14328,0x10ce6dec0,236,LoadJoinTypedElement_BigInt64Elements_0
code-creation,Builtin,2,14334,0x10ce6dfc0,24,LoadJoinTypedElement_Uint8Elements_0
code-creation,Builtin,2,14340,0x10ce6e000,24,LoadJoinTypedElement_Int8Elements_0
code-creation,Builtin,2,14346,0x10ce6e040,24,LoadJoinTypedElement_Uint16Elements_0
code-creation,Builtin,2,14352,0x10ce6e080,24,LoadJoinTypedElement_Int16Elements_0
code-creation,Builtin,2,14358,0x10ce6e0c0,124,LoadJoinTypedElement_Uint32Elements_0
code-creation,Builtin,2,14364,0x10ce6e140,12,GenericBuiltinTest_Smi_0
code-creation,Builtin,2,14369,0x10ce6e180,40,CanUseSameAccessor_FastDoubleElements_0
code-creation,Builtin,2,14375,0x10ce6e1c0,40,CanUseSameAccessor_FastSmiElements_0
code-creation,Builtin,2,14381,0x10ce6e200,40,CanUseSameAccessor_FastObjectElements_0
code-creation,Builtin,2,14387,0x10ce6e240,24,LoadNoHasPropertyCheck_GenericElementsAccessor_0
code-creation,Builtin,2,14394,0x10ce6e280,3500,Load_GenericElementsAccessor_0
code-creation,Builtin,2,14399,0x10ce6f040,24,Store_GenericElementsAccessor_0
code-creation,Builtin,2,14405,0x10ce6f080,36,Delete_GenericElementsAccessor_0
code-creation,Builtin,2,14414,0x10ce6f0c0,24,LoadTypedElement_Int32Elements_0
code-creation,Builtin,2,14419,0x10ce6f100,176,StoreTypedElementNumeric_Int32Elements_0
code-creation,Builtin,2,14426,0x10ce6f1c0,544,StoreTypedElementJSAny_Int32Elements_0
code-creation,Builtin,2,14432,0x10ce6f400,108,LoadTypedElement_Float32Elements_0
code-creation,Builtin,2,14437,0x10ce6f480,32,StoreTypedElementNumeric_Float32Elements_0
code-creation,Builtin,2,14444,0x10ce6f4c0,508,StoreTypedElementJSAny_Float32Elements_0
code-creation,Builtin,2,14450,0x10ce6f6c0,104,LoadTypedElement_Float64Elements_0
code-creation,Builtin,2,14467,0x10ce6f740,28,StoreTypedElementNumeric_Float64Elements_0
code-creation,Builtin,2,14475,0x10ce6f780,504,StoreTypedElementJSAny_Float64Elements_0
code-creation,Builtin,2,14483,0x10ce6f980,24,LoadTypedElement_Uint8ClampedElements_0
code-creation,Builtin,2,14489,0x10ce6f9c0,24,StoreTypedElementNumeric_Uint8ClampedElements_0
code-creation,Builtin,2,14498,0x10ce6fa00,964,StoreTypedElementJSAny_Uint8ClampedElements_0
code-creation,Builtin,2,14506,0x10ce6fe00,208,LoadTypedElement_BigUint64Elements_0
code-creation,Builtin,2,14514,0x10ce6ff00,56,StoreTypedElementNumeric_BigUint64Elements_0
code-creation,Builtin,2,14522,0x10ce6ff40,552,StoreTypedElementJSAny_BigUint64Elements_0
code-creation,Builtin,2,14530,0x10ce70180,236,LoadTypedElement_BigInt64Elements_0
code-creation,Builtin,2,14537,0x10ce70280,56,StoreTypedElementNumeric_BigInt64Elements_0
code-creation,Builtin,2,14545,0x10ce702c0,552,StoreTypedElementJSAny_BigInt64Elements_0
code-creation,Builtin,2,14553,0x10ce70500,24,LoadTypedElement_Uint8Elements_0
code-creation,Builtin,2,14561,0x10ce70540,24,StoreTypedElementNumeric_Uint8Elements_0
code-creation,Builtin,2,14568,0x10ce70580,544,StoreTypedElementJSAny_Uint8Elements_0
code-creation,Builtin,2,14576,0x10ce707c0,24,LoadTypedElement_Int8Elements_0
code-creation,Builtin,2,14584,0x10ce70800,24,StoreTypedElementNumeric_Int8Elements_0
code-creation,Builtin,2,14592,0x10ce70840,544,StoreTypedElementJSAny_Int8Elements_0
code-creation,Builtin,2,14599,0x10ce70a80,24,LoadTypedElement_Uint16Elements_0
code-creation,Builtin,2,14607,0x10ce70ac0,24,StoreTypedElementNumeric_Uint16Elements_0
code-creation,Builtin,2,14615,0x10ce70b00,548,StoreTypedElementJSAny_Uint16Elements_0
code-creation,Builtin,2,14623,0x10ce70d40,24,LoadTypedElement_Int16Elements_0
code-creation,Builtin,2,14638,0x10ce70d80,24,StoreTypedElementNumeric_Int16Elements_0
code-creation,Builtin,2,14646,0x10ce70dc0,548,StoreTypedElementJSAny_Int16Elements_0
code-creation,Builtin,2,14654,0x10ce71000,124,LoadTypedElement_Uint32Elements_0
code-creation,Builtin,2,14662,0x10ce71080,176,StoreTypedElementNumeric_Uint32Elements_0
code-creation,Builtin,2,14670,0x10ce71140,544,StoreTypedElementJSAny_Uint32Elements_0
code-creation,Builtin,2,14678,0x10ce71380,12,CollatorConstructor
code-creation,Builtin,2,14685,0x10ce713c0,12,CollatorInternalCompare
code-creation,Builtin,2,14692,0x10ce71400,12,CollatorPrototypeCompare
code-creation,Builtin,2,14699,0x10ce71440,12,CollatorSupportedLocalesOf
code-creation,Builtin,2,14707,0x10ce71480,12,CollatorPrototypeResolvedOptions
code-creation,Builtin,2,14714,0x10ce714c0,12,DatePrototypeToLocaleDateString
code-creation,Builtin,2,14722,0x10ce71500,12,DatePrototypeToLocaleString
code-creation,Builtin,2,14729,0x10ce71540,12,DatePrototypeToLocaleTimeString
code-creation,Builtin,2,14737,0x10ce71580,12,DateTimeFormatConstructor
code-creation,Builtin,2,14744,0x10ce715c0,12,DateTimeFormatInternalFormat
tick,0x10c6e4136,14861,0,0x0,6
code-creation,Builtin,2,14886,0x10ce71600,12,DateTimeFormatPrototypeFormat
code-creation,Builtin,2,14919,0x10ce71640,12,DateTimeFormatPrototypeFormatRange
code-creation,Builtin,2,14941,0x10ce71680,12,DateTimeFormatPrototypeFormatRangeToParts
code-creation,Builtin,2,14948,0x10ce716c0,12,DateTimeFormatPrototypeFormatToParts
code-creation,Builtin,2,14954,0x10ce71700,12,DateTimeFormatPrototypeResolvedOptions
code-creation,Builtin,2,14960,0x10ce71740,12,DateTimeFormatSupportedLocalesOf
code-creation,Builtin,2,14966,0x10ce71780,12,DisplayNamesConstructor
code-creation,Builtin,2,14972,0x10ce717c0,12,DisplayNamesPrototypeOf
code-creation,Builtin,2,14977,0x10ce71800,12,DisplayNamesPrototypeResolvedOptions
code-creation,Builtin,2,14983,0x10ce71840,12,DisplayNamesSupportedLocalesOf
code-creation,Builtin,2,14989,0x10ce71880,12,DurationFormatConstructor
code-creation,Builtin,2,14994,0x10ce718c0,12,DurationFormatPrototypeFormat
code-creation,Builtin,2,15000,0x10ce71900,12,DurationFormatPrototypeFormatToParts
code-creation,Builtin,2,15006,0x10ce71940,12,DurationFormatPrototypeResolvedOptions
code-creation,Builtin,2,15012,0x10ce71980,12,DurationFormatSupportedLocalesOf
code-creation,Builtin,2,15018,0x10ce719c0,12,IntlGetCanonicalLocales
code-creation,Builtin,2,15024,0x10ce71a00,12,IntlSupportedValuesOf
code-creation,Builtin,2,15029,0x10ce71a40,12,ListFormatConstructor
code-creation,Builtin,2,15034,0x10ce71a80,200,ListFormatPrototypeFormat
code-creation,Builtin,2,15040,0x10ce71b80,200,ListFormatPrototypeFormatToParts
code-creation,Builtin,2,15045,0x10ce71c80,12,ListFormatPrototypeResolvedOptions
code-creation,Builtin,2,15051,0x10ce71cc0,12,ListFormatSupportedLocalesOf
code-creation,Builtin,2,15057,0x10ce71d00,12,LocaleConstructor
code-creation,Builtin,2,15062,0x10ce71d40,12,LocalePrototypeBaseName
code-creation,Builtin,2,15068,0x10ce71d80,12,LocalePrototypeCalendar
code-creation,Builtin,2,15073,0x10ce71dc0,12,LocalePrototypeCalendars
code-creation,Builtin,2,15079,0x10ce71e00,12,LocalePrototypeCaseFirst
code-creation,Builtin,2,15084,0x10ce71e40,12,LocalePrototypeCollation
code-creation,Builtin,2,15090,0x10ce71e80,12,LocalePrototypeCollations
code-creation,Builtin,2,15095,0x10ce71ec0,12,LocalePrototypeHourCycle
code-creation,Builtin,2,15101,0x10ce71f00,12,LocalePrototypeHourCycles
code-creation,Builtin,2,15107,0x10ce71f40,12,LocalePrototypeLanguage
code-creation,Builtin,2,15112,0x10ce71f80,12,LocalePrototypeMaximize
code-creation,Builtin,2,15117,0x10ce71fc0,12,LocalePrototypeMinimize
code-creation,Builtin,2,15123,0x10ce72000,12,LocalePrototypeNumeric
code-creation,Builtin,2,15128,0x10ce72040,12,LocalePrototypeNumberingSystem
code-creation,Builtin,2,15134,0x10ce72080,12,LocalePrototypeNumberingSystems
code-creation,Builtin,2,15139,0x10ce720c0,12,LocalePrototypeRegion
code-creation,Builtin,2,15145,0x10ce72100,12,LocalePrototypeScript
code-creation,Builtin,2,15150,0x10ce72140,12,LocalePrototypeTextInfo
code-creation,Builtin,2,15165,0x10ce72180,12,LocalePrototypeTimeZones
code-creation,Builtin,2,15171,0x10ce721c0,12,LocalePrototypeToString
code-creation,Builtin,2,15177,0x10ce72200,12,LocalePrototypeWeekInfo
code-creation,Builtin,2,15182,0x10ce72240,12,NumberFormatConstructor
code-creation,Builtin,2,15187,0x10ce72280,12,NumberFormatInternalFormatNumber
code-creation,Builtin,2,15193,0x10ce722c0,12,NumberFormatPrototypeFormatNumber
code-creation,Builtin,2,15199,0x10ce72300,12,NumberFormatPrototypeFormatRange
code-creation,Builtin,2,15205,0x10ce72340,12,NumberFormatPrototypeFormatRangeToParts
code-creation,Builtin,2,15211,0x10ce72380,12,NumberFormatPrototypeFormatToParts
code-creation,Builtin,2,15217,0x10ce723c0,12,NumberFormatPrototypeResolvedOptions
code-creation,Builtin,2,15223,0x10ce72400,12,NumberFormatSupportedLocalesOf
code-creation,Builtin,2,15229,0x10ce72440,12,PluralRulesConstructor
code-creation,Builtin,2,15234,0x10ce72480,12,PluralRulesPrototypeResolvedOptions
code-creation,Builtin,2,15240,0x10ce724c0,12,PluralRulesPrototypeSelect
code-creation,Builtin,2,15246,0x10ce72500,12,PluralRulesPrototypeSelectRange
code-creation,Builtin,2,15251,0x10ce72540,12,PluralRulesSupportedLocalesOf
code-creation,Builtin,2,15257,0x10ce72580,12,RelativeTimeFormatConstructor
code-creation,Builtin,2,15289,0x10ce725c0,12,RelativeTimeFormatPrototypeFormat
code-creation,Builtin,2,15296,0x10ce72600,12,RelativeTimeFormatPrototypeFormatToParts
code-creation,Builtin,2,15318,0x10ce72640,12,RelativeTimeFormatPrototypeResolvedOptions
code-creation,Builtin,2,15338,0x10ce72680,12,RelativeTimeFormatSupportedLocalesOf
code-creation,Builtin,2,15344,0x10ce726c0,12,SegmenterConstructor
code-creation,Builtin,2,15350,0x10ce72700,12,SegmenterPrototypeResolvedOptions
code-creation,Builtin,2,15355,0x10ce72740,12,SegmenterPrototypeSegment
code-creation,Builtin,2,15361,0x10ce72780,12,SegmenterSupportedLocalesOf
code-creation,Builtin,2,15366,0x10ce727c0,12,SegmentIteratorPrototypeNext
code-creation,Builtin,2,15372,0x10ce72800,12,SegmentsPrototypeContaining
code-creation,Builtin,2,15378,0x10ce72840,12,SegmentsPrototypeIterator
code-creation,Builtin,2,15383,0x10ce72880,12,StringPrototypeNormalizeIntl
code-creation,Builtin,2,15389,0x10ce728c0,1160,StringPrototypeToLocaleLowerCase
code-creation,Builtin,2,15394,0x10ce72d80,12,StringPrototypeToLocaleUpperCase
code-creation,Builtin,2,15400,0x10ce72dc0,200,StringPrototypeToLowerCaseIntl
code-creation,Builtin,2,15406,0x10ce72ec0,12,StringPrototypeToUpperCaseIntl
code-creation,Builtin,2,15412,0x10ce72f00,648,StringToLowerCaseIntl
code-creation,Builtin,2,15417,0x10ce731c0,12,TemporalCalendarPrototypeEra
code-creation,Builtin,2,15422,0x10ce73200,12,TemporalCalendarPrototypeEraYear
code-creation,Builtin,2,15428,0x10ce73240,12,TemporalPlainDatePrototypeEra
code-creation,Builtin,2,15434,0x10ce73280,12,TemporalPlainDatePrototypeEraYear
code-creation,Builtin,2,15440,0x10ce732c0,12,TemporalPlainDateTimePrototypeEra
code-creation,Builtin,2,15470,0x10ce73300,12,TemporalPlainDateTimePrototypeEraYear
code-creation,Builtin,2,15477,0x10ce73340,12,TemporalPlainYearMonthPrototypeEra
code-creation,Builtin,2,15483,0x10ce73380,12,TemporalPlainYearMonthPrototypeEraYear
code-creation,Builtin,2,15489,0x10ce733c0,12,TemporalZonedDateTimePrototypeEra
code-creation,Builtin,2,15510,0x10ce73400,12,TemporalZonedDateTimePrototypeEraYear
code-creation,Builtin,2,15518,0x10ce73440,12,V8BreakIteratorConstructor
code-creation,Builtin,2,15524,0x10ce73480,12,V8BreakIteratorInternalAdoptText
code-creation,Builtin,2,15529,0x10ce734c0,12,V8BreakIteratorInternalBreakType
code-creation,Builtin,2,15535,0x10ce73500,12,V8BreakIteratorInternalCurrent
code-creation,Builtin,2,15541,0x10ce73540,12,V8BreakIteratorInternalFirst
code-creation,Builtin,2,15546,0x10ce73580,12,V8BreakIteratorInternalNext
code-creation,Builtin,2,15552,0x10ce735c0,12,V8BreakIteratorPrototypeAdoptText
code-creation,Builtin,2,15557,0x10ce73600,12,V8BreakIteratorPrototypeBreakType
code-creation,Builtin,2,15563,0x10ce73640,12,V8BreakIteratorPrototypeCurrent
code-creation,Builtin,2,15576,0x10ce73680,12,V8BreakIteratorPrototypeFirst
code-creation,Builtin,2,15582,0x10ce736c0,12,V8BreakIteratorPrototypeNext
code-creation,Builtin,2,15588,0x10ce73700,12,V8BreakIteratorPrototypeResolvedOptions
code-creation,Builtin,2,15621,0x10ce73740,12,V8BreakIteratorSupportedLocalesOf
code-creation,BytecodeHandler,0,15646,0x10ce73780,24,Wide
code-creation,BytecodeHandler,0,15651,0x10ce737c0,24,ExtraWide
code-creation,BytecodeHandler,0,15656,0x10ce73800,104,DebugBreakWide
code-creation,BytecodeHandler,0,15661,0x10ce73880,104,DebugBreakExtraWide
code-creation,BytecodeHandler,0,15666,0x10ce73900,164,DebugBreak0
code-creation,BytecodeHandler,0,15671,0x10ce739c0,104,DebugBreak1
code-creation,BytecodeHandler,0,15676,0x10ce73a40,104,DebugBreak2
code-creation,BytecodeHandler,0,15681,0x10ce73ac0,104,DebugBreak3
code-creation,BytecodeHandler,0,15686,0x10ce73b40,104,DebugBreak4
code-creation,BytecodeHandler,0,15690,0x10ce73bc0,104,DebugBreak5
code-creation,BytecodeHandler,0,15695,0x10ce73c40,104,DebugBreak6
code-creation,BytecodeHandler,0,15700,0x10ce73cc0,32,Ldar
code-creation,BytecodeHandler,0,15705,0x10ce73d00,56,LdaZero
code-creation,BytecodeHandler,0,15709,0x10ce73d40,64,LdaSmi
code-creation,BytecodeHandler,0,15714,0x10ce73dc0,64,LdaUndefined
code-creation,BytecodeHandler,0,15719,0x10ce73e40,64,LdaNull
code-creation,BytecodeHandler,0,15723,0x10ce73ec0,64,LdaTheHole
code-creation,BytecodeHandler,0,15728,0x10ce73f40,24,LdaTrue
code-creation,BytecodeHandler,0,15733,0x10ce73f80,24,LdaFalse
code-creation,BytecodeHandler,0,15748,0x10ce73fc0,64,LdaConstant
code-creation,BytecodeHandler,0,15757,0x10ce74040,124,LdaContextSlot
code-creation,BytecodeHandler,0,15762,0x10ce740c0,124,LdaImmutableContextSlot
code-creation,BytecodeHandler,0,15768,0x10ce74140,72,LdaCurrentContextSlot
code-creation,BytecodeHandler,0,15773,0x10ce741c0,72,LdaImmutableCurrentContextSlot
code-creation,BytecodeHandler,0,15779,0x10ce74240,32,Star
code-creation,BytecodeHandler,0,15783,0x10ce74280,48,Mov
code-creation,BytecodeHandler,0,15790,0x10ce742c0,40,PushContext
code-creation,BytecodeHandler,0,15796,0x10ce74300,36,PopContext
code-creation,BytecodeHandler,0,15803,0x10ce74340,56,TestReferenceEqual
code-creation,BytecodeHandler,0,15810,0x10ce74380,60,TestUndetectable
code-creation,BytecodeHandler,0,15817,0x10ce743c0,44,TestNull
code-creation,BytecodeHandler,0,15823,0x10ce74400,44,TestUndefined
code-creation,BytecodeHandler,0,15830,0x10ce74440,368,TestTypeOf
code-creation,BytecodeHandler,0,15837,0x10ce745c0,5672,LdaGlobal
code-creation,BytecodeHandler,0,15843,0x10ce75c00,4440,LdaGlobalInsideTypeof
code-creation,BytecodeHandler,0,15850,0x10ce76d80,160,StaGlobal
code-creation,BytecodeHandler,0,15857,0x10ce76e40,156,StaContextSlot
code-creation,BytecodeHandler,0,15863,0x10ce76f00,108,StaCurrentContextSlot
code-creation,BytecodeHandler,0,15871,0x10ce76f80,124,LdaLookupSlot
code-creation,BytecodeHandler,0,15877,0x10ce77000,256,LdaLookupContextSlot
code-creation,BytecodeHandler,0,15884,0x10ce77140,4752,LdaLookupGlobalSlot
code-creation,BytecodeHandler,0,15891,0x10ce78400,124,LdaLookupSlotInsideTypeof
code-creation,BytecodeHandler,0,15899,0x10ce78480,256,LdaLookupContextSlotInsideTypeof
code-creation,BytecodeHandler,0,15906,0x10ce785c0,4660,LdaLookupGlobalSlotInsideTypeof
code-creation,BytecodeHandler,0,15914,0x10ce79800,220,StaLookupSlot
code-creation,BytecodeHandler,0,15920,0x10ce79900,5372,GetNamedProperty
code-creation,BytecodeHandler,0,15927,0x10ce7ae00,184,GetNamedPropertyFromSuper
code-creation,BytecodeHandler,0,15934,0x10ce7aec0,200,GetKeyedProperty
code-creation,BytecodeHandler,0,15941,0x10ce7afc0,168,LdaModuleVariable
code-creation,BytecodeHandler,0,15948,0x10ce7b080,300,StaModuleVariable
code-creation,BytecodeHandler,0,15955,0x10ce7b1c0,176,SetNamedProperty
code-creation,BytecodeHandler,0,15961,0x10ce7b280,176,DefineNamedOwnProperty
code-creation,BytecodeHandler,0,15969,0x10ce7b340,168,SetKeyedProperty
code-creation,BytecodeHandler,0,15975,0x10ce7b400,184,DefineKeyedOwnProperty
code-creation,BytecodeHandler,0,15983,0x10ce7b4c0,168,StaInArrayLiteral
code-creation,BytecodeHandler,0,15998,0x10ce7b580,200,DefineKeyedOwnPropertyInLiteral
code-creation,BytecodeHandler,0,16006,0x10ce7b680,1504,Add
code-creation,BytecodeHandler,0,16013,0x10ce7bc80,1472,Sub
code-creation,BytecodeHandler,0,16019,0x10ce7c280,1592,Mul
code-creation,BytecodeHandler,0,16054,0x10ce7c8c0,1660,Div
code-creation,BytecodeHandler,0,16058,0x10ce7cf40,1608,Mod
code-creation,BytecodeHandler,0,16081,0x10ce7d5c0,956,Exp
code-creation,BytecodeHandler,0,16087,0x10ce7d980,1796,BitwiseOr
code-creation,BytecodeHandler,0,16094,0x10ce7e0c0,1800,BitwiseXor
code-creation,BytecodeHandler,0,16099,0x10ce7e800,1796,BitwiseAnd
code-creation,BytecodeHandler,0,16105,0x10ce7ef40,1216,ShiftLeft
code-creation,BytecodeHandler,0,16110,0x10ce7f440,1216,ShiftRight
code-creation,BytecodeHandler,0,16116,0x10ce7f940,1288,ShiftRightLogical
tick,0x7ff8092cbace,16126,0,0x0,6
code-creation,BytecodeHandler,0,16160,0x10ce7fe80,1388,AddSmi
code-creation,BytecodeHandler,0,16194,0x10ce80400,1356,SubSmi
code-creation,BytecodeHandler,0,16200,0x10ce80980,1432,MulSmi
code-creation,BytecodeHandler,0,16205,0x10ce80f40,1572,DivSmi
code-creation,BytecodeHandler,0,16210,0x10ce81580,1440,ModSmi
code-creation,BytecodeHandler,0,16215,0x10ce81b40,844,ExpSmi
code-creation,BytecodeHandler,0,16219,0x10ce81ec0,488,BitwiseOrSmi
code-creation,BytecodeHandler,0,16224,0x10ce820c0,488,BitwiseXorSmi
code-creation,BytecodeHandler,0,16229,0x10ce822c0,488,BitwiseAndSmi
code-creation,BytecodeHandler,0,16234,0x10ce824c0,508,ShiftLeftSmi
code-creation,BytecodeHandler,0,16239,0x10ce826c0,496,ShiftRightSmi
code-creation,BytecodeHandler,0,16244,0x10ce828c0,784,ShiftRightLogicalSmi
code-creation,BytecodeHandler,0,16249,0x10ce82c00,644,Inc
code-creation,BytecodeHandler,0,16256,0x10ce82ec0,644,Dec
code-creation,BytecodeHandler,0,16261,0x10ce83180,632,Negate
code-creation,BytecodeHandler,0,16266,0x10ce83400,504,BitwiseNot
code-creation,BytecodeHandler,0,16270,0x10ce83600,124,ToBooleanLogicalNot
code-creation,BytecodeHandler,0,16276,0x10ce83680,44,LogicalNot
code-creation,BytecodeHandler,0,16281,0x10ce836c0,204,TypeOf
code-creation,BytecodeHandler,0,16285,0x10ce837c0,124,DeletePropertyStrict
code-creation,BytecodeHandler,0,16290,0x10ce83840,116,DeletePropertySloppy
code-creation,BytecodeHandler,0,16295,0x10ce838c0,40,GetSuperConstructor
code-creation,BytecodeHandler,0,16304,0x10ce83900,352,FindNonDefaultConstructorOrConstruct
code-creation,BytecodeHandler,0,16310,0x10ce83a80,1100,CallAnyReceiver
code-creation,BytecodeHandler,0,16316,0x10ce83f00,1100,CallProperty
code-creation,BytecodeHandler,0,16320,0x10ce84380,1012,CallProperty0
code-creation,BytecodeHandler,0,16325,0x10ce84780,1024,CallProperty1
code-creation,BytecodeHandler,0,16330,0x10ce84bc0,1036,CallProperty2
code-creation,BytecodeHandler,0,16335,0x10ce85000,984,CallUndefinedReceiver
code-creation,BytecodeHandler,0,16340,0x10ce85400,1036,CallUndefinedReceiver0
code-creation,BytecodeHandler,0,16345,0x10ce85840,1024,CallUndefinedReceiver1
code-creation,BytecodeHandler,0,16351,0x10ce85c80,1040,CallUndefinedReceiver2
code-creation,BytecodeHandler,0,16356,0x10ce860c0,1100,CallWithSpread
code-creation,BytecodeHandler,0,16361,0x10ce86540,128,CallRuntime
code-creation,BytecodeHandler,0,16366,0x10ce86600,164,CallRuntimeForPair
code-creation,BytecodeHandler,0,16371,0x10ce866c0,80,CallJSRuntime
code-creation,BytecodeHandler,0,16376,0x10ce86740,1288,InvokeIntrinsic
code-creation,BytecodeHandler,0,16380,0x10ce86c80,1008,Construct
code-creation,BytecodeHandler,0,16385,0x10ce87080,512,ConstructWithSpread
code-creation,BytecodeHandler,0,16390,0x10ce872c0,2180,TestEqual
code-creation,BytecodeHandler,0,16395,0x10ce87b80,1336,TestEqualStrict
code-creation,BytecodeHandler,0,16400,0x10ce880c0,1808,TestLessThan
code-creation,BytecodeHandler,0,16405,0x10ce88800,1808,TestGreaterThan
code-creation,BytecodeHandler,0,16410,0x10ce88f40,1808,TestLessThanOrEqual
code-creation,BytecodeHandler,0,16415,0x10ce89680,1808,TestGreaterThanOrEqual
code-creation,BytecodeHandler,0,16420,0x10ce89dc0,884,TestInstanceOf
code-creation,BytecodeHandler,0,16425,0x10ce8a140,156,TestIn
code-creation,BytecodeHandler,0,16440,0x10ce8a200,116,ToName
code-creation,BytecodeHandler,0,16445,0x10ce8a280,220,ToNumber
code-creation,BytecodeHandler,0,16450,0x10ce8a380,244,ToNumeric
code-creation,BytecodeHandler,0,16455,0x10ce8a480,116,ToObject
code-creation,BytecodeHandler,0,16459,0x10ce8a500,124,ToString
code-creation,BytecodeHandler,0,16464,0x10ce8a580,396,CreateRegExpLiteral
code-creation,BytecodeHandler,0,16469,0x10ce8a740,1560,CreateArrayLiteral
code-creation,BytecodeHandler,0,16474,0x10ce8ad80,92,CreateArrayFromIterable
code-creation,BytecodeHandler,0,16480,0x10ce8ae00,768,CreateEmptyArrayLiteral
code-creation,BytecodeHandler,0,16485,0x10ce8b140,2388,CreateObjectLiteral
code-creation,BytecodeHandler,0,16490,0x10ce8bac0,236,CreateEmptyObjectLiteral
code-creation,BytecodeHandler,0,16496,0x10ce8bbc0,172,CloneObject
code-creation,BytecodeHandler,0,16501,0x10ce8bc80,204,GetTemplateObject
code-creation,BytecodeHandler,0,16506,0x10ce8bd80,336,CreateClosure
code-creation,BytecodeHandler,0,16510,0x10ce8bf00,116,CreateBlockContext
code-creation,BytecodeHandler,0,16515,0x10ce8bf80,132,CreateCatchContext
code-creation,BytecodeHandler,0,16521,0x10ce8c040,292,CreateFunctionContext
code-creation,BytecodeHandler,0,16526,0x10ce8c180,292,CreateEvalContext
code-creation,BytecodeHandler,0,16556,0x10ce8c2c0,132,CreateWithContext
code-creation,BytecodeHandler,0,16562,0x10ce8c380,1556,CreateMappedArguments
code-creation,BytecodeHandler,0,16567,0x10ce8c9c0,572,CreateUnmappedArguments
code-creation,BytecodeHandler,0,16575,0x10ce8cc00,624,CreateRestParameter
code-creation,BytecodeHandler,0,16582,0x10ce8ce80,868,JumpLoop
code-creation,BytecodeHandler,0,16587,0x10ce8d200,44,Jump
code-creation,BytecodeHandler,0,16592,0x10ce8d240,56,JumpConstant
code-creation,BytecodeHandler,0,16597,0x10ce8d280,80,JumpIfNullConstant
code-creation,BytecodeHandler,0,16602,0x10ce8d300,80,JumpIfNotNullConstant
code-creation,BytecodeHandler,0,16624,0x10ce8d380,80,JumpIfUndefinedConstant
code-creation,BytecodeHandler,0,16629,0x10ce8d400,80,JumpIfNotUndefinedConstant
code-creation,BytecodeHandler,0,16635,0x10ce8d480,92,JumpIfUndefinedOrNullConstant
code-creation,BytecodeHandler,0,16641,0x10ce8d500,80,JumpIfTrueConstant
code-creation,BytecodeHandler,0,16646,0x10ce8d580,80,JumpIfFalseConstant
code-creation,BytecodeHandler,0,16651,0x10ce8d600,92,JumpIfJSReceiverConstant
code-creation,BytecodeHandler,0,16656,0x10ce8d680,164,JumpIfToBooleanTrueConstant
code-creation,BytecodeHandler,0,16662,0x10ce8d740,160,JumpIfToBooleanFalseConstant
code-creation,BytecodeHandler,0,16668,0x10ce8d800,148,JumpIfToBooleanTrue
code-creation,BytecodeHandler,0,16673,0x10ce8d8c0,148,JumpIfToBooleanFalse
code-creation,BytecodeHandler,0,16678,0x10ce8d980,68,JumpIfTrue
code-creation,BytecodeHandler,0,16683,0x10ce8da00,68,JumpIfFalse
code-creation,BytecodeHandler,0,16688,0x10ce8da80,68,JumpIfNull
code-creation,BytecodeHandler,0,16692,0x10ce8db00,68,JumpIfNotNull
code-creation,BytecodeHandler,0,16697,0x10ce8db80,68,JumpIfUndefined
code-creation,BytecodeHandler,0,16702,0x10ce8dc00,68,JumpIfNotUndefined
code-creation,BytecodeHandler,0,16707,0x10ce8dc80,76,JumpIfUndefinedOrNull
code-creation,BytecodeHandler,0,16712,0x10ce8dd00,80,JumpIfJSReceiver
code-creation,BytecodeHandler,0,16717,0x10ce8dd80,108,SwitchOnSmiNoFeedback
code-creation,BytecodeHandler,0,16722,0x10ce8de00,472,ForInEnumerate
code-creation,BytecodeHandler,0,16727,0x10ce8e000,260,ForInPrepare
code-creation,BytecodeHandler,0,16732,0x10ce8e140,64,ForInContinue
code-creation,BytecodeHandler,0,16737,0x10ce8e1c0,260,ForInNext
code-creation,BytecodeHandler,0,16741,0x10ce8e300,48,ForInStep
code-creation,BytecodeHandler,0,16746,0x10ce8e340,36,SetPendingMessage
code-creation,BytecodeHandler,0,16751,0x10ce8e380,116,Throw
code-creation,BytecodeHandler,0,16755,0x10ce8e400,116,ReThrow
code-creation,BytecodeHandler,0,16760,0x10ce8e480,112,Return
code-creation,BytecodeHandler,0,16764,0x10ce8e500,188,ThrowReferenceErrorIfHole
code-creation,BytecodeHandler,0,16770,0x10ce8e5c0,136,ThrowSuperNotCalledIfHole
code-creation,BytecodeHandler,0,16775,0x10ce8e680,136,ThrowSuperAlreadyCalledIfNotHole
code-creation,BytecodeHandler,0,16788,0x10ce8e740,156,ThrowIfNotSuperConstructor
code-creation,BytecodeHandler,0,16794,0x10ce8e800,124,SwitchOnGeneratorState
code-creation,BytecodeHandler,0,16799,0x10ce8e880,508,SuspendGenerator
code-creation,BytecodeHandler,0,16804,0x10ce8ea80,140,ResumeGenerator
code-creation,BytecodeHandler,0,16809,0x10ce8eb40,164,GetIterator
code-creation,BytecodeHandler,0,16814,0x10ce8ec00,116,Debugger
code-creation,BytecodeHandler,0,16819,0x10ce8ec80,124,IncBlockCounter
code-creation,BytecodeHandler,0,16824,0x10ce8ed00,56,Abort
code-creation,BytecodeHandler,0,16828,0x10ce8ed40,32,Star0
code-creation,BytecodeHandler,0,16833,0x10ce8ed80,60,Illegal
code-creation,BytecodeHandler,0,16855,0x10ce8edc0,108,DebugBreak1.Wide
code-creation,BytecodeHandler,0,16860,0x10ce8ee40,108,DebugBreak2.Wide
code-creation,BytecodeHandler,0,16866,0x10ce8eec0,108,DebugBreak3.Wide
code-creation,BytecodeHandler,0,16871,0x10ce8ef40,108,DebugBreak4.Wide
code-creation,BytecodeHandler,0,16877,0x10ce8efc0,108,DebugBreak5.Wide
code-creation,BytecodeHandler,0,16882,0x10ce8f040,108,DebugBreak6.Wide
code-creation,BytecodeHandler,0,16887,0x10ce8f0c0,32,Ldar.Wide
code-creation,BytecodeHandler,0,16892,0x10ce8f100,32,LdaSmi.Wide
code-creation,BytecodeHandler,0,16897,0x10ce8f140,32,LdaConstant.Wide
code-creation,BytecodeHandler,0,16920,0x10ce8f180,96,LdaContextSlot.Wide
code-creation,BytecodeHandler,0,16926,0x10ce8f200,96,LdaImmutableContextSlot.Wide
code-creation,BytecodeHandler,0,16957,0x10ce8f280,44,LdaCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,16982,0x10ce8f2c0,44,LdaImmutableCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,16989,0x10ce8f300,32,Star.Wide
code-creation,BytecodeHandler,0,16993,0x10ce8f340,48,Mov.Wide
code-creation,BytecodeHandler,0,16998,0x10ce8f380,40,PushContext.Wide
code-creation,BytecodeHandler,0,17003,0x10ce8f3c0,36,PopContext.Wide
code-creation,BytecodeHandler,0,17008,0x10ce8f400,56,TestReferenceEqual.Wide
tick,0x7ff8092cbace,17049,0,0x0,6
code-creation,BytecodeHandler,0,17068,0x10ce8f440,4576,LdaGlobal.Wide
code-creation,BytecodeHandler,0,17076,0x10ce90640,4496,LdaGlobalInsideTypeof.Wide
code-creation,BytecodeHandler,0,17099,0x10ce91800,164,StaGlobal.Wide
code-creation,BytecodeHandler,0,17104,0x10ce918c0,156,StaContextSlot.Wide
code-creation,BytecodeHandler,0,17109,0x10ce91980,108,StaCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,17115,0x10ce91a00,128,LdaLookupSlot.Wide
code-creation,BytecodeHandler,0,17120,0x10ce91ac0,260,LdaLookupContextSlot.Wide
code-creation,BytecodeHandler,0,17126,0x10ce91c00,4756,LdaLookupGlobalSlot.Wide
code-creation,BytecodeHandler,0,17131,0x10ce92ec0,128,LdaLookupSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,17137,0x10ce92f80,260,LdaLookupContextSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,17143,0x10ce930c0,4676,LdaLookupGlobalSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,17149,0x10ce94340,220,StaLookupSlot.Wide
code-creation,BytecodeHandler,0,17155,0x10ce94440,5388,GetNamedProperty.Wide
code-creation,BytecodeHandler,0,17160,0x10ce95980,192,GetNamedPropertyFromSuper.Wide
code-creation,BytecodeHandler,0,17166,0x10ce95a80,156,GetKeyedProperty.Wide
code-creation,BytecodeHandler,0,17171,0x10ce95b40,168,LdaModuleVariable.Wide
code-creation,BytecodeHandler,0,17176,0x10ce95c00,304,StaModuleVariable.Wide
code-creation,BytecodeHandler,0,17182,0x10ce95d40,180,SetNamedProperty.Wide
code-creation,BytecodeHandler,0,17187,0x10ce95e00,180,DefineNamedOwnProperty.Wide
code-creation,BytecodeHandler,0,17193,0x10ce95ec0,172,SetKeyedProperty.Wide
code-creation,BytecodeHandler,0,17198,0x10ce95f80,188,DefineKeyedOwnProperty.Wide
code-creation,BytecodeHandler,0,17204,0x10ce96040,172,StaInArrayLiteral.Wide
code-creation,BytecodeHandler,0,17209,0x10ce96100,204,DefineKeyedOwnPropertyInLiteral.Wide
code-creation,BytecodeHandler,0,17215,0x10ce96200,1476,Add.Wide
code-creation,BytecodeHandler,0,17220,0x10ce96800,1440,Sub.Wide
code-creation,BytecodeHandler,0,17224,0x10ce96dc0,1560,Mul.Wide
code-creation,BytecodeHandler,0,17229,0x10ce97400,1672,Div.Wide
code-creation,BytecodeHandler,0,17241,0x10ce97ac0,1624,Mod.Wide
code-creation,BytecodeHandler,0,17246,0x10ce98140,980,Exp.Wide
code-creation,BytecodeHandler,0,17251,0x10ce98540,1848,BitwiseOr.Wide
code-creation,BytecodeHandler,0,17256,0x10ce98c80,1852,BitwiseXor.Wide
code-creation,BytecodeHandler,0,17261,0x10ce993c0,1848,BitwiseAnd.Wide
code-creation,BytecodeHandler,0,17266,0x10ce99b00,1272,ShiftLeft.Wide
code-creation,BytecodeHandler,0,17271,0x10ce9a000,1272,ShiftRight.Wide
code-creation,BytecodeHandler,0,17276,0x10ce9a500,1344,ShiftRightLogical.Wide
code-creation,BytecodeHandler,0,17281,0x10ce9aa80,1368,AddSmi.Wide
code-creation,BytecodeHandler,0,17286,0x10ce9b000,1332,SubSmi.Wide
code-creation,BytecodeHandler,0,17291,0x10ce9b540,1444,MulSmi.Wide
code-creation,BytecodeHandler,0,17296,0x10ce9bb00,1588,DivSmi.Wide
code-creation,BytecodeHandler,0,17301,0x10ce9c140,1456,ModSmi.Wide
code-creation,BytecodeHandler,0,17305,0x10ce9c700,840,ExpSmi.Wide
code-creation,BytecodeHandler,0,17310,0x10ce9ca80,496,BitwiseOrSmi.Wide
code-creation,BytecodeHandler,0,17316,0x10ce9cc80,496,BitwiseXorSmi.Wide
code-creation,BytecodeHandler,0,17321,0x10ce9ce80,496,BitwiseAndSmi.Wide
code-creation,BytecodeHandler,0,17326,0x10ce9d080,516,ShiftLeftSmi.Wide
code-creation,BytecodeHandler,0,17331,0x10ce9d2c0,500,ShiftRightSmi.Wide
code-creation,BytecodeHandler,0,17336,0x10ce9d4c0,792,ShiftRightLogicalSmi.Wide
code-creation,BytecodeHandler,0,17342,0x10ce9d800,616,Inc.Wide
code-creation,BytecodeHandler,0,17346,0x10ce9da80,616,Dec.Wide
code-creation,BytecodeHandler,0,17351,0x10ce9dd00,636,Negate.Wide
code-creation,BytecodeHandler,0,17356,0x10ce9df80,516,BitwiseNot.Wide
code-creation,BytecodeHandler,0,17361,0x10ce9e1c0,128,DeletePropertyStrict.Wide
code-creation,BytecodeHandler,0,17366,0x10ce9e280,120,DeletePropertySloppy.Wide
code-creation,BytecodeHandler,0,17372,0x10ce9e300,40,GetSuperConstructor.Wide
code-creation,BytecodeHandler,0,17377,0x10ce9e340,356,FindNonDefaultConstructorOrConstruct.Wide
code-creation,BytecodeHandler,0,17384,0x10ce9e4c0,1104,CallAnyReceiver.Wide
code-creation,BytecodeHandler,0,17389,0x10ce9e940,1104,CallProperty.Wide
code-creation,BytecodeHandler,0,17394,0x10ce9edc0,1016,CallProperty0.Wide
code-creation,BytecodeHandler,0,17399,0x10ce9f1c0,1028,CallProperty1.Wide
code-creation,BytecodeHandler,0,17404,0x10ce9f600,1040,CallProperty2.Wide
code-creation,BytecodeHandler,0,17409,0x10ce9fa40,988,CallUndefinedReceiver.Wide
code-creation,BytecodeHandler,0,17415,0x10ce9fe40,1040,CallUndefinedReceiver0.Wide
code-creation,BytecodeHandler,0,17421,0x10cea0280,1028,CallUndefinedReceiver1.Wide
code-creation,BytecodeHandler,0,17427,0x10cea06c0,1044,CallUndefinedReceiver2.Wide
code-creation,BytecodeHandler,0,17452,0x10cea0b00,1104,CallWithSpread.Wide
code-creation,BytecodeHandler,0,17474,0x10cea0f80,132,CallRuntime.Wide
code-creation,BytecodeHandler,0,17479,0x10cea1040,172,CallRuntimeForPair.Wide
code-creation,BytecodeHandler,0,17485,0x10cea1100,84,CallJSRuntime.Wide
code-creation,BytecodeHandler,0,17490,0x10cea1180,1292,InvokeIntrinsic.Wide
code-creation,BytecodeHandler,0,17495,0x10cea16c0,964,Construct.Wide
code-creation,BytecodeHandler,0,17500,0x10cea1ac0,460,ConstructWithSpread.Wide
code-creation,BytecodeHandler,0,17505,0x10cea1cc0,2212,TestEqual.Wide
code-creation,BytecodeHandler,0,17510,0x10cea2580,1344,TestEqualStrict.Wide
code-creation,BytecodeHandler,0,17515,0x10cea2b00,1788,TestLessThan.Wide
code-creation,BytecodeHandler,0,17520,0x10cea3200,1788,TestGreaterThan.Wide
code-creation,BytecodeHandler,0,17525,0x10cea3900,1788,TestLessThanOrEqual.Wide
code-creation,BytecodeHandler,0,17531,0x10cea4000,1788,TestGreaterThanOrEqual.Wide
code-creation,BytecodeHandler,0,17536,0x10cea4700,888,TestInstanceOf.Wide
code-creation,BytecodeHandler,0,17542,0x10cea4a80,156,TestIn.Wide
code-creation,BytecodeHandler,0,17547,0x10cea4b40,120,ToName.Wide
code-creation,BytecodeHandler,0,17551,0x10cea4bc0,224,ToNumber.Wide
code-creation,BytecodeHandler,0,17556,0x10cea4cc0,248,ToNumeric.Wide
code-creation,BytecodeHandler,0,17561,0x10cea4dc0,120,ToObject.Wide
code-creation,BytecodeHandler,0,17573,0x10cea4e40,400,CreateRegExpLiteral.Wide
code-creation,BytecodeHandler,0,17579,0x10cea5000,1492,CreateArrayLiteral.Wide
code-creation,BytecodeHandler,0,17584,0x10cea5600,768,CreateEmptyArrayLiteral.Wide
code-creation,BytecodeHandler,0,17590,0x10cea5940,2324,CreateObjectLiteral.Wide
code-creation,BytecodeHandler,0,17595,0x10cea6280,176,CloneObject.Wide
code-creation,BytecodeHandler,0,17601,0x10cea6340,164,GetTemplateObject.Wide
code-creation,BytecodeHandler,0,17606,0x10cea6400,336,CreateClosure.Wide
code-creation,BytecodeHandler,0,17611,0x10cea6580,120,CreateBlockContext.Wide
code-creation,BytecodeHandler,0,17616,0x10cea6600,136,CreateCatchContext.Wide
code-creation,BytecodeHandler,0,17622,0x10cea66c0,292,CreateFunctionContext.Wide
code-creation,BytecodeHandler,0,17628,0x10cea6800,292,CreateEvalContext.Wide
code-creation,BytecodeHandler,0,17633,0x10cea6940,136,CreateWithContext.Wide
code-creation,BytecodeHandler,0,17638,0x10cea6a00,900,JumpLoop.Wide
code-creation,BytecodeHandler,0,17643,0x10cea6dc0,44,Jump.Wide
code-creation,BytecodeHandler,0,17648,0x10cea6e00,56,JumpConstant.Wide
code-creation,BytecodeHandler,0,17653,0x10cea6e40,80,JumpIfNullConstant.Wide
code-creation,BytecodeHandler,0,17659,0x10cea6ec0,80,JumpIfNotNullConstant.Wide
code-creation,BytecodeHandler,0,17664,0x10cea6f40,80,JumpIfUndefinedConstant.Wide
code-creation,BytecodeHandler,0,17670,0x10cea6fc0,80,JumpIfNotUndefinedConstant.Wide
code-creation,BytecodeHandler,0,17676,0x10cea7040,92,JumpIfUndefinedOrNullConstant.Wide
code-creation,BytecodeHandler,0,17682,0x10cea70c0,80,JumpIfTrueConstant.Wide
code-creation,BytecodeHandler,0,17687,0x10cea7140,80,JumpIfFalseConstant.Wide
code-creation,BytecodeHandler,0,17718,0x10cea71c0,92,JumpIfJSReceiverConstant.Wide
code-creation,BytecodeHandler,0,17740,0x10cea7240,164,JumpIfToBooleanTrueConstant.Wide
code-creation,BytecodeHandler,0,17746,0x10cea7300,160,JumpIfToBooleanFalseConstant.Wide
code-creation,BytecodeHandler,0,17752,0x10cea73c0,148,JumpIfToBooleanTrue.Wide
code-creation,BytecodeHandler,0,17757,0x10cea7480,148,JumpIfToBooleanFalse.Wide
code-creation,BytecodeHandler,0,17762,0x10cea7540,68,JumpIfTrue.Wide
code-creation,BytecodeHandler,0,17767,0x10cea75c0,68,JumpIfFalse.Wide
code-creation,BytecodeHandler,0,17773,0x10cea7640,68,JumpIfNull.Wide
code-creation,BytecodeHandler,0,17777,0x10cea76c0,68,JumpIfNotNull.Wide
code-creation,BytecodeHandler,0,17783,0x10cea7740,68,JumpIfUndefined.Wide
code-creation,BytecodeHandler,0,17788,0x10cea77c0,68,JumpIfNotUndefined.Wide
code-creation,BytecodeHandler,0,17793,0x10cea7840,76,JumpIfUndefinedOrNull.Wide
code-creation,BytecodeHandler,0,17799,0x10cea78c0,80,JumpIfJSReceiver.Wide
code-creation,BytecodeHandler,0,17804,0x10cea7940,108,SwitchOnSmiNoFeedback.Wide
code-creation,BytecodeHandler,0,17810,0x10cea79c0,476,ForInEnumerate.Wide
code-creation,BytecodeHandler,0,17815,0x10cea7bc0,260,ForInPrepare.Wide
code-creation,BytecodeHandler,0,17820,0x10cea7d00,64,ForInContinue.Wide
code-creation,BytecodeHandler,0,17826,0x10cea7d80,264,ForInNext.Wide
code-creation,BytecodeHandler,0,17831,0x10cea7ec0,48,ForInStep.Wide
code-creation,BytecodeHandler,0,17836,0x10cea7f00,160,ThrowReferenceErrorIfHole.Wide
code-creation,BytecodeHandler,0,17842,0x10cea7fc0,160,ThrowIfNotSuperConstructor.Wide
code-creation,BytecodeHandler,0,17848,0x10cea8080,124,SwitchOnGeneratorState.Wide
code-creation,BytecodeHandler,0,17853,0x10cea8100,528,SuspendGenerator.Wide
code-creation,BytecodeHandler,0,17859,0x10cea8340,140,ResumeGenerator.Wide
code-creation,BytecodeHandler,0,17864,0x10cea8400,168,GetIterator.Wide
code-creation,BytecodeHandler,0,17869,0x10cea84c0,128,IncBlockCounter.Wide
code-creation,BytecodeHandler,0,17874,0x10cea8580,56,Abort.Wide
code-creation,BytecodeHandler,0,17879,0x10cea85c0,108,DebugBreak1.ExtraWide
code-creation,BytecodeHandler,0,17885,0x10cea8640,108,DebugBreak2.ExtraWide
code-creation,BytecodeHandler,0,17890,0x10cea86c0,108,DebugBreak3.ExtraWide
code-creation,BytecodeHandler,0,17895,0x10cea8740,108,DebugBreak4.ExtraWide
code-creation,BytecodeHandler,0,17907,0x10cea87c0,108,DebugBreak5.ExtraWide
code-creation,BytecodeHandler,0,17913,0x10cea8840,108,DebugBreak6.ExtraWide
code-creation,BytecodeHandler,0,17941,0x10cea88c0,32,Ldar.ExtraWide
code-creation,BytecodeHandler,0,17947,0x10cea8900,28,LdaSmi.ExtraWide
code-creation,BytecodeHandler,0,17952,0x10cea8940,32,LdaConstant.ExtraWide
code-creation,BytecodeHandler,0,17958,0x10cea8980,92,LdaContextSlot.ExtraWide
code-creation,BytecodeHandler,0,17963,0x10cea8a00,92,LdaImmutableContextSlot.ExtraWide
code-creation,BytecodeHandler,0,17987,0x10cea8a80,44,LdaCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,17993,0x10cea8ac0,44,LdaImmutableCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,17999,0x10cea8b00,32,Star.ExtraWide
code-creation,BytecodeHandler,0,18004,0x10cea8b40,44,Mov.ExtraWide
code-creation,BytecodeHandler,0,18009,0x10cea8b80,40,PushContext.ExtraWide
code-creation,BytecodeHandler,0,18014,0x10cea8bc0,36,PopContext.ExtraWide
code-creation,BytecodeHandler,0,18020,0x10cea8c00,52,TestReferenceEqual.ExtraWide
code-creation,BytecodeHandler,0,18025,0x10cea8c40,4564,LdaGlobal.ExtraWide
code-creation,BytecodeHandler,0,18031,0x10cea9e40,4484,LdaGlobalInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,18037,0x10ceab000,164,StaGlobal.ExtraWide
code-creation,BytecodeHandler,0,18076,0x10ceab0c0,152,StaContextSlot.ExtraWide
code-creation,BytecodeHandler,0,18086,0x10ceab180,104,StaCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,18094,0x10ceab200,128,LdaLookupSlot.ExtraWide
code-creation,BytecodeHandler,0,18102,0x10ceab2c0,260,LdaLookupContextSlot.ExtraWide
code-creation,BytecodeHandler,0,18111,0x10ceab400,4744,LdaLookupGlobalSlot.ExtraWide
code-creation,BytecodeHandler,0,18117,0x10ceac6c0,128,LdaLookupSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,18124,0x10ceac780,260,LdaLookupContextSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,18131,0x10ceac8c0,4660,LdaLookupGlobalSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,18138,0x10ceadb00,220,StaLookupSlot.ExtraWide
code-creation,BytecodeHandler,0,18145,0x10ceadc00,5364,GetNamedProperty.ExtraWide
code-creation,BytecodeHandler,0,18152,0x10ceaf100,188,GetNamedPropertyFromSuper.ExtraWide
code-creation,BytecodeHandler,0,18159,0x10ceaf1c0,156,GetKeyedProperty.ExtraWide
code-creation,BytecodeHandler,0,18167,0x10ceaf280,164,LdaModuleVariable.ExtraWide
code-creation,BytecodeHandler,0,18175,0x10ceaf340,300,StaModuleVariable.ExtraWide
code-creation,BytecodeHandler,0,18182,0x10ceaf480,176,SetNamedProperty.ExtraWide
code-creation,BytecodeHandler,0,18190,0x10ceaf540,176,DefineNamedOwnProperty.ExtraWide
code-creation,BytecodeHandler,0,18214,0x10ceaf600,168,SetKeyedProperty.ExtraWide
code-creation,BytecodeHandler,0,18221,0x10ceaf6c0,184,DefineKeyedOwnProperty.ExtraWide
code-creation,BytecodeHandler,0,18248,0x10ceaf780,168,StaInArrayLiteral.ExtraWide
tick,0x7ff8092cbace,18263,0,0x0,6
code-creation,BytecodeHandler,0,18283,0x10ceaf840,200,DefineKeyedOwnPropertyInLiteral.ExtraWide
code-creation,BytecodeHandler,0,18310,0x10ceaf940,1472,Add.ExtraWide
code-creation,BytecodeHandler,0,18316,0x10ceaff40,1436,Sub.ExtraWide
code-creation,BytecodeHandler,0,18321,0x10ceb0500,1556,Mul.ExtraWide
code-creation,BytecodeHandler,0,18326,0x10ceb0b40,1668,Div.ExtraWide
code-creation,BytecodeHandler,0,18331,0x10ceb1200,1620,Mod.ExtraWide
code-creation,BytecodeHandler,0,18359,0x10ceb1880,976,Exp.ExtraWide
code-creation,BytecodeHandler,0,18364,0x10ceb1c80,1836,BitwiseOr.ExtraWide
code-creation,BytecodeHandler,0,18386,0x10ceb23c0,1840,BitwiseXor.ExtraWide
code-creation,BytecodeHandler,0,18412,0x10ceb2b00,1836,BitwiseAnd.ExtraWide
code-creation,BytecodeHandler,0,18421,0x10ceb3240,1268,ShiftLeft.ExtraWide
code-creation,BytecodeHandler,0,18427,0x10ceb3740,1268,ShiftRight.ExtraWide
code-creation,BytecodeHandler,0,18433,0x10ceb3c40,1332,ShiftRightLogical.ExtraWide
code-creation,BytecodeHandler,0,18439,0x10ceb4180,1360,AddSmi.ExtraWide
code-creation,BytecodeHandler,0,18459,0x10ceb4700,1328,SubSmi.ExtraWide
code-creation,BytecodeHandler,0,18464,0x10ceb4c40,1440,MulSmi.ExtraWide
code-creation,BytecodeHandler,0,18504,0x10ceb5200,1584,DivSmi.ExtraWide
code-creation,BytecodeHandler,0,18511,0x10ceb5840,1452,ModSmi.ExtraWide
code-creation,BytecodeHandler,0,18516,0x10ceb5e00,840,ExpSmi.ExtraWide
code-creation,BytecodeHandler,0,18521,0x10ceb6180,492,BitwiseOrSmi.ExtraWide
code-creation,BytecodeHandler,0,18542,0x10ceb6380,492,BitwiseXorSmi.ExtraWide
code-creation,BytecodeHandler,0,18548,0x10ceb6580,492,BitwiseAndSmi.ExtraWide
code-creation,BytecodeHandler,0,18574,0x10ceb6780,516,ShiftLeftSmi.ExtraWide
code-creation,BytecodeHandler,0,18579,0x10ceb69c0,500,ShiftRightSmi.ExtraWide
code-creation,BytecodeHandler,0,18585,0x10ceb6bc0,788,ShiftRightLogicalSmi.ExtraWide
code-creation,BytecodeHandler,0,18591,0x10ceb6f00,616,Inc.ExtraWide
code-creation,BytecodeHandler,0,18597,0x10ceb7180,616,Dec.ExtraWide
code-creation,BytecodeHandler,0,18602,0x10ceb7400,636,Negate.ExtraWide
code-creation,BytecodeHandler,0,18622,0x10ceb7680,516,BitwiseNot.ExtraWide
code-creation,BytecodeHandler,0,18628,0x10ceb78c0,124,DeletePropertyStrict.ExtraWide
code-creation,BytecodeHandler,0,18634,0x10ceb7940,116,DeletePropertySloppy.ExtraWide
code-creation,BytecodeHandler,0,18640,0x10ceb79c0,40,GetSuperConstructor.ExtraWide
code-creation,BytecodeHandler,0,18646,0x10ceb7a00,352,FindNonDefaultConstructorOrConstruct.ExtraWide
code-creation,BytecodeHandler,0,18653,0x10ceb7b80,1092,CallAnyReceiver.ExtraWide
code-creation,BytecodeHandler,0,18719,0x10ceb8000,1092,CallProperty.ExtraWide
code-creation,BytecodeHandler,0,18729,0x10ceb8480,1008,CallProperty0.ExtraWide
code-creation,BytecodeHandler,0,18736,0x10ceb8880,1020,CallProperty1.ExtraWide
code-creation,BytecodeHandler,0,18741,0x10ceb8c80,1032,CallProperty2.ExtraWide
code-creation,BytecodeHandler,0,18747,0x10ceb90c0,984,CallUndefinedReceiver.ExtraWide
code-creation,BytecodeHandler,0,18753,0x10ceb94c0,1036,CallUndefinedReceiver0.ExtraWide
code-creation,BytecodeHandler,0,18785,0x10ceb9900,1024,CallUndefinedReceiver1.ExtraWide
code-creation,BytecodeHandler,0,18807,0x10ceb9d40,1040,CallUndefinedReceiver2.ExtraWide
code-creation,BytecodeHandler,0,18825,0x10ceba180,1092,CallWithSpread.ExtraWide
code-creation,BytecodeHandler,0,18866,0x10ceba600,128,CallRuntime.ExtraWide
code-creation,BytecodeHandler,0,18875,0x10ceba6c0,168,CallRuntimeForPair.ExtraWide
code-creation,BytecodeHandler,0,18884,0x10ceba780,80,CallJSRuntime.ExtraWide
code-creation,BytecodeHandler,0,18890,0x10ceba800,1292,InvokeIntrinsic.ExtraWide
code-creation,BytecodeHandler,0,18896,0x10cebad40,960,Construct.ExtraWide
code-creation,BytecodeHandler,0,18902,0x10cebb140,456,ConstructWithSpread.ExtraWide
code-creation,BytecodeHandler,0,18908,0x10cebb340,2212,TestEqual.ExtraWide
code-creation,BytecodeHandler,0,18913,0x10cebbc00,1340,TestEqualStrict.ExtraWide
code-creation,BytecodeHandler,0,18942,0x10cebc140,1788,TestLessThan.ExtraWide
code-creation,BytecodeHandler,0,18967,0x10cebc840,1788,TestGreaterThan.ExtraWide
code-creation,BytecodeHandler,0,18973,0x10cebcf40,1788,TestLessThanOrEqual.ExtraWide
code-creation,BytecodeHandler,0,18994,0x10cebd640,1788,TestGreaterThanOrEqual.ExtraWide
code-creation,BytecodeHandler,0,19000,0x10cebdd40,888,TestInstanceOf.ExtraWide
code-creation,BytecodeHandler,0,19006,0x10cebe0c0,156,TestIn.ExtraWide
code-creation,BytecodeHandler,0,19011,0x10cebe180,116,ToName.ExtraWide
code-creation,BytecodeHandler,0,19016,0x10cebe200,220,ToNumber.ExtraWide
code-creation,BytecodeHandler,0,19022,0x10cebe300,244,ToNumeric.ExtraWide
code-creation,BytecodeHandler,0,19027,0x10cebe400,116,ToObject.ExtraWide
code-creation,BytecodeHandler,0,19034,0x10cebe480,396,CreateRegExpLiteral.ExtraWide
code-creation,BytecodeHandler,0,19041,0x10cebe640,1492,CreateArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,19074,0x10cebec40,768,CreateEmptyArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,19081,0x10cebef80,2320,CreateObjectLiteral.ExtraWide
code-creation,BytecodeHandler,0,19088,0x10cebf8c0,172,CloneObject.ExtraWide
code-creation,BytecodeHandler,0,19093,0x10cebf980,164,GetTemplateObject.ExtraWide
code-creation,BytecodeHandler,0,19111,0x10cebfa40,332,CreateClosure.ExtraWide
code-creation,BytecodeHandler,0,19133,0x10cebfbc0,120,CreateBlockContext.ExtraWide
code-creation,BytecodeHandler,0,19138,0x10cebfc40,132,CreateCatchContext.ExtraWide
code-creation,BytecodeHandler,0,19144,0x10cebfd00,288,CreateFunctionContext.ExtraWide
code-creation,BytecodeHandler,0,19150,0x10cebfe40,288,CreateEvalContext.ExtraWide
code-creation,BytecodeHandler,0,19156,0x10cebff80,132,CreateWithContext.ExtraWide
code-creation,BytecodeHandler,0,19162,0x10cec0040,896,JumpLoop.ExtraWide
code-creation,BytecodeHandler,0,19167,0x10cec0400,44,Jump.ExtraWide
code-creation,BytecodeHandler,0,19190,0x10cec0440,56,JumpConstant.ExtraWide
code-creation,BytecodeHandler,0,19196,0x10cec0480,80,JumpIfNullConstant.ExtraWide
code-creation,BytecodeHandler,0,19202,0x10cec0500,80,JumpIfNotNullConstant.ExtraWide
code-creation,BytecodeHandler,0,19208,0x10cec0580,80,JumpIfUndefinedConstant.ExtraWide
code-creation,BytecodeHandler,0,19214,0x10cec0600,80,JumpIfNotUndefinedConstant.ExtraWide
code-creation,BytecodeHandler,0,19221,0x10cec0680,88,JumpIfUndefinedOrNullConstant.ExtraWide
code-creation,BytecodeHandler,0,19293,0x10cec0700,80,JumpIfTrueConstant.ExtraWide
code-creation,BytecodeHandler,0,19302,0x10cec0780,80,JumpIfFalseConstant.ExtraWide
tick,0x10c165a0a,19319,0,0x0,6
code-creation,BytecodeHandler,0,19342,0x10cec0800,92,JumpIfJSReceiverConstant.ExtraWide
code-creation,BytecodeHandler,0,19396,0x10cec0880,164,JumpIfToBooleanTrueConstant.ExtraWide
code-creation,BytecodeHandler,0,19458,0x10cec0940,160,JumpIfToBooleanFalseConstant.ExtraWide
code-creation,BytecodeHandler,0,19476,0x10cec0a00,144,JumpIfToBooleanTrue.ExtraWide
code-creation,BytecodeHandler,0,19487,0x10cec0ac0,144,JumpIfToBooleanFalse.ExtraWide
code-creation,BytecodeHandler,0,19509,0x10cec0b80,68,JumpIfTrue.ExtraWide
code-creation,BytecodeHandler,0,19542,0x10cec0c00,68,JumpIfFalse.ExtraWide
code-creation,BytecodeHandler,0,19554,0x10cec0c80,68,JumpIfNull.ExtraWide
code-creation,BytecodeHandler,0,19633,0x10cec0d00,68,JumpIfNotNull.ExtraWide
code-creation,BytecodeHandler,0,19643,0x10cec0d80,68,JumpIfUndefined.ExtraWide
code-creation,BytecodeHandler,0,19649,0x10cec0e00,68,JumpIfNotUndefined.ExtraWide
code-creation,BytecodeHandler,0,19655,0x10cec0e80,76,JumpIfUndefinedOrNull.ExtraWide
code-creation,BytecodeHandler,0,19662,0x10cec0f00,76,JumpIfJSReceiver.ExtraWide
code-creation,BytecodeHandler,0,19690,0x10cec0f80,104,SwitchOnSmiNoFeedback.ExtraWide
code-creation,BytecodeHandler,0,19722,0x10cec1000,476,ForInEnumerate.ExtraWide
code-creation,BytecodeHandler,0,19728,0x10cec1200,256,ForInPrepare.ExtraWide
code-creation,BytecodeHandler,0,19734,0x10cec1340,64,ForInContinue.ExtraWide
code-creation,BytecodeHandler,0,19740,0x10cec13c0,260,ForInNext.ExtraWide
code-creation,BytecodeHandler,0,19746,0x10cec1500,44,ForInStep.ExtraWide
code-creation,BytecodeHandler,0,19752,0x10cec1540,160,ThrowReferenceErrorIfHole.ExtraWide
code-creation,BytecodeHandler,0,19759,0x10cec1600,160,ThrowIfNotSuperConstructor.ExtraWide
code-creation,BytecodeHandler,0,19782,0x10cec16c0,124,SwitchOnGeneratorState.ExtraWide
code-creation,BytecodeHandler,0,19808,0x10cec1740,528,SuspendGenerator.ExtraWide
code-creation,BytecodeHandler,0,19814,0x10cec1980,136,ResumeGenerator.ExtraWide
code-creation,BytecodeHandler,0,19821,0x10cec1a40,164,GetIterator.ExtraWide
code-creation,BytecodeHandler,0,19827,0x10cec1b00,124,IncBlockCounter.ExtraWide
code-creation,BytecodeHandler,0,19911,0x10cec1b80,56,Abort.ExtraWide
tick,0x10c62f1e1,20359,0,0x0,6
tick,0x10c1f7c88,21423,0,0x0,6
new,MemoryChunk,0x31e66b0c0000,262144
tick,0x10ca280ca,22744,0,0x0,5
new,MemoryChunk,0x31e68dd00000,262144
tick,0x10ca24951,23711,0,0x0,5
new,MemoryChunk,0x31e6cb500000,262144
tick,0x10ca2d0cc,24991,0,0x0,5
new,MemoryChunk,0x31e637d00000,262144
new,MemoryChunk,0x31e63e080000,262144
tick,0x10ca2dc3e,26185,0,0x0,5
tick,0x10c8a6197,27377,0,0x0,5
tick,0x10c9a29f0,28641,0,0x0,2
code-creation,Eval,10,28782,0x31e63e0baf0e,5, node:internal/main/run_main_module:1:1,0x31e63e0badc8,~
script-source,80,node:internal/main/run_main_module,'use strict';\n\nconst { RegExpPrototypeExec } = primordials;\n\nconst {\n  prepareMainThreadExecution\x2C\n  markBootstrapComplete\x2C\n} = require('internal/process/pre_execution');\nconst { getOptionValue } = require('internal/options');\n\nconst mainEntry = prepareMainThreadExecution(true);\n\nmarkBootstrapComplete();\n\n// Necessary to reset RegExp statics before user code runs.\nRegExpPrototypeExec(/^/\x2C '');\n\nif (getOptionValue('--experimental-default-type') === 'module') {\n  require('internal/modules/run_main').executeUserEntryPoint(mainEntry);\n} else {\n  /**\n   * To support legacy monkey-patching of `Module.runMain`\x2C we call `runMain` here to have the CommonJS loader begin\n   * the execution of the main entry point\x2C even if the ESM loader immediately takes over because the main entry is an\n   * ES module or one of the other opt-in conditions (such as the use of `--import`) are met. Users can monkey-patch\n   * before the main entry point is loaded by doing so via scripts loaded through `--require`. This monkey-patchability\n   * is undesirable and is removed in `--experimental-default-type=module` mode.\n   */\n  require('internal/modules/cjs/loader').Module.runMain(mainEntry);\n}\n
code-source-info,0x31e63e0baf0e,80,0,1182,C0O0C4O1182,,
code-creation,JS,10,28895,0x31e63e0baffe,120, node:internal/main/run_main_module:1:1,0x31e63e0bae88,~
code-source-info,0x31e63e0baffe,80,0,1182,C0O23C5O128C8O128C13O71C18O101C23O198C26O198C31O179C36O246C38O246C43O281C46O367C55O367C60O398C63O402C70O448C75O466C78O466C83O502C88O503C95O1114C98O1114C103O1152C108O1159C113O1160C119O1181,,
code-creation,JS,10,29372,0x31e63e0bb65e,45,prepareMainThreadExecution node:internal/process/pre_execution:54:36,0x31e647c790a0,~
script-source,67,node:internal/process/pre_execution,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  Date\x2C\n  DatePrototypeGetDate\x2C\n  DatePrototypeGetFullYear\x2C\n  DatePrototypeGetHours\x2C\n  DatePrototypeGetMinutes\x2C\n  DatePrototypeGetMonth\x2C\n  DatePrototypeGetSeconds\x2C\n  NumberParseInt\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  SafeMap\x2C\n  String\x2C\n  StringPrototypeStartsWith\x2C\n  Symbol\x2C\n  SymbolAsyncDispose\x2C\n  SymbolDispose\x2C\n  globalThis\x2C\n} = primordials;\n\nconst {\n  getOptionValue\x2C\n  refreshOptions\x2C\n  getEmbedderOptions\x2C\n} = require('internal/options');\nconst { reconnectZeroFillToggle } = require('internal/buffer');\nconst {\n  defineOperation\x2C\n  exposeInterface\x2C\n  exposeLazyInterfaces\x2C\n  defineReplaceableLazyAttribute\x2C\n  setupCoverageHooks\x2C\n} = require('internal/util');\n\nconst {\n  ERR_INVALID_THIS\x2C\n  ERR_MANIFEST_ASSERT_INTEGRITY\x2C\n  ERR_NO_CRYPTO\x2C\n  ERR_MISSING_OPTION\x2C\n  ERR_ACCESS_DENIED\x2C\n} = require('internal/errors').codes;\nconst assert = require('internal/assert');\nconst {\n  namespace: {\n    addSerializeCallback\x2C\n    isBuildingSnapshot\x2C\n  }\x2C\n} = require('internal/v8/startup_snapshot');\n\nfunction prepareMainThreadExecution(expandArgv1 = false\x2C initializeModules = true) {\n  return prepareExecution({\n    expandArgv1\x2C\n    initializeModules\x2C\n    isMainThread: true\x2C\n  });\n}\n\nfunction prepareWorkerThreadExecution() {\n  prepareExecution({\n    expandArgv1: false\x2C\n    initializeModules: false\x2C  // Will need to initialize it after policy setup\n    isMainThread: false\x2C\n  });\n}\n\nfunction prepareShadowRealmExecution() {\n  const { registerRealm } = require('internal/modules/esm/utils');\n  // Patch the process object with legacy properties and normalizations.\n  // Do not expand argv1 as it is not available in ShadowRealm.\n  patchProcessObject(false);\n  setupDebugEnv();\n\n  // Disable custom loaders in ShadowRealm.\n  setupUserModules(true);\n  registerRealm(globalThis\x2C {\n    __proto__: null\x2C\n    importModuleDynamically: (specifier\x2C _referrer\x2C attributes) => {\n      // The handler for `ShadowRealm.prototype.importValue`.\n      const { esmLoader } = require('internal/process/esm_loader');\n      // `parentURL` is not set in the case of a ShadowRealm top-level import.\n      return esmLoader.import(specifier\x2C undefined\x2C attributes);\n    }\x2C\n  });\n}\n\nfunction prepareExecution(options) {\n  const { expandArgv1\x2C initializeModules\x2C isMainThread } = options;\n\n  refreshRuntimeOptions();\n  reconnectZeroFillToggle();\n\n  // Patch the process object and get the resolved main entry point.\n  const mainEntry = patchProcessObject(expandArgv1);\n  setupTraceCategoryState();\n  setupInspectorHooks();\n  setupWarningHandler();\n  setupUndici();\n  setupWebCrypto();\n  setupCustomEvent();\n  setupCodeCoverage();\n  setupDebugEnv();\n  // Process initial diagnostic reporting configuration\x2C if present.\n  initializeReport();\n\n  // Load permission system API\n  initializePermission();\n\n  initializeSourceMapsHandlers();\n  initializeDeprecations();\n\n  require('internal/dns/utils').initializeDns();\n\n  setupSymbolDisposePolyfill();\n\n  if (isMainThread) {\n    assert(internalBinding('worker').isMainThread);\n    // Worker threads will get the manifest in the message handler.\n    const policy = readPolicyFromDisk();\n    if (policy) {\n      require('internal/process/policy')\n        .setup(policy.manifestSrc\x2C policy.manifestURL);\n    }\n\n    // Print stack trace on `SIGINT` if option `--trace-sigint` presents.\n    setupStacktracePrinterOnSigint();\n    initializeReportSignalHandlers();  // Main-thread-only.\n    initializeHeapSnapshotSignalHandlers();\n    // If the process is spawned with env NODE_CHANNEL_FD\x2C it's probably\n    // spawned by our child_process module\x2C then initialize IPC.\n    // This attaches some internal event listeners and creates:\n    // process.send()\x2C process.channel\x2C process.connected\x2C\n    // process.disconnect().\n    setupChildProcessIpcChannel();\n    // If this is a worker in cluster mode\x2C start up the communication\n    // channel. This needs to be done before any user code gets executed\n    // (including preload modules).\n    initializeClusterIPC();\n\n    // TODO(joyeecheung): do this for worker threads as well.\n    require('internal/v8/startup_snapshot').runDeserializeCallbacks();\n  } else {\n    assert(!internalBinding('worker').isMainThread);\n    // The setup should be called in LOAD_SCRIPT message handler.\n    assert(!initializeModules);\n  }\n\n  if (initializeModules) {\n    setupUserModules();\n  }\n\n  return mainEntry;\n}\n\nfunction setupSymbolDisposePolyfill() {\n  // TODO(MoLow): Remove this polyfill once Symbol.dispose and Symbol.asyncDispose are available in V8.\n  // eslint-disable-next-line node-core/prefer-primordials\n  if (typeof Symbol.dispose !== 'symbol') {\n    ObjectDefineProperty(Symbol\x2C 'dispose'\x2C {\n      __proto__: null\x2C\n      configurable: false\x2C\n      enumerable: false\x2C\n      value: SymbolDispose\x2C\n      writable: false\x2C\n    });\n  }\n\n  // eslint-disable-next-line node-core/prefer-primordials\n  if (typeof Symbol.asyncDispose !== 'symbol') {\n    ObjectDefineProperty(Symbol\x2C 'asyncDispose'\x2C {\n      __proto__: null\x2C\n      configurable: false\x2C\n      enumerable: false\x2C\n      value: SymbolAsyncDispose\x2C\n      writable: false\x2C\n    });\n  }\n}\n\nfunction setupUserModules(forceDefaultLoader = false) {\n  initializeCJSLoader();\n  initializeESMLoader(forceDefaultLoader);\n  const CJSLoader = require('internal/modules/cjs/loader');\n  assert(!CJSLoader.hasLoadedAnyUserCJSModule);\n  // Do not enable preload modules if custom loaders are disabled.\n  // For example\x2C loader workers are responsible for doing this themselves.\n  // And preload modules are not supported in ShadowRealm as well.\n  if (!forceDefaultLoader) {\n    loadPreloadModules();\n  }\n  // Need to be done after --require setup.\n  initializeFrozenIntrinsics();\n}\n\nfunction refreshRuntimeOptions() {\n  refreshOptions();\n}\n\n/**\n * Patch the process object with legacy properties and normalizations.\n * Replace `process.argv[0]` with `process.execPath`\x2C preserving the original `argv[0]` value as `process.argv0`.\n * Replace `process.argv[1]` with the resolved absolute file path of the entry point\x2C if found.\n * @param {boolean} expandArgv1 - Whether to replace `process.argv[1]` with the resolved absolute file path of\n * the main entry point.\n */\nfunction patchProcessObject(expandArgv1) {\n  const binding = internalBinding('process_methods');\n  binding.patchProcessObject(process);\n\n  require('internal/process/per_thread').refreshHrtimeBuffer();\n\n  // Since we replace process.argv[0] below\x2C preserve the original value in case the user needs it.\n  ObjectDefineProperty(process\x2C 'argv0'\x2C {\n    __proto__: null\x2C\n    enumerable: true\x2C\n    // Only set it to true during snapshot building.\n    configurable: isBuildingSnapshot()\x2C\n    value: process.argv[0]\x2C\n  });\n\n  process.exitCode = undefined;\n  process._exiting = false;\n  process.argv[0] = process.execPath;\n\n  /** @type {string} */\n  let mainEntry;\n  // If requested\x2C update process.argv[1] to replace whatever the user provided with the resolved absolute file path of\n  // the entry point.\n  if (expandArgv1 && process.argv[1] &&\n      !StringPrototypeStartsWith(process.argv[1]\x2C '-')) {\n    // Expand process.argv[1] into a full path.\n    const path = require('path');\n    try {\n      mainEntry = path.resolve(process.argv[1]);\n      process.argv[1] = mainEntry;\n    } catch {\n      // Continue regardless of error.\n    }\n  }\n\n  // We need to initialize the global console here again with process.stdout\n  // and friends for snapshot deserialization.\n  const globalConsole = require('internal/console/global');\n  const { initializeGlobalConsole } = require('internal/console/constructor');\n  initializeGlobalConsole(globalConsole);\n\n  // TODO(joyeecheung): most of these should be deprecated and removed\x2C\n  // except some that we need to be able to mutate during run time.\n  addReadOnlyProcessAlias('_eval'\x2C '--eval');\n  addReadOnlyProcessAlias('_print_eval'\x2C '--print');\n  addReadOnlyProcessAlias('_syntax_check_only'\x2C '--check');\n  addReadOnlyProcessAlias('_forceRepl'\x2C '--interactive');\n  addReadOnlyProcessAlias('_preload_modules'\x2C '--require');\n  addReadOnlyProcessAlias('noDeprecation'\x2C '--no-deprecation');\n  addReadOnlyProcessAlias('noProcessWarnings'\x2C '--no-warnings');\n  addReadOnlyProcessAlias('traceProcessWarnings'\x2C '--trace-warnings');\n  addReadOnlyProcessAlias('throwDeprecation'\x2C '--throw-deprecation');\n  addReadOnlyProcessAlias('profProcess'\x2C '--prof-process');\n  addReadOnlyProcessAlias('traceDeprecation'\x2C '--trace-deprecation');\n  addReadOnlyProcessAlias('_breakFirstLine'\x2C '--inspect-brk'\x2C false);\n  addReadOnlyProcessAlias('_breakNodeFirstLine'\x2C '--inspect-brk-node'\x2C false);\n\n  return mainEntry;\n}\n\nfunction addReadOnlyProcessAlias(name\x2C option\x2C enumerable = true) {\n  const value = getOptionValue(option);\n  if (value) {\n    ObjectDefineProperty(process\x2C name\x2C {\n      __proto__: null\x2C\n      writable: false\x2C\n      configurable: true\x2C\n      enumerable\x2C\n      value\x2C\n    });\n  }\n}\n\nfunction setupWarningHandler() {\n  const {\n    onWarning\x2C\n    resetForSerialization\x2C\n  } = require('internal/process/warning');\n  if (getOptionValue('--warnings') &&\n    process.env.NODE_NO_WARNINGS !== '1') {\n    process.on('warning'\x2C onWarning);\n\n    // The code above would add the listener back during deserialization\x2C\n    // if applicable.\n    if (isBuildingSnapshot()) {\n      addSerializeCallback(() => {\n        process.removeListener('warning'\x2C onWarning);\n        resetForSerialization();\n      });\n    }\n  }\n}\n\n// https://fetch.spec.whatwg.org/\n// https://websockets.spec.whatwg.org/\nfunction setupUndici() {\n  if (getEmbedderOptions().noBrowserGlobals) {\n    return;\n  }\n\n  let undici;\n  function lazyUndici() {\n    if (undici) {\n      return undici;\n    }\n\n    undici = require('internal/deps/undici/undici');\n    return undici;\n  }\n\n  function lazyInterface(name) {\n    return {\n      configurable: true\x2C\n      enumerable: false\x2C\n      get() {\n        return lazyUndici()[name];\n      }\x2C\n      set(value) {\n        exposeInterface(globalThis\x2C name\x2C value);\n      }\x2C\n    };\n  }\n\n  if (!getOptionValue('--no-experimental-fetch')) {\n    // Fetch is meant to return a Promise\x2C but not be async.\n    function fetch(input\x2C init = undefined) {\n      return lazyUndici().fetch(input\x2C init);\n    }\n\n    defineOperation(globalThis\x2C 'fetch'\x2C fetch);\n\n    ObjectDefineProperties(globalThis\x2C {\n      FormData: lazyInterface('FormData')\x2C\n      Headers: lazyInterface('Headers')\x2C\n      Request: lazyInterface('Request')\x2C\n      Response: lazyInterface('Response')\x2C\n    });\n\n    // The WebAssembly Web API: https://webassembly.github.io/spec/web-api\n    internalBinding('wasm_web_api').setImplementation((streamState\x2C source) => {\n      require('internal/wasm_web_api').wasmStreamingCallback(streamState\x2C source);\n    });\n  }\n\n  if (getOptionValue('--experimental-websocket')) {\n    ObjectDefineProperties(globalThis\x2C {\n      WebSocket: lazyInterface('WebSocket')\x2C\n    });\n  }\n}\n\n// TODO(aduh95): move this to internal/bootstrap/web/* when the CLI flag is\n//               removed.\nfunction setupWebCrypto() {\n  if (getEmbedderOptions().noBrowserGlobals ||\n      getOptionValue('--no-experimental-global-webcrypto')) {\n    return;\n  }\n\n  if (internalBinding('config').hasOpenSSL) {\n    defineReplaceableLazyAttribute(\n      globalThis\x2C\n      'internal/crypto/webcrypto'\x2C\n      ['crypto']\x2C\n      false\x2C\n      function cryptoThisCheck() {\n        if (this !== globalThis && this != null)\n          throw new ERR_INVALID_THIS(\n            'nullish or must be the global object');\n      }\x2C\n    );\n    exposeLazyInterfaces(\n      globalThis\x2C 'internal/crypto/webcrypto'\x2C\n      ['Crypto'\x2C 'CryptoKey'\x2C 'SubtleCrypto']\x2C\n    );\n  } else {\n    ObjectDefineProperty(globalThis\x2C 'crypto'\x2C\n                         { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor({\n                           get crypto() {\n                             throw new ERR_NO_CRYPTO();\n                           }\x2C\n                         }\x2C 'crypto') });\n\n  }\n}\n\nfunction setupCodeCoverage() {\n  // Resolve the coverage directory to an absolute path\x2C and\n  // overwrite process.env so that the original path gets passed\n  // to child processes even when they switch cwd. Don't do anything if the\n  // --experimental-test-coverage flag is present\x2C as the test runner will\n  // handle coverage.\n  if (process.env.NODE_V8_COVERAGE &&\n      !getOptionValue('--experimental-test-coverage')) {\n    process.env.NODE_V8_COVERAGE =\n      setupCoverageHooks(process.env.NODE_V8_COVERAGE);\n  }\n}\n\n// TODO(daeyeon): move this to internal/bootstrap/web/* when the CLI flag is\n//                removed.\nfunction setupCustomEvent() {\n  if (getEmbedderOptions().noBrowserGlobals ||\n      getOptionValue('--no-experimental-global-customevent')) {\n    return;\n  }\n  const { CustomEvent } = require('internal/event_target');\n  exposeInterface(globalThis\x2C 'CustomEvent'\x2C CustomEvent);\n}\n\nfunction setupStacktracePrinterOnSigint() {\n  if (!getOptionValue('--trace-sigint')) {\n    return;\n  }\n  const { SigintWatchdog } = require('internal/watchdog');\n\n  const watchdog = new SigintWatchdog();\n  watchdog.start();\n}\n\nfunction initializeReport() {\n  ObjectDefineProperty(process\x2C 'report'\x2C {\n    __proto__: null\x2C\n    enumerable: true\x2C\n    configurable: true\x2C\n    get() {\n      const { report } = require('internal/process/report');\n      return report;\n    }\x2C\n  });\n}\n\nfunction setupDebugEnv() {\n  require('internal/util/debuglog').initializeDebugEnv(process.env.NODE_DEBUG);\n  if (getOptionValue('--expose-internals')) {\n    require('internal/bootstrap/realm').BuiltinModule.exposeInternals();\n  }\n}\n\n// This has to be called after initializeReport() is called\nfunction initializeReportSignalHandlers() {\n  if (getOptionValue('--report-on-signal')) {\n    const { addSignalHandler } = require('internal/process/report');\n    addSignalHandler();\n  }\n}\n\nfunction initializeHeapSnapshotSignalHandlers() {\n  const signal = getOptionValue('--heapsnapshot-signal');\n  const diagnosticDir = getOptionValue('--diagnostic-dir');\n\n  if (!signal)\n    return;\n\n  require('internal/validators').validateSignalName(signal);\n  const { writeHeapSnapshot } = require('v8');\n\n  function doWriteHeapSnapshot() {\n    const heapSnapshotFilename = getHeapSnapshotFilename(diagnosticDir);\n    writeHeapSnapshot(heapSnapshotFilename);\n  }\n  process.on(signal\x2C doWriteHeapSnapshot);\n\n  // The code above would add the listener back during deserialization\x2C\n  // if applicable.\n  if (isBuildingSnapshot()) {\n    addSerializeCallback(() => {\n      process.removeListener(signal\x2C doWriteHeapSnapshot);\n    });\n  }\n}\n\nfunction setupTraceCategoryState() {\n  const { isTraceCategoryEnabled } = internalBinding('trace_events');\n  const { toggleTraceCategoryState } = require('internal/process/per_thread');\n  toggleTraceCategoryState(isTraceCategoryEnabled('node.async_hooks'));\n}\n\nfunction setupInspectorHooks() {\n  // If Debugger.setAsyncCallStackDepth is sent during bootstrap\x2C\n  // we cannot immediately call into JS to enable the hooks\x2C which could\n  // interrupt the JS execution of bootstrap. So instead we save the\n  // notification in the inspector agent if it's sent in the middle of\n  // bootstrap\x2C and process the notification later here.\n  if (internalBinding('config').hasInspector) {\n    const {\n      enable\x2C\n      disable\x2C\n    } = require('internal/inspector_async_hook');\n    internalBinding('inspector').registerAsyncHook(enable\x2C disable);\n  }\n}\n\n// In general deprecations are initialized wherever the APIs are implemented\x2C\n// this is used to deprecate APIs implemented in C++ where the deprecation\n// utilities are not easily accessible.\nfunction initializeDeprecations() {\n  const { deprecate } = require('internal/util');\n  const pendingDeprecation = getOptionValue('--pending-deprecation');\n\n  // DEP0103: access to `process.binding('util').isX` type checkers\n  // TODO(addaleax): Turn into a full runtime deprecation.\n  const utilBinding = internalBinding('util');\n  const types = require('internal/util/types');\n  for (const name of [\n    'isArrayBuffer'\x2C\n    'isArrayBufferView'\x2C\n    'isAsyncFunction'\x2C\n    'isDataView'\x2C\n    'isDate'\x2C\n    'isExternal'\x2C\n    'isMap'\x2C\n    'isMapIterator'\x2C\n    'isNativeError'\x2C\n    'isPromise'\x2C\n    'isRegExp'\x2C\n    'isSet'\x2C\n    'isSetIterator'\x2C\n    'isTypedArray'\x2C\n    'isUint8Array'\x2C\n    'isAnyArrayBuffer'\x2C\n  ]) {\n    utilBinding[name] = pendingDeprecation ?\n      deprecate(types[name]\x2C\n                'Accessing native typechecking bindings of Node ' +\n                'directly is deprecated. ' +\n                `Please use \\`util.types.${name}\\` instead.`\x2C\n                'DEP0103') :\n      types[name];\n  }\n\n  // TODO(joyeecheung): this is a legacy property exposed to process.\n  // Now that we use the config binding to carry this information\x2C remove\n  // it from the process. We may consider exposing it properly in\n  // process.features.\n  const { noBrowserGlobals } = internalBinding('config');\n  if (noBrowserGlobals) {\n    ObjectDefineProperty(process\x2C '_noBrowserGlobals'\x2C {\n      __proto__: null\x2C\n      writable: false\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      value: noBrowserGlobals\x2C\n    });\n  }\n\n  if (pendingDeprecation) {\n    process.binding = deprecate(process.binding\x2C\n                                'process.binding() is deprecated. ' +\n                                'Please use public APIs instead.'\x2C 'DEP0111');\n\n    process._tickCallback = deprecate(process._tickCallback\x2C\n                                      'process._tickCallback() is deprecated'\x2C\n                                      'DEP0134');\n  }\n}\n\nfunction setupChildProcessIpcChannel() {\n  if (process.env.NODE_CHANNEL_FD) {\n    const assert = require('internal/assert');\n\n    const fd = NumberParseInt(process.env.NODE_CHANNEL_FD\x2C 10);\n    assert(fd >= 0);\n\n    // Make sure it's not accidentally inherited by child processes.\n    delete process.env.NODE_CHANNEL_FD;\n\n    const serializationMode =\n      process.env.NODE_CHANNEL_SERIALIZATION_MODE || 'json';\n    delete process.env.NODE_CHANNEL_SERIALIZATION_MODE;\n\n    require('child_process')._forkChild(fd\x2C serializationMode);\n    assert(process.send);\n  }\n}\n\nfunction initializeClusterIPC() {\n  if (process.argv[1] && process.env.NODE_UNIQUE_ID) {\n    const cluster = require('cluster');\n    cluster._setupWorker();\n    // Make sure it's not accidentally inherited by child processes.\n    delete process.env.NODE_UNIQUE_ID;\n  }\n}\n\nfunction initializePermission() {\n  const experimentalPermission = getOptionValue('--experimental-permission');\n  if (experimentalPermission) {\n    process.binding = function binding(_module) {\n      throw new ERR_ACCESS_DENIED('process.binding');\n    };\n    process.emitWarning('Permission is an experimental feature'\x2C\n                        'ExperimentalWarning');\n    const { has\x2C deny } = require('internal/process/permission');\n    const warnFlags = [\n      '--allow-child-process'\x2C\n      '--allow-worker'\x2C\n    ];\n    for (const flag of warnFlags) {\n      if (getOptionValue(flag)) {\n        process.emitWarning(\n          `The flag ${flag} must be used with extreme caution. ` +\n        'It could invalidate the permission model.'\x2C 'SecurityWarning');\n      }\n    }\n    const warnCommaFlags = [\n      '--allow-fs-read'\x2C\n      '--allow-fs-write'\x2C\n    ];\n    for (const flag of warnCommaFlags) {\n      const value = getOptionValue(flag);\n      if (value.length === 1 && value[0].includes('\x2C')) {\n        process.emitWarning(\n          `The ${flag} CLI flag has changed. ` +\n        'Passing a comma-separated list of paths is no longer valid. ' +\n        'Documentation can be found at ' +\n        'https://nodejs.org/api/permissions.html#file-system-permissions'\x2C\n          'Warning'\x2C\n        );\n      }\n    }\n\n    ObjectDefineProperty(process\x2C 'permission'\x2C {\n      __proto__: null\x2C\n      enumerable: true\x2C\n      configurable: false\x2C\n      value: {\n        has\x2C\n        deny\x2C\n      }\x2C\n    });\n  } else {\n    const availablePermissionFlags = [\n      '--allow-fs-read'\x2C\n      '--allow-fs-write'\x2C\n      '--allow-child-process'\x2C\n      '--allow-worker'\x2C\n    ];\n    ArrayPrototypeForEach(availablePermissionFlags\x2C (flag) => {\n      const value = getOptionValue(flag);\n      if (value.length) {\n        throw new ERR_MISSING_OPTION('--experimental-permission');\n      }\n    });\n  }\n}\n\nfunction readPolicyFromDisk() {\n  const experimentalPolicy = getOptionValue('--experimental-policy');\n  if (experimentalPolicy) {\n    process.emitWarning('Policies are experimental.'\x2C\n                        'ExperimentalWarning');\n    const { pathToFileURL\x2C URL } = require('internal/url');\n    // URL here as it is slightly different parsing\n    // no bare specifiers for now\n    let manifestURL;\n    if (require('path').isAbsolute(experimentalPolicy)) {\n      manifestURL = pathToFileURL(experimentalPolicy);\n    } else {\n      const cwdURL = pathToFileURL(process.cwd());\n      cwdURL.pathname += '/';\n      manifestURL = new URL(experimentalPolicy\x2C cwdURL);\n    }\n    const fs = require('fs');\n    const src = fs.readFileSync(manifestURL\x2C 'utf8');\n    const experimentalPolicyIntegrity = getOptionValue('--policy-integrity');\n    if (experimentalPolicyIntegrity) {\n      const SRI = require('internal/policy/sri');\n      const { createHash\x2C timingSafeEqual } = require('crypto');\n      const realIntegrities = new SafeMap();\n      const integrityEntries = SRI.parse(experimentalPolicyIntegrity);\n      let foundMatch = false;\n      for (let i = 0; i < integrityEntries.length; i++) {\n        const {\n          algorithm\x2C\n          value: expected\x2C\n        } = integrityEntries[i];\n        const hash = createHash(algorithm);\n        hash.update(src);\n        const digest = hash.digest();\n        if (digest.length === expected.length &&\n          timingSafeEqual(digest\x2C expected)) {\n          foundMatch = true;\n          break;\n        }\n        realIntegrities.set(algorithm\x2C digest.toString('base64'));\n      }\n      if (!foundMatch) {\n        throw new ERR_MANIFEST_ASSERT_INTEGRITY(manifestURL\x2C realIntegrities);\n      }\n    }\n    return {\n      manifestSrc: src\x2C manifestURL: manifestURL.href\x2C\n    };\n  }\n}\n\nfunction initializeCJSLoader() {\n  const { initializeCJS } = require('internal/modules/cjs/loader');\n  initializeCJS();\n}\n\nfunction initializeESMLoader(forceDefaultLoader) {\n  const { initializeESM } = require('internal/modules/esm/utils');\n  initializeESM(forceDefaultLoader);\n\n  // Patch the vm module when --experimental-vm-modules is on.\n  // Please update the comments in vm.js when this block changes.\n  if (getOptionValue('--experimental-vm-modules')) {\n    const {\n      Module\x2C SourceTextModule\x2C SyntheticModule\x2C\n    } = require('internal/vm/module');\n    const vm = require('vm');\n    vm.Module = Module;\n    vm.SourceTextModule = SourceTextModule;\n    vm.SyntheticModule = SyntheticModule;\n  }\n}\n\nfunction initializeSourceMapsHandlers() {\n  const {\n    setSourceMapsEnabled\x2C\n  } = require('internal/source_map/source_map_cache');\n  setSourceMapsEnabled(getOptionValue('--enable-source-maps'));\n}\n\nfunction initializeFrozenIntrinsics() {\n  if (getOptionValue('--frozen-intrinsics')) {\n    process.emitWarning('The --frozen-intrinsics flag is experimental'\x2C\n                        'ExperimentalWarning');\n    require('internal/freeze_intrinsics')();\n  }\n}\n\nfunction loadPreloadModules() {\n  // For user code\x2C we preload modules if `-r` is passed\n  const preloadModules = getOptionValue('--require');\n  if (preloadModules && preloadModules.length > 0) {\n    const {\n      Module: {\n        _preloadModules\x2C\n      }\x2C\n    } = require('internal/modules/cjs/loader');\n    _preloadModules(preloadModules);\n  }\n}\n\nfunction markBootstrapComplete() {\n  internalBinding('performance').markBootstrapComplete();\n}\n\n// Sequence number for diagnostic filenames\nlet sequenceNumOfheapSnapshot = 0;\n\n// To generate the HeapSnapshotFilename while using custom diagnosticDir\nfunction getHeapSnapshotFilename(diagnosticDir) {\n  if (!diagnosticDir) return undefined;\n\n  const date = new Date();\n\n  const year = DatePrototypeGetFullYear(date);\n  const month = String(DatePrototypeGetMonth(date) + 1).padStart(2\x2C '0');\n  const day = String(DatePrototypeGetDate(date)).padStart(2\x2C '0');\n  const hours = String(DatePrototypeGetHours(date)).padStart(2\x2C '0');\n  const minutes = String(DatePrototypeGetMinutes(date)).padStart(2\x2C '0');\n  const seconds = String(DatePrototypeGetSeconds(date)).padStart(2\x2C '0');\n\n  const dateString = `${year}${month}${day}`;\n  const timeString = `${hours}${minutes}${seconds}`;\n  const pid = process.pid;\n  const threadId = internalBinding('worker').threadId;\n  const fileSequence = (++sequenceNumOfheapSnapshot).toString().padStart(3\x2C '0');\n\n  return `${diagnosticDir}/Heap.${dateString}.${timeString}.${pid}.${threadId}.${fileSequence}.heapsnapshot`;\n}\n\nmodule.exports = {\n  setupUserModules\x2C\n  prepareMainThreadExecution\x2C\n  prepareWorkerThreadExecution\x2C\n  prepareShadowRealmExecution\x2C\n  markBootstrapComplete\x2C\n  loadPreloadModules\x2C\n  initializeFrozenIntrinsics\x2C\n};\n
code-source-info,0x31e63e0bb65e,67,1126,1275,C20O1178C30O1208C36O1225C40O1185C44O1273,,
tick,0x10ca5f720,31118,0,0x0,3,0x10c9f09d0,0x31e63e0bb024
tick,0x7ff809303563,31136,0,0x0,3,0x10c9f09d0,0x31e63e0bb024
code-creation,JS,10,31243,0x31e63e0bd316,309,prepareExecution node:internal/process/pre_execution:90:26,0x31e647c79628,~
code-source-info,0x31e63e0bd316,67,2277,4446,C0O2299C5O2312C10O2331C15O2360C18O2360C21O2387C26O2387C29O2504C32O2504C37O2539C40O2539C43O2568C46O2568C49O2593C52O2593C55O2618C58O2618C61O2635C64O2635C67O2655C70O2655C73O2677C76O2677C79O2700C82O2700C85O2788C88O2788C91O2843C94O2843C97O2870C100O2870C103O2904C106O2904C109O2933C115O2933C120O2962C125O2963C129O2983C132O2983C135O3016C139O3040C150O3047C155O3072C160O3040C164O3175C167O3175C171O3201C173O3221C179O3221C184O3264C189O3278C194O3298C199O3265C205O3397C208O3397C211O3435C214O3435C217O3495C220O3495C223O3829C226O3829C229O4044C232O4044C235O4135C241O4135C246O4174C251O4175C257O4217C268O4225C273O4250C279O4217C283O4336C290O4344C292O4336C296O4371C300O4400C303O4400C306O4427C308O4444,,
code-creation,JS,10,31319,0x31e63e0bd606,10,refreshRuntimeOptions node:internal/process/pre_execution:198:31,0x31e647c79718,~
code-source-info,0x31e63e0bd606,67,5795,5821,C0O5802C5O5802C9O5820,,
code-creation,JS,10,31354,0x31e63e0bd6ee,22,refreshOptions node:internal/options:39:24,0x31e647c44928,~
script-source,17,node:internal/options,'use strict';\n\nconst {\n  getCLIOptions\x2C\n  getEmbedderOptions: getEmbedderOptionsFromBinding\x2C\n} = internalBinding('options');\n\nlet warnOnAllowUnauthorized = true;\n\nlet optionsMap;\nlet aliasesMap;\nlet embedderOptions;\n\n// getCLIOptions() would serialize the option values from C++ land.\n// It would error if the values are queried before bootstrap is\n// complete so that we don't accidentally include runtime-dependent\n// states into a runtime-independent snapshot.\nfunction getCLIOptionsFromBinding() {\n  if (!optionsMap) {\n    ({ options: optionsMap } = getCLIOptions());\n  }\n  return optionsMap;\n}\n\nfunction getAliasesFromBinding() {\n  if (!aliasesMap) {\n    ({ aliases: aliasesMap } = getCLIOptions());\n  }\n  return aliasesMap;\n}\n\nfunction getEmbedderOptions() {\n  if (!embedderOptions) {\n    embedderOptions = getEmbedderOptionsFromBinding();\n  }\n  return embedderOptions;\n}\n\nfunction refreshOptions() {\n  optionsMap = undefined;\n  aliasesMap = undefined;\n}\n\nfunction getOptionValue(optionName) {\n  const options = getCLIOptionsFromBinding();\n  if (optionName.startsWith('--no-')) {\n    const option = options.get('--' + optionName.slice(5));\n    return option && !option.value;\n  }\n  return options.get(optionName)?.value;\n}\n\nfunction getAllowUnauthorized() {\n  const allowUnauthorized = process.env.NODE_TLS_REJECT_UNAUTHORIZED === '0';\n\n  if (allowUnauthorized && warnOnAllowUnauthorized) {\n    warnOnAllowUnauthorized = false;\n    process.emitWarning(\n      'Setting the NODE_TLS_REJECT_UNAUTHORIZED ' +\n      'environment variable to \\'0\\' makes TLS connections ' +\n      'and HTTPS requests insecure by disabling ' +\n      'certificate verification.');\n  }\n  return allowUnauthorized;\n}\n\nmodule.exports = {\n  get options() {\n    return getCLIOptionsFromBinding();\n  }\x2C\n  get aliases() {\n    return getAliasesFromBinding();\n  }\x2C\n  getOptionValue\x2C\n  getAllowUnauthorized\x2C\n  getEmbedderOptions\x2C\n  refreshOptions\x2C\n};\n
code-source-info,0x31e63e0bd6ee,17,902,960,C0O909C4O920C10O935C14O946C21O959,,
code-creation,JS,10,31529,0x31e63e0bda56,19,reconnectZeroFillToggle node:internal/buffer:1074:33,0x31e647c55b60,~
script-source,25,node:internal/buffer,'use strict';\n\nconst {\n  BigInt\x2C\n  Float32Array\x2C\n  Float64Array\x2C\n  MathFloor\x2C\n  Number\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  ERR_BUFFER_OUT_OF_BOUNDS\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_OUT_OF_RANGE\x2C\n} = require('internal/errors').codes;\nconst { validateNumber } = require('internal/validators');\nconst {\n  asciiSlice\x2C\n  base64Slice\x2C\n  base64urlSlice\x2C\n  latin1Slice\x2C\n  hexSlice\x2C\n  ucs2Slice\x2C\n  utf8Slice\x2C\n  asciiWrite\x2C\n  base64Write\x2C\n  base64urlWrite\x2C\n  latin1Write\x2C\n  hexWrite\x2C\n  ucs2Write\x2C\n  utf8Write\x2C\n  getZeroFillToggle\x2C\n} = internalBinding('buffer');\n\nconst {\n  privateSymbols: {\n    untransferable_object_private_symbol\x2C\n  }\x2C\n} = internalBinding('util');\n\n// Temporary buffers to convert numbers.\nconst float32Array = new Float32Array(1);\nconst uInt8Float32Array = new Uint8Array(float32Array.buffer);\nconst float64Array = new Float64Array(1);\nconst uInt8Float64Array = new Uint8Array(float64Array.buffer);\n\n// Check endianness.\nfloat32Array[0] = -1; // 0xBF800000\n// Either it is [0\x2C 0\x2C 128\x2C 191] or [191\x2C 128\x2C 0\x2C 0]. It is not possible to\n// check this with `os.endianness()` because that is determined at compile time.\nconst bigEndian = uInt8Float32Array[3] === 0;\n\nfunction checkBounds(buf\x2C offset\x2C byteLength) {\n  validateNumber(offset\x2C 'offset');\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined)\n    boundsError(offset\x2C buf.length - (byteLength + 1));\n}\n\nfunction checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : '';\n    let range;\n    if (byteLength > 3) {\n      if (min === 0 || min === 0n) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and ` +\n                `< 2${n} ** ${(byteLength + 1) * 8 - 1}${n}`;\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`;\n    }\n    throw new ERR_OUT_OF_RANGE('value'\x2C range\x2C value);\n  }\n  checkBounds(buf\x2C offset\x2C byteLength);\n}\n\nfunction boundsError(value\x2C length\x2C type) {\n  if (MathFloor(value) !== value) {\n    validateNumber(value\x2C type);\n    throw new ERR_OUT_OF_RANGE(type || 'offset'\x2C 'an integer'\x2C value);\n  }\n\n  if (length < 0)\n    throw new ERR_BUFFER_OUT_OF_BOUNDS();\n\n  throw new ERR_OUT_OF_RANGE(type || 'offset'\x2C\n                             `>= ${type ? 1 : 0} and <= ${length}`\x2C\n                             value);\n}\n\n// Read integers.\nfunction readBigUInt64LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24;\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24;\n\n  return BigInt(lo) + (BigInt(hi) << 32n);\n}\n\nfunction readBigUInt64BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset];\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n\n  return (BigInt(hi) << 32n) + BigInt(lo);\n}\n\nfunction readBigInt64LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24); // Overflow\n  return (BigInt(val) << 32n) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24);\n}\n\nfunction readBigInt64BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset];\n  return (BigInt(val) << 32n) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last);\n}\n\nfunction readUIntLE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readUInt48LE(this\x2C offset);\n  if (byteLength === 5)\n    return readUInt40LE(this\x2C offset);\n  if (byteLength === 3)\n    return readUInt24LE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readUInt32LE(offset);\n  if (byteLength === 2)\n    return this.readUInt16LE(offset);\n  if (byteLength === 1)\n    return this.readUInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readUInt48LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  return first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24 +\n    (buf[++offset] + last * 2 ** 8) * 2 ** 32;\n}\n\nfunction readUInt40LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24 +\n    last * 2 ** 32;\n}\n\nfunction readUInt32LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24;\n}\n\nfunction readUInt24LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\n}\n\nfunction readUInt16LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  return first + last * 2 ** 8;\n}\n\nfunction readUInt8(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const val = this[offset];\n  if (val === undefined)\n    boundsError(offset\x2C this.length - 1);\n\n  return val;\n}\n\nfunction readUIntBE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readUInt48BE(this\x2C offset);\n  if (byteLength === 5)\n    return readUInt40BE(this\x2C offset);\n  if (byteLength === 3)\n    return readUInt24BE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readUInt32BE(offset);\n  if (byteLength === 2)\n    return this.readUInt16BE(offset);\n  if (byteLength === 1)\n    return this.readUInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readUInt48BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt40BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return first * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt32BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt24BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n}\n\nfunction readUInt16BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  return first * 2 ** 8 + last;\n}\n\nfunction readIntLE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readInt48LE(this\x2C offset);\n  if (byteLength === 5)\n    return readInt40LE(this\x2C offset);\n  if (byteLength === 3)\n    return readInt24LE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readInt32LE(offset);\n  if (byteLength === 2)\n    return this.readInt16LE(offset);\n  if (byteLength === 1)\n    return this.readInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readInt48LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  const val = buf[offset + 4] + last * 2 ** 8;\n  return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 +\n    first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24;\n}\n\nfunction readInt40LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return (last | (last & 2 ** 7) * 0x1fffffe) * 2 ** 32 +\n    first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24;\n}\n\nfunction readInt32LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    (last << 24); // Overflow\n}\n\nfunction readInt24LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\n  return val | (val & 2 ** 23) * 0x1fe;\n}\n\nfunction readInt16LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  const val = first + last * 2 ** 8;\n  return val | (val & 2 ** 15) * 0x1fffe;\n}\n\nfunction readInt8(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const val = this[offset];\n  if (val === undefined)\n    boundsError(offset\x2C this.length - 1);\n\n  return val | (val & 2 ** 7) * 0x1fffffe;\n}\n\nfunction readIntBE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readInt48BE(this\x2C offset);\n  if (byteLength === 5)\n    return readInt40BE(this\x2C offset);\n  if (byteLength === 3)\n    return readInt24BE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readInt32BE(offset);\n  if (byteLength === 2)\n    return this.readInt16BE(offset);\n  if (byteLength === 1)\n    return this.readInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readInt48BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  const val = buf[++offset] + first * 2 ** 8;\n  return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt40BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt32BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt24BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n  return val | (val & 2 ** 23) * 0x1fe;\n}\n\nfunction readInt16BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  const val = first * 2 ** 8 + last;\n  return val | (val & 2 ** 15) * 0x1fffe;\n}\n\n// Read floats\nfunction readFloatBackwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  uInt8Float32Array[3] = first;\n  uInt8Float32Array[2] = this[++offset];\n  uInt8Float32Array[1] = this[++offset];\n  uInt8Float32Array[0] = last;\n  return float32Array[0];\n}\n\nfunction readFloatForwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  uInt8Float32Array[0] = first;\n  uInt8Float32Array[1] = this[++offset];\n  uInt8Float32Array[2] = this[++offset];\n  uInt8Float32Array[3] = last;\n  return float32Array[0];\n}\n\nfunction readDoubleBackwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  uInt8Float64Array[7] = first;\n  uInt8Float64Array[6] = this[++offset];\n  uInt8Float64Array[5] = this[++offset];\n  uInt8Float64Array[4] = this[++offset];\n  uInt8Float64Array[3] = this[++offset];\n  uInt8Float64Array[2] = this[++offset];\n  uInt8Float64Array[1] = this[++offset];\n  uInt8Float64Array[0] = last;\n  return float64Array[0];\n}\n\nfunction readDoubleForwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  uInt8Float64Array[0] = first;\n  uInt8Float64Array[1] = this[++offset];\n  uInt8Float64Array[2] = this[++offset];\n  uInt8Float64Array[3] = this[++offset];\n  uInt8Float64Array[4] = this[++offset];\n  uInt8Float64Array[5] = this[++offset];\n  uInt8Float64Array[6] = this[++offset];\n  uInt8Float64Array[7] = last;\n  return float64Array[0];\n}\n\n// Write integers.\nfunction writeBigU_Int64LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 7);\n\n  let lo = Number(value & 0xffffffffn);\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  let hi = Number(value >> 32n & 0xffffffffn);\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  return offset;\n}\n\nfunction writeBigUInt64LE(value\x2C offset = 0) {\n  return writeBigU_Int64LE(this\x2C value\x2C offset\x2C 0n\x2C 0xffffffffffffffffn);\n}\n\nfunction writeBigU_Int64BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 7);\n\n  let lo = Number(value & 0xffffffffn);\n  buf[offset + 7] = lo;\n  lo = lo >> 8;\n  buf[offset + 6] = lo;\n  lo = lo >> 8;\n  buf[offset + 5] = lo;\n  lo = lo >> 8;\n  buf[offset + 4] = lo;\n  let hi = Number(value >> 32n & 0xffffffffn);\n  buf[offset + 3] = hi;\n  hi = hi >> 8;\n  buf[offset + 2] = hi;\n  hi = hi >> 8;\n  buf[offset + 1] = hi;\n  hi = hi >> 8;\n  buf[offset] = hi;\n  return offset + 8;\n}\n\nfunction writeBigUInt64BE(value\x2C offset = 0) {\n  return writeBigU_Int64BE(this\x2C value\x2C offset\x2C 0n\x2C 0xffffffffffffffffn);\n}\n\nfunction writeBigInt64LE(value\x2C offset = 0) {\n  return writeBigU_Int64LE(\n    this\x2C value\x2C offset\x2C -0x8000000000000000n\x2C 0x7fffffffffffffffn);\n}\n\nfunction writeBigInt64BE(value\x2C offset = 0) {\n  return writeBigU_Int64BE(\n    this\x2C value\x2C offset\x2C -0x8000000000000000n\x2C 0x7fffffffffffffffn);\n}\n\nfunction writeUIntLE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffff);\n  if (byteLength === 3)\n    return writeU_Int24LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffff);\n  if (byteLength === 4)\n    return writeU_Int32LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n  if (byteLength === 2)\n    return writeU_Int16LE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeU_Int48LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 5);\n\n  const newVal = MathFloor(value * 2 ** -32);\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  buf[offset++] = newVal;\n  buf[offset++] = (newVal >>> 8);\n  return offset;\n}\n\nfunction writeU_Int40LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 4);\n\n  const newVal = value;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  buf[offset++] = MathFloor(newVal * 2 ** -32);\n  return offset;\n}\n\nfunction writeU_Int32LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 3);\n\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeUInt32LE(value\x2C offset = 0) {\n  return writeU_Int32LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n}\n\nfunction writeU_Int24LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 2);\n\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeU_Int16LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 1);\n\n  buf[offset++] = value;\n  buf[offset++] = (value >>> 8);\n  return offset;\n}\n\nfunction writeUInt16LE(value\x2C offset = 0) {\n  return writeU_Int16LE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n}\n\nfunction writeU_Int8(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  // `checkInt()` can not be used here because it checks two entries.\n  validateNumber(offset\x2C 'offset');\n  if (value > max || value < min) {\n    throw new ERR_OUT_OF_RANGE('value'\x2C `>= ${min} and <= ${max}`\x2C value);\n  }\n  if (buf[offset] === undefined)\n    boundsError(offset\x2C buf.length - 1);\n\n  buf[offset] = value;\n  return offset + 1;\n}\n\nfunction writeUInt8(value\x2C offset = 0) {\n  return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n}\n\nfunction writeUIntBE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffff);\n  if (byteLength === 3)\n    return writeU_Int24BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffff);\n  if (byteLength === 4)\n    return writeU_Int32BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n  if (byteLength === 2)\n    return writeU_Int16BE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeU_Int48BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 5);\n\n  const newVal = MathFloor(value * 2 ** -32);\n  buf[offset++] = (newVal >>> 8);\n  buf[offset++] = newVal;\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeU_Int40BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 4);\n\n  buf[offset++] = MathFloor(value * 2 ** -32);\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeU_Int32BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 3);\n\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeUInt32BE(value\x2C offset = 0) {\n  return writeU_Int32BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n}\n\nfunction writeU_Int24BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 2);\n\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 3;\n}\n\nfunction writeU_Int16BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 1);\n\n  buf[offset++] = (value >>> 8);\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeUInt16BE(value\x2C offset = 0) {\n  return writeU_Int16BE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n}\n\nfunction writeIntLE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48LE(this\x2C value\x2C offset\x2C -0x800000000000\x2C 0x7fffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40LE(this\x2C value\x2C offset\x2C -0x8000000000\x2C 0x7fffffffff);\n  if (byteLength === 3)\n    return writeU_Int24LE(this\x2C value\x2C offset\x2C -0x800000\x2C 0x7fffff);\n  if (byteLength === 4)\n    return writeU_Int32LE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n  if (byteLength === 2)\n    return writeU_Int16LE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeInt32LE(value\x2C offset = 0) {\n  return writeU_Int32LE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n}\n\nfunction writeInt16LE(value\x2C offset = 0) {\n  return writeU_Int16LE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n}\n\nfunction writeInt8(value\x2C offset = 0) {\n  return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n}\n\nfunction writeIntBE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48BE(this\x2C value\x2C offset\x2C -0x800000000000\x2C 0x7fffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40BE(this\x2C value\x2C offset\x2C -0x8000000000\x2C 0x7fffffffff);\n  if (byteLength === 3)\n    return writeU_Int24BE(this\x2C value\x2C offset\x2C -0x800000\x2C 0x7fffff);\n  if (byteLength === 4)\n    return writeU_Int32BE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n  if (byteLength === 2)\n    return writeU_Int16BE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeInt32BE(value\x2C offset = 0) {\n  return writeU_Int32BE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n}\n\nfunction writeInt16BE(value\x2C offset = 0) {\n  return writeU_Int16BE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n}\n\n// Write floats.\nfunction writeDoubleForwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 7);\n\n  float64Array[0] = val;\n  this[offset++] = uInt8Float64Array[0];\n  this[offset++] = uInt8Float64Array[1];\n  this[offset++] = uInt8Float64Array[2];\n  this[offset++] = uInt8Float64Array[3];\n  this[offset++] = uInt8Float64Array[4];\n  this[offset++] = uInt8Float64Array[5];\n  this[offset++] = uInt8Float64Array[6];\n  this[offset++] = uInt8Float64Array[7];\n  return offset;\n}\n\nfunction writeDoubleBackwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 7);\n\n  float64Array[0] = val;\n  this[offset++] = uInt8Float64Array[7];\n  this[offset++] = uInt8Float64Array[6];\n  this[offset++] = uInt8Float64Array[5];\n  this[offset++] = uInt8Float64Array[4];\n  this[offset++] = uInt8Float64Array[3];\n  this[offset++] = uInt8Float64Array[2];\n  this[offset++] = uInt8Float64Array[1];\n  this[offset++] = uInt8Float64Array[0];\n  return offset;\n}\n\nfunction writeFloatForwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 3);\n\n  float32Array[0] = val;\n  this[offset++] = uInt8Float32Array[0];\n  this[offset++] = uInt8Float32Array[1];\n  this[offset++] = uInt8Float32Array[2];\n  this[offset++] = uInt8Float32Array[3];\n  return offset;\n}\n\nfunction writeFloatBackwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 3);\n\n  float32Array[0] = val;\n  this[offset++] = uInt8Float32Array[3];\n  this[offset++] = uInt8Float32Array[2];\n  this[offset++] = uInt8Float32Array[1];\n  this[offset++] = uInt8Float32Array[0];\n  return offset;\n}\n\nclass FastBuffer extends Uint8Array {\n  // Using an explicit constructor here is necessary to avoid relying on\n  // `Array.prototype[Symbol.iterator]`\x2C which can be mutated by users.\n  // eslint-disable-next-line no-useless-constructor\n  constructor(bufferOrLength\x2C byteOffset\x2C length) {\n    super(bufferOrLength\x2C byteOffset\x2C length);\n  }\n}\n\nfunction addBufferPrototypeMethods(proto) {\n  proto.readBigUInt64LE = readBigUInt64LE;\n  proto.readBigUInt64BE = readBigUInt64BE;\n  proto.readBigUint64LE = readBigUInt64LE;\n  proto.readBigUint64BE = readBigUInt64BE;\n  proto.readBigInt64LE = readBigInt64LE;\n  proto.readBigInt64BE = readBigInt64BE;\n  proto.writeBigUInt64LE = writeBigUInt64LE;\n  proto.writeBigUInt64BE = writeBigUInt64BE;\n  proto.writeBigUint64LE = writeBigUInt64LE;\n  proto.writeBigUint64BE = writeBigUInt64BE;\n  proto.writeBigInt64LE = writeBigInt64LE;\n  proto.writeBigInt64BE = writeBigInt64BE;\n\n  proto.readUIntLE = readUIntLE;\n  proto.readUInt32LE = readUInt32LE;\n  proto.readUInt16LE = readUInt16LE;\n  proto.readUInt8 = readUInt8;\n  proto.readUIntBE = readUIntBE;\n  proto.readUInt32BE = readUInt32BE;\n  proto.readUInt16BE = readUInt16BE;\n  proto.readUintLE = readUIntLE;\n  proto.readUint32LE = readUInt32LE;\n  proto.readUint16LE = readUInt16LE;\n  proto.readUint8 = readUInt8;\n  proto.readUintBE = readUIntBE;\n  proto.readUint32BE = readUInt32BE;\n  proto.readUint16BE = readUInt16BE;\n  proto.readIntLE = readIntLE;\n  proto.readInt32LE = readInt32LE;\n  proto.readInt16LE = readInt16LE;\n  proto.readInt8 = readInt8;\n  proto.readIntBE = readIntBE;\n  proto.readInt32BE = readInt32BE;\n  proto.readInt16BE = readInt16BE;\n\n  proto.writeUIntLE = writeUIntLE;\n  proto.writeUInt32LE = writeUInt32LE;\n  proto.writeUInt16LE = writeUInt16LE;\n  proto.writeUInt8 = writeUInt8;\n  proto.writeUIntBE = writeUIntBE;\n  proto.writeUInt32BE = writeUInt32BE;\n  proto.writeUInt16BE = writeUInt16BE;\n  proto.writeUintLE = writeUIntLE;\n  proto.writeUint32LE = writeUInt32LE;\n  proto.writeUint16LE = writeUInt16LE;\n  proto.writeUint8 = writeUInt8;\n  proto.writeUintBE = writeUIntBE;\n  proto.writeUint32BE = writeUInt32BE;\n  proto.writeUint16BE = writeUInt16BE;\n  proto.writeIntLE = writeIntLE;\n  proto.writeInt32LE = writeInt32LE;\n  proto.writeInt16LE = writeInt16LE;\n  proto.writeInt8 = writeInt8;\n  proto.writeIntBE = writeIntBE;\n  proto.writeInt32BE = writeInt32BE;\n  proto.writeInt16BE = writeInt16BE;\n\n  proto.readFloatLE = bigEndian ? readFloatBackwards : readFloatForwards;\n  proto.readFloatBE = bigEndian ? readFloatForwards : readFloatBackwards;\n  proto.readDoubleLE = bigEndian ? readDoubleBackwards : readDoubleForwards;\n  proto.readDoubleBE = bigEndian ? readDoubleForwards : readDoubleBackwards;\n  proto.writeFloatLE = bigEndian ? writeFloatBackwards : writeFloatForwards;\n  proto.writeFloatBE = bigEndian ? writeFloatForwards : writeFloatBackwards;\n  proto.writeDoubleLE = bigEndian ? writeDoubleBackwards : writeDoubleForwards;\n  proto.writeDoubleBE = bigEndian ? writeDoubleForwards : writeDoubleBackwards;\n\n  proto.asciiSlice = asciiSlice;\n  proto.base64Slice = base64Slice;\n  proto.base64urlSlice = base64urlSlice;\n  proto.latin1Slice = latin1Slice;\n  proto.hexSlice = hexSlice;\n  proto.ucs2Slice = ucs2Slice;\n  proto.utf8Slice = utf8Slice;\n  proto.asciiWrite = asciiWrite;\n  proto.base64Write = base64Write;\n  proto.base64urlWrite = base64urlWrite;\n  proto.latin1Write = latin1Write;\n  proto.hexWrite = hexWrite;\n  proto.ucs2Write = ucs2Write;\n  proto.utf8Write = utf8Write;\n}\n\n// This would better be placed in internal/worker/io.js\x2C but that doesn't work\n// because Buffer needs this and that would introduce a cyclic dependency.\nfunction markAsUntransferable(obj) {\n  if ((typeof obj !== 'object' && typeof obj !== 'function') || obj === null)\n    return;  // This object is a primitive and therefore already untransferable.\n  obj[untransferable_object_private_symbol] = true;\n}\n\n// A toggle used to access the zero fill setting of the array buffer allocator\n// in C++.\n// |zeroFill| can be undefined when running inside an isolate where we\n// do not own the ArrayBuffer allocator.  Zero fill is always on in that case.\nlet zeroFill = getZeroFillToggle();\nfunction createUnsafeBuffer(size) {\n  zeroFill[0] = 0;\n  try {\n    return new FastBuffer(size);\n  } finally {\n    zeroFill[0] = 1;\n  }\n}\n\n// The connection between the JS land zero fill toggle and the\n// C++ one in the NodeArrayBufferAllocator gets lost if the toggle\n// is deserialized from the snapshot\x2C because V8 owns the underlying\n// memory of this toggle. This resets the connection.\nfunction reconnectZeroFillToggle() {\n  zeroFill = getZeroFillToggle();\n}\n\nmodule.exports = {\n  FastBuffer\x2C\n  addBufferPrototypeMethods\x2C\n  markAsUntransferable\x2C\n  createUnsafeBuffer\x2C\n  readUInt16BE\x2C\n  readUInt32BE\x2C\n  reconnectZeroFillToggle\x2C\n};\n
code-source-info,0x31e63e0bda56,25,30714,30754,C0O30721C5O30732C11O30730C18O30753,,
tick,0x7ff8093035a2,33254,0,0x0,3,0x10c9f09d0,0x31e63e0bd330,0x31e63e0bb686,0x31e63e0bb024
tick,0x10c6e4407,33266,0,0x0,3,0x10c9f09d0,0x31e63e0bd330,0x31e63e0bb686,0x31e63e0bb024
new,MemoryChunk,0x31e6f6b40000,262144
code-creation,JS,10,33362,0x31e6f6b4144e,462,patchProcessObject node:internal/process/pre_execution:209:28,0x31e647c79768,~
code-source-info,0x31e6f6b4144e,67,6275,8678,C0O6309C6O6309C11O6355C19O6355C24O6387C30O6387C35O6425C40O6426C44O6552C55O6573C62O6707C65O6707C75O6748C81O6752C88O6552C93O6766C97O6783C101O6798C105O6815C109O6826C112O6834C122O6852C126O6842C130O6893C132O7048C139O7075C146O7079C153O7093C159O7127C166O7131C173O7093C180O7209C186O7209C194O7259C202O7275C209O7279C213O7259C219O7291C222O7299C232O7307C242O7532C248O7532C253O7606C259O7606C264O7578C269O7649C273O7832C282O7832C287O7878C296O7878C301O7931C310O7931C315O7991C324O7991C329O8049C338O8049C343O8109C352O8109C357O8173C366O8173C371O8238C380O8238C385O8309C394O8309C399O8379C408O8379C413O8439C422O8439C427O8509C438O8509C443O8579C454O8579C459O8659C461O8676,,
code-creation,JS,10,33556,0x31e6f6b41a46,134,set node:internal/bootstrap/node:116:8,0x31e6931bbfd8,~
script-source,12,node:internal/bootstrap/node,// Hello\x2C and welcome to hacking node.js!\n//\n// This file is invoked by `Realm::BootstrapRealm()` in `src/node_realm.cc`\x2C\n// and is responsible for setting up Node.js core before main scripts\n// under `lib/internal/main/` are executed.\n//\n// By default\x2C Node.js binaries come with an embedded V8 startup snapshot\n// that is generated at build-time with a `node_mksnapshot` executable.\n// The snapshot generation code can be found in `SnapshotBuilder::Generate()`\n// from `src/node_snapshotable.cc`.\n// This snapshot captures the V8 heap initialized by scripts under\n// `lib/internal/bootstrap/`\x2C including this file. When initializing the main\n// thread\x2C Node.js deserializes the heap from the snapshot\x2C instead of actually\n// running this script and others in `lib/internal/bootstrap/`. To disable this\n// behavior\x2C pass `--no-node-snapshot` when starting the process so that\n// Node.js actually runs this script to initialize the heap.\n//\n// This script is expected not to perform any asynchronous operations itself\n// when being executed - those should be done in either\n// `lib/internal/process/pre_execution.js` or in main scripts. It should not\n// query any run-time states (e.g. command line arguments\x2C environment\n// variables) when being executed - functions in this script that are invoked\n// at a later time can\x2C however\x2C query those states lazily.\n// The majority of the code here focuses on setting up the global object and\n// the process object in a synchronous\x2C environment-independent manner.\n//\n// Scripts run before this file:\n// - `lib/internal/per_context/primordials.js`: this saves copies of JavaScript\n//   builtins that won't be affected by user land monkey-patching for internal\n//   modules to use.\n// - `lib/internal/per_context/domexception.js`: implementation of the\n//   `DOMException` class.\n// - `lib/internal/per_context/messageport.js`: JS-side components of the\n//   `MessagePort` implementation.\n// - `lib/internal/bootstrap/realm.js`: this sets up internal binding and\n//   module loaders\x2C including `process.binding()`\x2C `process._linkedBinding()`\x2C\n//   `internalBinding()` and `BuiltinModule`\x2C and per-realm internal states\n//   and bindings\x2C including `prepare_stack_trace_callback`.\n//\n// The initialization done in this script is included in both the main thread\n// and the worker threads. After this\x2C further initialization is done based\n// on the configuration of the Node.js instance by executing the scripts in\n// `lib/internal/bootstrap/switches/`.\n//\n// Then\x2C depending on how the Node.js instance is launched\x2C one of the main\n// scripts in `lib/internal/main` will be selected by C++ to start the actual\n// execution. They may run additional setups exported by\n// `lib/internal/process/pre_execution.js` depending on the run-time states.\n\n'use strict';\n\n// This file is compiled as if it's wrapped in a function with arguments\n// passed by `BuiltinLoader::CompileAndCall()`.\n/* global process\x2C require\x2C internalBinding\x2C primordials */\n\nconst {\n  FunctionPrototypeCall\x2C\n  JSONParse\x2C\n  Number\x2C\n  NumberIsNaN\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  ObjectFreeze\x2C\n  SymbolToStringTag\x2C\n  globalThis\x2C\n} = primordials;\nconst config = internalBinding('config');\nconst internalTimers = require('internal/timers');\nconst {\n  defineOperation\x2C\n  deprecate\x2C\n} = require('internal/util');\nconst {\n  validateInteger\x2C\n} = require('internal/validators');\nconst {\n  constants: {\n    kExitCode\x2C\n    kExiting\x2C\n    kHasExitCode\x2C\n  }\x2C\n  privateSymbols: {\n    exit_info_private_symbol\x2C\n  }\x2C\n} = internalBinding('util');\n\nsetupProcessObject();\n\nsetupGlobalProxy();\nsetupBuffer();\n\nprocess.domain = null;\n\n// process._exiting and process.exitCode\n{\n  const fields = process[exit_info_private_symbol];\n  ObjectDefineProperty(process\x2C '_exiting'\x2C {\n    __proto__: null\x2C\n    get() {\n      return fields[kExiting] === 1;\n    }\x2C\n    set(value) {\n      fields[kExiting] = value ? 1 : 0;\n    }\x2C\n    enumerable: true\x2C\n    configurable: true\x2C\n  });\n\n  let exitCode;\n  ObjectDefineProperty(process\x2C 'exitCode'\x2C {\n    __proto__: null\x2C\n    get() {\n      return exitCode;\n    }\x2C\n    set(code) {\n      if (code !== null && code !== undefined) {\n        let value = code;\n        if (typeof code === 'string' && code !== '' &&\n          NumberIsNaN((value = Number(code)))) {\n          value = code;\n        }\n        validateInteger(value\x2C 'code');\n        fields[kExitCode] = value;\n        fields[kHasExitCode] = 1;\n      } else {\n        fields[kHasExitCode] = 0;\n      }\n      exitCode = code;\n    }\x2C\n    enumerable: true\x2C\n    configurable: false\x2C\n  });\n}\nprocess._exiting = false;\n\n// process.config is serialized config.gypi\nconst binding = internalBinding('builtins');\n\nconst processConfig = JSONParse(binding.config\x2C (_key\x2C value) => {\n  // The `reviver` argument of the JSONParse method will visit all the values of\n  // the parsed config\x2C including the "root" object\x2C so there is no need to\n  // explicitly freeze the config outside of this method\n  return ObjectFreeze(value);\n});\n\nObjectDefineProperty(process\x2C 'config'\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  configurable: true\x2C\n  value: processConfig\x2C\n});\n\nrequire('internal/worker/js_transferable').setup();\n\n// Bootstrappers for all threads\x2C including worker threads and main thread\nconst perThreadSetup = require('internal/process/per_thread');\nconst rawMethods = internalBinding('process_methods');\n\n// Set up methods on the process object for all threads\n{\n  process.dlopen = rawMethods.dlopen;\n  process.uptime = rawMethods.uptime;\n\n  // TODO(joyeecheung): either remove them or make them public\n  process._getActiveRequests = rawMethods._getActiveRequests;\n  process._getActiveHandles = rawMethods._getActiveHandles;\n  process.getActiveResourcesInfo = rawMethods.getActiveResourcesInfo;\n\n  // TODO(joyeecheung): remove these\n  process.reallyExit = rawMethods.reallyExit;\n  process._kill = rawMethods._kill;\n\n  const wrapped = perThreadSetup.wrapProcessMethods(rawMethods);\n  process._rawDebug = wrapped._rawDebug;\n  process.cpuUsage = wrapped.cpuUsage;\n  process.resourceUsage = wrapped.resourceUsage;\n  process.memoryUsage = wrapped.memoryUsage;\n  process.constrainedMemory = rawMethods.constrainedMemory;\n  process.kill = wrapped.kill;\n  process.exit = wrapped.exit;\n\n  process.hrtime = perThreadSetup.hrtime;\n  process.hrtime.bigint = perThreadSetup.hrtimeBigInt;\n\n  process.openStdin = function() {\n    process.stdin.resume();\n    return process.stdin;\n  };\n}\n\nconst credentials = internalBinding('credentials');\nif (credentials.implementsPosixCredentials) {\n  process.getuid = credentials.getuid;\n  process.geteuid = credentials.geteuid;\n  process.getgid = credentials.getgid;\n  process.getegid = credentials.getegid;\n  process.getgroups = credentials.getgroups;\n}\n\n// Setup the callbacks that node::AsyncWrap will call when there are hooks to\n// process. They use the same functions as the JS embedder API. These callbacks\n// are setup immediately to prevent async_wrap.setupHooks() from being hijacked\n// and the cost of doing so is negligible.\nconst { nativeHooks } = require('internal/async_hooks');\ninternalBinding('async_wrap').setupHooks(nativeHooks);\n\nconst {\n  setupTaskQueue\x2C\n} = require('internal/process/task_queues');\nconst timers = require('timers');\n// Non-standard extensions:\ndefineOperation(globalThis\x2C 'clearImmediate'\x2C timers.clearImmediate);\ndefineOperation(globalThis\x2C 'setImmediate'\x2C timers.setImmediate);\n\n// Set the per-Environment callback that will be called\n// when the TrackingTraceStateObserver updates trace state.\n// Note that when NODE_USE_V8_PLATFORM is true\x2C the observer is\n// attached to the per-process TracingController.\nconst { setTraceCategoryStateUpdateHandler } = internalBinding('trace_events');\nsetTraceCategoryStateUpdateHandler(perThreadSetup.toggleTraceCategoryState);\n\n// process.allowedNodeEnvironmentFlags\nObjectDefineProperty(process\x2C 'allowedNodeEnvironmentFlags'\x2C {\n  __proto__: null\x2C\n  get() {\n    const flags = perThreadSetup.buildAllowedFlags();\n    process.allowedNodeEnvironmentFlags = flags;\n    return process.allowedNodeEnvironmentFlags;\n  }\x2C\n  // If the user tries to set this to another value\x2C override\n  // this completely to that value.\n  set(value) {\n    ObjectDefineProperty(this\x2C 'allowedNodeEnvironmentFlags'\x2C {\n      __proto__: null\x2C\n      value\x2C\n      configurable: true\x2C\n      enumerable: true\x2C\n      writable: true\x2C\n    });\n  }\x2C\n  enumerable: true\x2C\n  configurable: true\x2C\n});\n\n// process.assert\nprocess.assert = deprecate(\n  perThreadSetup.assert\x2C\n  'process.assert() is deprecated. Please use the `assert` module instead.'\x2C\n  'DEP0100');\n\n// TODO(joyeecheung): this property has not been well-maintained\x2C should we\n// deprecate it in favor of a better API?\nconst { isDebugBuild\x2C hasOpenSSL\x2C hasInspector } = config;\nconst features = {\n  inspector: hasInspector\x2C\n  debug: isDebugBuild\x2C\n  uv: true\x2C\n  ipv6: true\x2C  // TODO(bnoordhuis) ping libuv\n  tls_alpn: hasOpenSSL\x2C\n  tls_sni: hasOpenSSL\x2C\n  tls_ocsp: hasOpenSSL\x2C\n  tls: hasOpenSSL\x2C\n  // This needs to be dynamic because --no-node-snapshot disables the\n  // code cache even if the binary is built with embedded code cache.\n  get cached_builtins() {\n    return binding.hasCachedBuiltins();\n  }\x2C\n};\n\nObjectDefineProperty(process\x2C 'features'\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  writable: false\x2C\n  configurable: false\x2C\n  value: features\x2C\n});\n\n{\n  const {\n    onGlobalUncaughtException\x2C\n    setUncaughtExceptionCaptureCallback\x2C\n    hasUncaughtExceptionCaptureCallback\x2C\n  } = require('internal/process/execution');\n\n  // For legacy reasons this is still called `_fatalException`\x2C even\n  // though it is now a global uncaught exception handler.\n  // The C++ land node::errors::TriggerUncaughtException grabs it\n  // from the process object because it has been monkey-patchable.\n  // TODO(joyeecheung): investigate whether process._fatalException\n  // can be deprecated.\n  process._fatalException = onGlobalUncaughtException;\n  process.setUncaughtExceptionCaptureCallback =\n    setUncaughtExceptionCaptureCallback;\n  process.hasUncaughtExceptionCaptureCallback =\n    hasUncaughtExceptionCaptureCallback;\n}\n\nconst { emitWarning } = require('internal/process/warning');\nprocess.emitWarning = emitWarning;\n\n// We initialize the tick callbacks and the timer callbacks last during\n// bootstrap to make sure that any operation done before this are synchronous.\n// If any ticks or timers are scheduled before this they are unlikely to work.\n{\n  const { nextTick\x2C runNextTicks } = setupTaskQueue();\n  process.nextTick = nextTick;\n  // Used to emulate a tick manually in the JS land.\n  // A better name for this function would be `runNextTicks` but\n  // it has been exposed to the process object so we keep this legacy name\n  // TODO(joyeecheung): either remove it or make it public\n  process._tickCallback = runNextTicks;\n\n  const { setupTimers } = internalBinding('timers');\n  const {\n    processImmediate\x2C\n    processTimers\x2C\n  } = internalTimers.getTimerCallbacks(runNextTicks);\n  // Sets two per-Environment callbacks that will be run from libuv:\n  // - processImmediate will be run in the callback of the per-Environment\n  //   check handle.\n  // - processTimers will be run in the callback of the per-Environment timer.\n  setupTimers(processImmediate\x2C processTimers);\n  // Note: only after this point are the timers effective\n}\n\n{\n  const {\n    getSourceMapsEnabled\x2C\n    setSourceMapsEnabled\x2C\n    maybeCacheGeneratedSourceMap\x2C\n  } = require('internal/source_map/source_map_cache');\n  const {\n    setMaybeCacheGeneratedSourceMap\x2C\n  } = internalBinding('errors');\n\n  ObjectDefineProperty(process\x2C 'sourceMapsEnabled'\x2C {\n    __proto__: null\x2C\n    enumerable: true\x2C\n    configurable: true\x2C\n    get() {\n      return getSourceMapsEnabled();\n    }\x2C\n  });\n  process.setSourceMapsEnabled = setSourceMapsEnabled;\n  // The C++ land calls back to maybeCacheGeneratedSourceMap()\n  // when code is generated by user with eval() or new Function()\n  // to cache the source maps from the evaluated code\x2C if any.\n  setMaybeCacheGeneratedSourceMap(maybeCacheGeneratedSourceMap);\n}\n\nfunction setupProcessObject() {\n  const EventEmitter = require('events');\n  const origProcProto = ObjectGetPrototypeOf(process);\n  ObjectSetPrototypeOf(origProcProto\x2C EventEmitter.prototype);\n  FunctionPrototypeCall(EventEmitter\x2C process);\n  ObjectDefineProperty(process\x2C SymbolToStringTag\x2C {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    writable: true\x2C\n    configurable: false\x2C\n    value: 'process'\x2C\n  });\n\n  // Create global.process as getters so that we have a\n  // deprecation path for these in ES Modules.\n  // See https://github.com/nodejs/node/pull/26334.\n  let _process = process;\n  ObjectDefineProperty(globalThis\x2C 'process'\x2C {\n    __proto__: null\x2C\n    get() {\n      return _process;\n    }\x2C\n    set(value) {\n      _process = value;\n    }\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n  });\n}\n\nfunction setupGlobalProxy() {\n  ObjectDefineProperty(globalThis\x2C SymbolToStringTag\x2C {\n    __proto__: null\x2C\n    value: 'global'\x2C\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n  });\n  globalThis.global = globalThis;\n}\n\nfunction setupBuffer() {\n  const {\n    Buffer\x2C\n  } = require('buffer');\n  const bufferBinding = internalBinding('buffer');\n\n  // Only after this point can C++ use Buffer::New()\n  bufferBinding.setBufferPrototype(Buffer.prototype);\n  delete bufferBinding.setBufferPrototype;\n\n  // Create global.Buffer as getters so that we have a\n  // deprecation path for these in ES Modules.\n  // See https://github.com/nodejs/node/pull/26334.\n  let _Buffer = Buffer;\n  ObjectDefineProperty(globalThis\x2C 'Buffer'\x2C {\n    __proto__: null\x2C\n    get() {\n      return _Buffer;\n    }\x2C\n    set(value) {\n      _Buffer = value;\n    }\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n  });\n}\n
code-source-info,0x31e6f6b41a46,12,4131,4547,C0O4146C8O4209C11O4223C19O4260C28O4280C35O4301C38O4301C43O4280C49O4329C54O4361C64O4361C69O4401C78O4408C83O4419C87O4436C96O4443C101O4457C107O4485C116O4492C120O4506C124O4525C126O4534C133O4546,,
tick,0x7ff8091ad5d5,34530,0,0x0,3,0x10c9f09d0,0x31e6f6b414af,0x31e63e0bd336,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,34622,0x31e6f6b4299e,189,resolve node:path:1095:10,0x31e647c5b680,~
script-source,34,node:path,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  FunctionPrototypeBind\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToLowerCase\x2C\n} = primordials;\n\nconst {\n  CHAR_UPPERCASE_A\x2C\n  CHAR_LOWERCASE_A\x2C\n  CHAR_UPPERCASE_Z\x2C\n  CHAR_LOWERCASE_Z\x2C\n  CHAR_DOT\x2C\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_COLON\x2C\n  CHAR_QUESTION_MARK\x2C\n} = require('internal/constants');\nconst {\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst platformIsWin32 = (process.platform === 'win32');\n\nfunction isPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code) {\n  return (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n         (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path\x2C allowAboveRoot\x2C separator\x2C isPathSeparator) {\n  let res = '';\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = 0;\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = StringPrototypeCharCodeAt(path\x2C i);\n    else if (isPathSeparator(code))\n      break;\n    else\n      code = CHAR_FORWARD_SLASH;\n\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 ||\n            StringPrototypeCharCodeAt(res\x2C res.length - 1) !== CHAR_DOT ||\n            StringPrototypeCharCodeAt(res\x2C res.length - 2) !== CHAR_DOT) {\n          if (res.length > 2) {\n            const lastSlashIndex = StringPrototypeLastIndexOf(res\x2C separator);\n            if (lastSlashIndex === -1) {\n              res = '';\n              lastSegmentLength = 0;\n            } else {\n              res = StringPrototypeSlice(res\x2C 0\x2C lastSlashIndex);\n              lastSegmentLength =\n                res.length - 1 - StringPrototypeLastIndexOf(res\x2C separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length !== 0) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? `${separator}..` : '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += `${separator}${StringPrototypeSlice(path\x2C lastSlash + 1\x2C i)}`;\n        else\n          res = StringPrototypeSlice(path\x2C lastSlash + 1\x2C i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction formatExt(ext) {\n  return ext ? `${ext[0] === '.' ? '' : '.'}${ext}` : '';\n}\n\n/**\n * @param {string} sep\n * @param {{\n *  dir?: string;\n *  root?: string;\n *  base?: string;\n *  name?: string;\n *  ext?: string;\n *  }} pathObject\n * @returns {string}\n */\nfunction _format(sep\x2C pathObject) {\n  validateObject(pathObject\x2C 'pathObject');\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base ||\n    `${pathObject.name || ''}${formatExt(pathObject.ext)}`;\n  if (!dir) {\n    return base;\n  }\n  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nconst win32 = {\n  /**\n   * path.resolve([from ...]\x2C to)\n   * @param {...string} args\n   * @returns {string}\n   */\n  resolve(...args) {\n    let resolvedDevice = '';\n    let resolvedTail = '';\n    let resolvedAbsolute = false;\n\n    for (let i = args.length - 1; i >= -1; i--) {\n      let path;\n      if (i >= 0) {\n        path = args[i];\n        validateString(path\x2C `paths[${i}]`);\n\n        // Skip empty entries\n        if (path.length === 0) {\n          continue;\n        }\n      } else if (resolvedDevice.length === 0) {\n        path = process.cwd();\n      } else {\n        // Windows has the concept of drive-specific current working\n        // directories. If we've resolved a drive letter but not yet an\n        // absolute path\x2C get cwd for that drive\x2C or the process cwd if\n        // the drive cwd is not available. We're sure the device is not\n        // a UNC path at this points\x2C because UNC paths are always absolute.\n        path = process.env[`=${resolvedDevice}`] || process.cwd();\n\n        // Verify that a cwd was found and that it actually points\n        // to our drive. If not\x2C default to the drive's root.\n        if (path === undefined ||\n            (StringPrototypeToLowerCase(StringPrototypeSlice(path\x2C 0\x2C 2)) !==\n            StringPrototypeToLowerCase(resolvedDevice) &&\n            StringPrototypeCharCodeAt(path\x2C 2) === CHAR_BACKWARD_SLASH)) {\n          path = `${resolvedDevice}\\\\`;\n        }\n      }\n\n      const len = path.length;\n      let rootEnd = 0;\n      let device = '';\n      let isAbsolute = false;\n      const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n      // Try to match a root\n      if (len === 1) {\n        if (isPathSeparator(code)) {\n          // `path` contains just a path separator\n          rootEnd = 1;\n          isAbsolute = true;\n        }\n      } else if (isPathSeparator(code)) {\n        // Possible UNC root\n\n        // If we started with a separator\x2C we know we at least have an\n        // absolute path of some kind (UNC or otherwise)\n        isAbsolute = true;\n\n        if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n          // Matched double path separator at beginning\n          let j = 2;\n          let last = j;\n          // Match 1 or more non-path separators\n          while (j < len &&\n                 !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            const firstPart = StringPrototypeSlice(path\x2C last\x2C j);\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            while (j < len &&\n                   isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              while (j < len &&\n                     !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n                j++;\n              }\n              if (j === len || j !== last) {\n                // We matched a UNC root\n                device =\n                  `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last\x2C j)}`;\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if (isWindowsDeviceRoot(code) &&\n                  StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n        // Possible device root\n        device = StringPrototypeSlice(path\x2C 0\x2C 2);\n        rootEnd = 2;\n        if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n          // Treat separator following drive name as an absolute path\n          // indicator\n          isAbsolute = true;\n          rootEnd = 3;\n        }\n      }\n\n      if (device.length > 0) {\n        if (resolvedDevice.length > 0) {\n          if (StringPrototypeToLowerCase(device) !==\n              StringPrototypeToLowerCase(resolvedDevice))\n            // This path points to another device so it is not applicable\n            continue;\n        } else {\n          resolvedDevice = device;\n        }\n      }\n\n      if (resolvedAbsolute) {\n        if (resolvedDevice.length > 0)\n          break;\n      } else {\n        resolvedTail =\n          `${StringPrototypeSlice(path\x2C rootEnd)}\\\\${resolvedTail}`;\n        resolvedAbsolute = isAbsolute;\n        if (isAbsolute && resolvedDevice.length > 0) {\n          break;\n        }\n      }\n    }\n\n    // At this point the path should be resolved to a full absolute path\x2C\n    // but handle relative paths to be safe (might happen when process.cwd()\n    // fails)\n\n    // Normalize the tail path\n    resolvedTail = normalizeString(resolvedTail\x2C !resolvedAbsolute\x2C '\\\\'\x2C\n                                   isPathSeparator);\n\n    return resolvedAbsolute ?\n      `${resolvedDevice}\\\\${resolvedTail}` :\n      `${resolvedDevice}${resolvedTail}` || '.';\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  normalize(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    let rootEnd = 0;\n    let device;\n    let isAbsolute = false;\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    // Try to match a root\n    if (len === 1) {\n      // `path` contains just a single char\x2C exit early to avoid\n      // unnecessary work\n      return isPosixPathSeparator(code) ? '\\\\' : path;\n    }\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      // If we started with a separator\x2C we know we at least have an absolute\n      // path of some kind (UNC or otherwise)\n      isAbsolute = true;\n\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          const firstPart = StringPrototypeSlice(path\x2C last\x2C j);\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              // Return the normalized version of the UNC root since there\n              // is nothing left to process\n              return `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last)}\\\\`;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n              device =\n                `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last\x2C j)}`;\n              rootEnd = j;\n            }\n          }\n        }\n      } else {\n        rootEnd = 1;\n      }\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      // Possible device root\n      device = StringPrototypeSlice(path\x2C 0\x2C 2);\n      rootEnd = 2;\n      if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n        // Treat separator following drive name as an absolute path\n        // indicator\n        isAbsolute = true;\n        rootEnd = 3;\n      }\n    }\n\n    let tail = rootEnd < len ?\n      normalizeString(StringPrototypeSlice(path\x2C rootEnd)\x2C\n                      !isAbsolute\x2C '\\\\'\x2C isPathSeparator) :\n      '';\n    if (tail.length === 0 && !isAbsolute)\n      tail = '.';\n    if (tail.length > 0 &&\n        isPathSeparator(StringPrototypeCharCodeAt(path\x2C len - 1)))\n      tail += '\\\\';\n    if (device === undefined) {\n      return isAbsolute ? `\\\\${tail}` : tail;\n    }\n    return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {boolean}\n   */\n  isAbsolute(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return false;\n\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n    return isPathSeparator(code) ||\n      // Possible device root\n      (len > 2 &&\n      isWindowsDeviceRoot(code) &&\n      StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON &&\n      isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2)));\n  }\x2C\n\n  /**\n   * @param {...string} args\n   * @returns {string}\n   */\n  join(...args) {\n    if (args.length === 0)\n      return '.';\n\n    let joined;\n    let firstPart;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg\x2C 'path');\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = firstPart = arg;\n        else\n          joined += `\\\\${arg}`;\n      }\n    }\n\n    if (joined === undefined)\n      return '.';\n\n    // Make sure that the joined path doesn't start with two slashes\x2C because\n    // normalize() will mistake it for a UNC path then.\n    //\n    // This step is skipped when it is very clear that the user actually\n    // intended to point at a UNC path. This is assumed when the first\n    // non-empty string arguments starts with exactly two slashes followed by\n    // at least one more non-slash character.\n    //\n    // Note that for normalize() to treat a path as a UNC path it needs to\n    // have at least 2 components\x2C so we don't filter for that here.\n    // This means that the user can use join to construct UNC paths from\n    // a server name and a share name; for example:\n    //   path.join('//server'\x2C 'share') -> '\\\\\\\\server\\\\share\\\\')\n    let needsReplace = true;\n    let slashCount = 0;\n    if (isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 0))) {\n      ++slashCount;\n      const firstLen = firstPart.length;\n      if (firstLen > 1 &&\n          isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 1))) {\n        ++slashCount;\n        if (firstLen > 2) {\n          if (isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 2)))\n            ++slashCount;\n          else {\n            // We matched a UNC path in the first part\n            needsReplace = false;\n          }\n        }\n      }\n    }\n    if (needsReplace) {\n      // Find any more consecutive slashes we need to replace\n      while (slashCount < joined.length &&\n             isPathSeparator(StringPrototypeCharCodeAt(joined\x2C slashCount))) {\n        slashCount++;\n      }\n\n      // Replace the slashes if needed\n      if (slashCount >= 2)\n        joined = `\\\\${StringPrototypeSlice(joined\x2C slashCount)}`;\n    }\n\n    return win32.normalize(joined);\n  }\x2C\n\n  /**\n   * It will solve the relative path from `from` to `to`\x2C for instance\n   * from = 'C:\\\\orandea\\\\test\\\\aaa'\n   * to = 'C:\\\\orandea\\\\impl\\\\bbb'\n   * The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n   * @param {string} from\n   * @param {string} to\n   * @returns {string}\n   */\n  relative(from\x2C to) {\n    validateString(from\x2C 'from');\n    validateString(to\x2C 'to');\n\n    if (from === to)\n      return '';\n\n    const fromOrig = win32.resolve(from);\n    const toOrig = win32.resolve(to);\n\n    if (fromOrig === toOrig)\n      return '';\n\n    from = StringPrototypeToLowerCase(fromOrig);\n    to = StringPrototypeToLowerCase(toOrig);\n\n    if (from === to)\n      return '';\n\n    // Trim any leading backslashes\n    let fromStart = 0;\n    while (fromStart < from.length &&\n           StringPrototypeCharCodeAt(from\x2C fromStart) === CHAR_BACKWARD_SLASH) {\n      fromStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let fromEnd = from.length;\n    while (\n      fromEnd - 1 > fromStart &&\n      StringPrototypeCharCodeAt(from\x2C fromEnd - 1) === CHAR_BACKWARD_SLASH\n    ) {\n      fromEnd--;\n    }\n    const fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    let toStart = 0;\n    while (toStart < to.length &&\n           StringPrototypeCharCodeAt(to\x2C toStart) === CHAR_BACKWARD_SLASH) {\n      toStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let toEnd = to.length;\n    while (toEnd - 1 > toStart &&\n           StringPrototypeCharCodeAt(to\x2C toEnd - 1) === CHAR_BACKWARD_SLASH) {\n      toEnd--;\n    }\n    const toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = fromLen < toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = StringPrototypeCharCodeAt(from\x2C fromStart + i);\n      if (fromCode !== StringPrototypeCharCodeAt(to\x2C toStart + i))\n        break;\n      else if (fromCode === CHAR_BACKWARD_SLASH)\n        lastCommonSep = i;\n    }\n\n    // We found a mismatch before the first common path separator was seen\x2C so\n    // return the original `to`.\n    if (i !== length) {\n      if (lastCommonSep === -1)\n        return toOrig;\n    } else {\n      if (toLen > length) {\n        if (StringPrototypeCharCodeAt(to\x2C toStart + i) ===\n            CHAR_BACKWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n          return StringPrototypeSlice(toOrig\x2C toStart + i + 1);\n        }\n        if (i === 2) {\n          // We get here if `from` is the device root.\n          // For example: from='C:\\\\'; to='C:\\\\foo'\n          return StringPrototypeSlice(toOrig\x2C toStart + i);\n        }\n      }\n      if (fromLen > length) {\n        if (StringPrototypeCharCodeAt(from\x2C fromStart + i) ===\n            CHAR_BACKWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n          lastCommonSep = i;\n        } else if (i === 2) {\n          // We get here if `to` is the device root.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n          lastCommonSep = 3;\n        }\n      }\n      if (lastCommonSep === -1)\n        lastCommonSep = 0;\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to` and\n    // `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd ||\n          StringPrototypeCharCodeAt(from\x2C i) === CHAR_BACKWARD_SLASH) {\n        out += out.length === 0 ? '..' : '\\\\..';\n      }\n    }\n\n    toStart += lastCommonSep;\n\n    // Lastly\x2C append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return `${out}${StringPrototypeSlice(toOrig\x2C toStart\x2C toEnd)}`;\n\n    if (StringPrototypeCharCodeAt(toOrig\x2C toStart) === CHAR_BACKWARD_SLASH)\n      ++toStart;\n    return StringPrototypeSlice(toOrig\x2C toStart\x2C toEnd);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  toNamespacedPath(path) {\n    // Note: this will *probably* throw somewhere.\n    if (typeof path !== 'string' || path.length === 0)\n      return path;\n\n    const resolvedPath = win32.resolve(path);\n\n    if (resolvedPath.length <= 2)\n      return path;\n\n    if (StringPrototypeCharCodeAt(resolvedPath\x2C 0) === CHAR_BACKWARD_SLASH) {\n      // Possible UNC root\n      if (StringPrototypeCharCodeAt(resolvedPath\x2C 1) === CHAR_BACKWARD_SLASH) {\n        const code = StringPrototypeCharCodeAt(resolvedPath\x2C 2);\n        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n          // Matched non-long UNC root\x2C convert the path to a long UNC path\n          return `\\\\\\\\?\\\\UNC\\\\${StringPrototypeSlice(resolvedPath\x2C 2)}`;\n        }\n      }\n    } else if (\n      isWindowsDeviceRoot(StringPrototypeCharCodeAt(resolvedPath\x2C 0)) &&\n      StringPrototypeCharCodeAt(resolvedPath\x2C 1) === CHAR_COLON &&\n      StringPrototypeCharCodeAt(resolvedPath\x2C 2) === CHAR_BACKWARD_SLASH\n    ) {\n      // Matched device root\x2C convert the path to a long UNC path\n      return `\\\\\\\\?\\\\${resolvedPath}`;\n    }\n\n    return path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  dirname(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    let rootEnd = -1;\n    let offset = 0;\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    if (len === 1) {\n      // `path` contains just a path separator\x2C exit early to avoid\n      // unnecessary work or a dot.\n      return isPathSeparator(code) ? path : '.';\n    }\n\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = offset = 1;\n\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              return path;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n\n              // Offset by 1 to include the separator after the UNC root to\n              // treat it as a "normal root" on top of a (UNC) root\n              rootEnd = offset = j + 1;\n            }\n          }\n        }\n      }\n    // Possible device root\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      rootEnd =\n        len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2)) ? 3 : 2;\n      offset = rootEnd;\n    }\n\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = len - 1; i >= offset; --i) {\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C i))) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      if (rootEnd === -1)\n        return '.';\n\n      end = rootEnd;\n    }\n    return StringPrototypeSlice(path\x2C 0\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @param {string} [suffix]\n   * @returns {string}\n   */\n  basename(path\x2C suffix) {\n    if (suffix !== undefined)\n      validateString(suffix\x2C 'ext');\n    validateString(path\x2C 'path');\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n    if (path.length >= 2 &&\n        isWindowsDeviceRoot(StringPrototypeCharCodeAt(path\x2C 0)) &&\n        StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      start = 2;\n    }\n\n    if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {\n      if (suffix === path)\n        return '';\n      let extIdx = suffix.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= start; --i) {\n        const code = StringPrototypeCharCodeAt(path\x2C i);\n        if (isPathSeparator(code)) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string\x2C stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator\x2C remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === StringPrototypeCharCodeAt(suffix\x2C extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension\x2C so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match\x2C so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return StringPrototypeSlice(path\x2C start\x2C end);\n    }\n    for (let i = path.length - 1; i >= start; --i) {\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C i))) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1)\n      return '';\n    return StringPrototypeSlice(path\x2C start\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  extname(path) {\n    validateString(path\x2C 'path');\n    let start = 0;\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n\n    if (path.length >= 2 &&\n        StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON &&\n        isWindowsDeviceRoot(StringPrototypeCharCodeAt(path\x2C 0))) {\n      start = startPart = 2;\n    }\n\n    for (let i = path.length - 1; i >= start; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(path\x2C startDot\x2C end);\n  }\x2C\n\n  format: FunctionPrototypeBind(_format\x2C null\x2C '\\\\')\x2C\n\n  /**\n   * @param {string} path\n   * @returns {{\n   *  dir: string;\n   *  root: string;\n   *  base: string;\n   *  name: string;\n   *  ext: string;\n   *  }}\n   */\n  parse(path) {\n    validateString(path\x2C 'path');\n\n    const ret = { root: ''\x2C dir: ''\x2C base: ''\x2C ext: ''\x2C name: '' };\n    if (path.length === 0)\n      return ret;\n\n    const len = path.length;\n    let rootEnd = 0;\n    let code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    if (len === 1) {\n      if (isPathSeparator(code)) {\n        // `path` contains just a path separator\x2C exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      ret.base = ret.name = path;\n      return ret;\n    }\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = 1;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              rootEnd = j;\n            } else if (j !== last) {\n              // We matched a UNC root with leftovers\n              rootEnd = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      // Possible device root\n      if (len <= 2) {\n        // `path` contains just a drive root\x2C exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      rootEnd = 2;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n        if (len === 3) {\n          // `path` contains just a drive root\x2C exit early to avoid\n          // unnecessary work\n          ret.root = ret.dir = path;\n          return ret;\n        }\n        rootEnd = 3;\n      }\n    }\n    if (rootEnd > 0)\n      ret.root = StringPrototypeSlice(path\x2C 0\x2C rootEnd);\n\n    let startDot = -1;\n    let startPart = rootEnd;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= rootEnd; --i) {\n      code = StringPrototypeCharCodeAt(path\x2C i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      if (startDot === -1 ||\n          // We saw a non-dot character immediately before the dot\n          preDotState === 0 ||\n          // The (right-most) trimmed path component is exactly '..'\n          (preDotState === 1 &&\n           startDot === end - 1 &&\n           startDot === startPart + 1)) {\n        ret.base = ret.name = StringPrototypeSlice(path\x2C startPart\x2C end);\n      } else {\n        ret.name = StringPrototypeSlice(path\x2C startPart\x2C startDot);\n        ret.base = StringPrototypeSlice(path\x2C startPart\x2C end);\n        ret.ext = StringPrototypeSlice(path\x2C startDot\x2C end);\n      }\n    }\n\n    // If the directory is the root\x2C use the entire root as the `dir` including\n    // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise\x2C strip out the\n    // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n    if (startPart > 0 && startPart !== rootEnd)\n      ret.dir = StringPrototypeSlice(path\x2C 0\x2C startPart - 1);\n    else\n      ret.dir = ret.root;\n\n    return ret;\n  }\x2C\n\n  sep: '\\\\'\x2C\n  delimiter: ';'\x2C\n  win32: null\x2C\n  posix: null\x2C\n};\n\nconst posixCwd = (() => {\n  if (platformIsWin32) {\n    // Converts Windows' backslash path separators to POSIX forward slashes\n    // and truncates any drive indicator\n    const regexp = /\\\\/g;\n    return () => {\n      const cwd = StringPrototypeReplace(process.cwd()\x2C regexp\x2C '/');\n      return StringPrototypeSlice(cwd\x2C StringPrototypeIndexOf(cwd\x2C '/'));\n    };\n  }\n\n  // We're already on POSIX\x2C no need for any transformations\n  return () => process.cwd();\n})();\n\nconst posix = {\n  /**\n   * path.resolve([from ...]\x2C to)\n   * @param {...string} args\n   * @returns {string}\n   */\n  resolve(...args) {\n    let resolvedPath = '';\n    let resolvedAbsolute = false;\n\n    for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      const path = i >= 0 ? args[i] : posixCwd();\n      validateString(path\x2C `paths[${i}]`);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = `${path}/${resolvedPath}`;\n      resolvedAbsolute =\n        StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    }\n\n    // At this point the path should be resolved to a full absolute path\x2C but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeString(resolvedPath\x2C !resolvedAbsolute\x2C '/'\x2C\n                                   isPosixPathSeparator);\n\n    if (resolvedAbsolute) {\n      return `/${resolvedPath}`;\n    }\n    return resolvedPath.length > 0 ? resolvedPath : '.';\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  normalize(path) {\n    validateString(path\x2C 'path');\n\n    if (path.length === 0)\n      return '.';\n\n    const isAbsolute =\n      StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    const trailingSeparator =\n      StringPrototypeCharCodeAt(path\x2C path.length - 1) === CHAR_FORWARD_SLASH;\n\n    // Normalize the path\n    path = normalizeString(path\x2C !isAbsolute\x2C '/'\x2C isPosixPathSeparator);\n\n    if (path.length === 0) {\n      if (isAbsolute)\n        return '/';\n      return trailingSeparator ? './' : '.';\n    }\n    if (trailingSeparator)\n      path += '/';\n\n    return isAbsolute ? `/${path}` : path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {boolean}\n   */\n  isAbsolute(path) {\n    validateString(path\x2C 'path');\n    return path.length > 0 &&\n           StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n  }\x2C\n\n  /**\n   * @param {...string} args\n   * @returns {string}\n   */\n  join(...args) {\n    if (args.length === 0)\n      return '.';\n    let joined;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg\x2C 'path');\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += `/${arg}`;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  }\x2C\n\n  /**\n   * @param {string} from\n   * @param {string} to\n   * @returns {string}\n   */\n  relative(from\x2C to) {\n    validateString(from\x2C 'from');\n    validateString(to\x2C 'to');\n\n    if (from === to)\n      return '';\n\n    // Trim leading forward slashes.\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to)\n      return '';\n\n    const fromStart = 1;\n    const fromEnd = from.length;\n    const fromLen = fromEnd - fromStart;\n    const toStart = 1;\n    const toLen = to.length - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = (fromLen < toLen ? fromLen : toLen);\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = StringPrototypeCharCodeAt(from\x2C fromStart + i);\n      if (fromCode !== StringPrototypeCharCodeAt(to\x2C toStart + i))\n        break;\n      else if (fromCode === CHAR_FORWARD_SLASH)\n        lastCommonSep = i;\n    }\n    if (i === length) {\n      if (toLen > length) {\n        if (StringPrototypeCharCodeAt(to\x2C toStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return StringPrototypeSlice(to\x2C toStart + i + 1);\n        }\n        if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return StringPrototypeSlice(to\x2C toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (StringPrototypeCharCodeAt(from\x2C fromStart + i) ===\n            CHAR_FORWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo/bar'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`.\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd ||\n          StringPrototypeCharCodeAt(from\x2C i) === CHAR_FORWARD_SLASH) {\n        out += out.length === 0 ? '..' : '/..';\n      }\n    }\n\n    // Lastly\x2C append the rest of the destination (`to`) path that comes after\n    // the common path parts.\n    return `${out}${StringPrototypeSlice(to\x2C toStart + lastCommonSep)}`;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  toNamespacedPath(path) {\n    // Non-op on posix systems\n    return path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  dirname(path) {\n    validateString(path\x2C 'path');\n    if (path.length === 0)\n      return '.';\n    const hasRoot = StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = path.length - 1; i >= 1; --i) {\n      if (StringPrototypeCharCodeAt(path\x2C i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1)\n      return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1)\n      return '//';\n    return StringPrototypeSlice(path\x2C 0\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @param {string} [suffix]\n   * @returns {string}\n   */\n  basename(path\x2C suffix) {\n    if (suffix !== undefined)\n      validateString(suffix\x2C 'ext');\n    validateString(path\x2C 'path');\n\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n\n    if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {\n      if (suffix === path)\n        return '';\n      let extIdx = suffix.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= 0; --i) {\n        const code = StringPrototypeCharCodeAt(path\x2C i);\n        if (code === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string\x2C stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator\x2C remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === StringPrototypeCharCodeAt(suffix\x2C extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension\x2C so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match\x2C so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return StringPrototypeSlice(path\x2C start\x2C end);\n    }\n    for (let i = path.length - 1; i >= 0; --i) {\n      if (StringPrototypeCharCodeAt(path\x2C i) === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1)\n      return '';\n    return StringPrototypeSlice(path\x2C start\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  extname(path) {\n    validateString(path\x2C 'path');\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n    for (let i = path.length - 1; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(path\x2C startDot\x2C end);\n  }\x2C\n\n  format: FunctionPrototypeBind(_format\x2C null\x2C '/')\x2C\n\n  /**\n   * @param {string} path\n   * @returns {{\n   *   dir: string;\n   *   root: string;\n   *   base: string;\n   *   name: string;\n   *   ext: string;\n   *   }}\n   */\n  parse(path) {\n    validateString(path\x2C 'path');\n\n    const ret = { root: ''\x2C dir: ''\x2C base: ''\x2C ext: ''\x2C name: '' };\n    if (path.length === 0)\n      return ret;\n    const isAbsolute =\n      StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    let start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      const start = startPart === 0 && isAbsolute ? 1 : startPart;\n      if (startDot === -1 ||\n          // We saw a non-dot character immediately before the dot\n          preDotState === 0 ||\n          // The (right-most) trimmed path component is exactly '..'\n          (preDotState === 1 &&\n          startDot === end - 1 &&\n          startDot === startPart + 1)) {\n        ret.base = ret.name = StringPrototypeSlice(path\x2C start\x2C end);\n      } else {\n        ret.name = StringPrototypeSlice(path\x2C start\x2C startDot);\n        ret.base = StringPrototypeSlice(path\x2C start\x2C end);\n        ret.ext = StringPrototypeSlice(path\x2C startDot\x2C end);\n      }\n    }\n\n    if (startPart > 0)\n      ret.dir = StringPrototypeSlice(path\x2C 0\x2C startPart - 1);\n    else if (isAbsolute)\n      ret.dir = '/';\n\n    return ret;\n  }\x2C\n\n  sep: '/'\x2C\n  delimiter: ':'\x2C\n  win32: null\x2C\n  posix: null\x2C\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\n// Legacy internal API\x2C docs-only deprecated: DEP0080\nwin32._makeLong = win32.toNamespacedPath;\nposix._makeLong = posix.toNamespacedPath;\n\nmodule.exports = platformIsWin32 ? win32 : posix;\n
code-source-info,0x31e6f6b4299e,34,33911,34827,C0O33911C3O33946C6O33977C8O34007C12O34014C16O34027C18O34021C25O34031C27O34075C28O34077C35O34088C42O34094C45O34094C49O34112C59O34142C70O34112C75O34193C81O34200C86O34217C88O34242C100O34268C105O34290C112O34317C120O34356C122O34352C126O34050C131O33989C135O34572C140O34618C151O34587C157O34704C161O34734C166O34745C170O34760C171O34791C177O34798C188O34823,,
tick,0x7ff809250fcf,37257,0,0x0,3,0x10c9f09d0,0x31e6f6b41523,0x31e63e0bd336,0x31e63e0bb686,0x31e63e0bb024
tick,0x7ff8092271f2,37273,0,0x0,3,0x10c9f09d0,0x31e6f6b41523,0x31e63e0bd336,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,37384,0x31e6f6b45d3e,444,normalizeString node:path:66:25,0x31e647c5b220,~
code-source-info,0x31e6f6b45d3e,34,2161,4085,C0O2226C3O2256C5O2277C8O2294C10O2310C12O2328C14O2341C18O2333C23O2373C27O2366C32O2387C37O2394C45O2443C51O2472C53O2494C58O2530C64O2561C66O2581C69O2575C76O2593C83O2631C85O2640C90O2665C97O2672C104O2697C111O2718C114O2753C118O2760C122O2718C130O2769C132O2765C139O2793C142O2828C146O2835C150O2793C158O2844C160O2840C165O2874C172O2881C177O2923C182O2923C188O2979C190O2998C195O3022C198O3046C202O3104C215O3110C221O3210C225O3217C231O3223C234O3223C239O3221C243O3293C246O3320C248O3342C250O3377C256O3384C261O3405C264O3427C266O3462C269O3489C271O3511C273O3551C277O3594C283O3601C293O3610C308O3642C313O3706C319O3713C324O3728C326O3738C330O3750C335O3787C345O3750C363O3821C370O3864C380O3827C386O3881C388O3903C391O3915C395O3934C398O3955C402O3976C404O3989C406O3985C413O4006C418O4022C425O4049C428O2351C433O2315C441O4072C443O4083,,
code-creation,JS,10,37461,0x31e6f6b460c6,8,isPosixPathSeparator node:path:56:30,0x31e647c5b180,~
code-source-info,0x31e6f6b460c6,34,1854,1902,C0O1865C2O1881C4O1877C7O1900,,
code-creation,JS,10,37612,0x31e6f6b463de,376,initializeGlobalConsole node:internal/console/constructor:690:33,0x31e647c63918,~
script-source,44,node:internal/console/constructor,'use strict';\n\n// The Console constructor is not actually used to construct the global\n// console. It's exported for backwards compatibility.\n\nconst {\n  ArrayFrom\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeUnshift\x2C\n  Boolean\x2C\n  ErrorCaptureStackTrace\x2C\n  FunctionPrototypeBind\x2C\n  MathFloor\x2C\n  Number\x2C\n  NumberPrototypeToFixed\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectValues\x2C\n  ReflectApply\x2C\n  ReflectConstruct\x2C\n  ReflectOwnKeys\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  SafeArrayIterator\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  SafeSet\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypePadStart\x2C\n  StringPrototypeRepeat\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  Symbol\x2C\n  SymbolHasInstance\x2C\n  SymbolToStringTag\x2C\n} = primordials;\n\nconst { trace } = internalBinding('trace_events');\nconst {\n  isStackOverflowError\x2C\n  codes: {\n    ERR_CONSOLE_WRITABLE_STREAM\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INCOMPATIBLE_OPTION_PAIR\x2C\n  }\x2C\n} = require('internal/errors');\nconst {\n  validateArray\x2C\n  validateInteger\x2C\n  validateObject\x2C\n} = require('internal/validators');\nconst { previewEntries } = internalBinding('util');\nconst { Buffer: { isBuffer } } = require('buffer');\nconst {\n  inspect\x2C\n  formatWithOptions\x2C\n} = require('internal/util/inspect');\nconst {\n  isTypedArray\x2C isSet\x2C isMap\x2C isSetIterator\x2C isMapIterator\x2C\n} = require('internal/util/types');\nconst {\n  CHAR_LOWERCASE_B: kTraceBegin\x2C\n  CHAR_LOWERCASE_E: kTraceEnd\x2C\n  CHAR_LOWERCASE_N: kTraceInstant\x2C\n  CHAR_UPPERCASE_C: kTraceCount\x2C\n} = require('internal/constants');\nconst kCounts = Symbol('counts');\n\nconst kTraceConsoleCategory = 'node\x2Cnode.console';\n\nconst kSecond = 1000;\nconst kMinute = 60 * kSecond;\nconst kHour = 60 * kMinute;\nconst kMaxGroupIndentation = 1000;\n\n// Lazy loaded for startup performance.\nlet cliTable;\n\nlet utilColors;\nfunction lazyUtilColors() {\n  utilColors ??= require('internal/util/colors');\n  return utilColors;\n}\n\n// Track amount of indentation required via `console.group()`.\nconst kGroupIndent = Symbol('kGroupIndent');\nconst kGroupIndentationWidth = Symbol('kGroupIndentWidth');\nconst kFormatForStderr = Symbol('kFormatForStderr');\nconst kFormatForStdout = Symbol('kFormatForStdout');\nconst kGetInspectOptions = Symbol('kGetInspectOptions');\nconst kColorMode = Symbol('kColorMode');\nconst kIsConsole = Symbol('kIsConsole');\nconst kWriteToConsole = Symbol('kWriteToConsole');\nconst kBindProperties = Symbol('kBindProperties');\nconst kBindStreamsEager = Symbol('kBindStreamsEager');\nconst kBindStreamsLazy = Symbol('kBindStreamsLazy');\nconst kUseStdout = Symbol('kUseStdout');\nconst kUseStderr = Symbol('kUseStderr');\n\nconst optionsMap = new SafeWeakMap();\nfunction Console(options /* or: stdout\x2C stderr\x2C ignoreErrors = true */) {\n  // We have to test new.target here to see if this function is called\n  // with new\x2C because we need to define a custom instanceof to accommodate\n  // the global console.\n  if (new.target === undefined) {\n    return ReflectConstruct(Console\x2C arguments);\n  }\n\n  if (!options || typeof options.write === 'function') {\n    options = {\n      stdout: options\x2C\n      stderr: arguments[1]\x2C\n      ignoreErrors: arguments[2]\x2C\n    };\n  }\n\n  const {\n    stdout\x2C\n    stderr = stdout\x2C\n    ignoreErrors = true\x2C\n    colorMode = 'auto'\x2C\n    inspectOptions\x2C\n    groupIndentation\x2C\n  } = options;\n\n  if (!stdout || typeof stdout.write !== 'function') {\n    throw new ERR_CONSOLE_WRITABLE_STREAM('stdout');\n  }\n  if (!stderr || typeof stderr.write !== 'function') {\n    throw new ERR_CONSOLE_WRITABLE_STREAM('stderr');\n  }\n\n  if (typeof colorMode !== 'boolean' && colorMode !== 'auto')\n    throw new ERR_INVALID_ARG_VALUE('colorMode'\x2C colorMode);\n\n  if (groupIndentation !== undefined) {\n    validateInteger(groupIndentation\x2C 'groupIndentation'\x2C\n                    0\x2C kMaxGroupIndentation);\n  }\n\n  if (inspectOptions !== undefined) {\n    validateObject(inspectOptions\x2C 'options.inspectOptions');\n\n    if (inspectOptions.colors !== undefined &&\n        options.colorMode !== undefined) {\n      throw new ERR_INCOMPATIBLE_OPTION_PAIR(\n        'options.inspectOptions.color'\x2C 'colorMode');\n    }\n    optionsMap.set(this\x2C inspectOptions);\n  }\n\n  // Bind the prototype functions to this Console instance\n  ArrayPrototypeForEach(ObjectKeys(Console.prototype)\x2C (key) => {\n    // We have to bind the methods grabbed from the instance instead of from\n    // the prototype so that users extending the Console can override them\n    // from the prototype chain of the subclass.\n    this[key] = FunctionPrototypeBind(this[key]\x2C this);\n    ObjectDefineProperty(this[key]\x2C 'name'\x2C {\n      __proto__: null\x2C\n      value: key\x2C\n    });\n  });\n\n  this[kBindStreamsEager](stdout\x2C stderr);\n  this[kBindProperties](ignoreErrors\x2C colorMode\x2C groupIndentation);\n}\n\nconst consolePropAttributes = {\n  writable: true\x2C\n  enumerable: false\x2C\n  configurable: true\x2C\n};\n\n// Fixup global.console instanceof global.console.Console\nObjectDefineProperty(Console\x2C SymbolHasInstance\x2C {\n  __proto__: null\x2C\n  value(instance) {\n    return instance[kIsConsole];\n  }\x2C\n});\n\nconst kColorInspectOptions = { colors: true };\nconst kNoColorInspectOptions = {};\n\nObjectDefineProperties(Console.prototype\x2C {\n  [kBindStreamsEager]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    // Eager version for the Console constructor\n    value: function(stdout\x2C stderr) {\n      ObjectDefineProperties(this\x2C {\n        '_stdout': { __proto__: null\x2C ...consolePropAttributes\x2C value: stdout }\x2C\n        '_stderr': { __proto__: null\x2C ...consolePropAttributes\x2C value: stderr }\x2C\n      });\n    }\x2C\n  }\x2C\n  [kBindStreamsLazy]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    // Lazily load the stdout and stderr from an object so we don't\n    // create the stdio streams when they are not even accessed\n    value: function(object) {\n      let stdout;\n      let stderr;\n      ObjectDefineProperties(this\x2C {\n        '_stdout': {\n          __proto__: null\x2C\n          enumerable: false\x2C\n          configurable: true\x2C\n          get() {\n            if (!stdout) stdout = object.stdout;\n            return stdout;\n          }\x2C\n          set(value) { stdout = value; }\x2C\n        }\x2C\n        '_stderr': {\n          __proto__: null\x2C\n          enumerable: false\x2C\n          configurable: true\x2C\n          get() {\n            if (!stderr) { stderr = object.stderr; }\n            return stderr;\n          }\x2C\n          set(value) { stderr = value; }\x2C\n        }\x2C\n      });\n    }\x2C\n  }\x2C\n  [kBindProperties]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    value: function(ignoreErrors\x2C colorMode\x2C groupIndentation = 2) {\n      ObjectDefineProperties(this\x2C {\n        '_stdoutErrorHandler': {\n          __proto__: null\x2C\n          ...consolePropAttributes\x2C\n          value: createWriteErrorHandler(this\x2C kUseStdout)\x2C\n        }\x2C\n        '_stderrErrorHandler': {\n          ...consolePropAttributes\x2C\n          __proto__: null\x2C\n          value: createWriteErrorHandler(this\x2C kUseStderr)\x2C\n        }\x2C\n        '_ignoreErrors': {\n          __proto__: null\x2C\n          ...consolePropAttributes\x2C\n          value: Boolean(ignoreErrors)\x2C\n        }\x2C\n        '_times': { __proto__: null\x2C ...consolePropAttributes\x2C value: new SafeMap() }\x2C\n        // Corresponds to https://console.spec.whatwg.org/#count-map\n        [kCounts]: { __proto__: null\x2C ...consolePropAttributes\x2C value: new SafeMap() }\x2C\n        [kColorMode]: { __proto__: null\x2C ...consolePropAttributes\x2C value: colorMode }\x2C\n        [kIsConsole]: { __proto__: null\x2C ...consolePropAttributes\x2C value: true }\x2C\n        [kGroupIndent]: { __proto__: null\x2C ...consolePropAttributes\x2C value: '' }\x2C\n        [kGroupIndentationWidth]: {\n          __proto__: null\x2C\n          ...consolePropAttributes\x2C\n          value: groupIndentation\x2C\n        }\x2C\n        [SymbolToStringTag]: {\n          __proto__: null\x2C\n          writable: false\x2C\n          enumerable: false\x2C\n          configurable: true\x2C\n          value: 'console'\x2C\n        }\x2C\n      });\n    }\x2C\n  }\x2C\n  [kWriteToConsole]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    value: function(streamSymbol\x2C string) {\n      const ignoreErrors = this._ignoreErrors;\n      const groupIndent = this[kGroupIndent];\n\n      const useStdout = streamSymbol === kUseStdout;\n      const stream = useStdout ? this._stdout : this._stderr;\n      const errorHandler = useStdout ?\n        this._stdoutErrorHandler : this._stderrErrorHandler;\n\n      if (groupIndent.length !== 0) {\n        if (StringPrototypeIncludes(string\x2C '\\n')) {\n          string = RegExpPrototypeSymbolReplace(/\\n/g\x2C string\x2C `\\n${groupIndent}`);\n        }\n        string = groupIndent + string;\n      }\n      string += '\\n';\n\n      if (ignoreErrors === false) return stream.write(string);\n\n      // There may be an error occurring synchronously (e.g. for files or TTYs\n      // on POSIX systems) or asynchronously (e.g. pipes on POSIX systems)\x2C so\n      // handle both situations.\n      try {\n        // Add and later remove a noop error handler to catch synchronous\n        // errors.\n        if (stream.listenerCount('error') === 0)\n          stream.once('error'\x2C noop);\n\n        stream.write(string\x2C errorHandler);\n      } catch (e) {\n        // Console is a debugging utility\x2C so it swallowing errors is not\n        // desirable even in edge cases such as low stack space.\n        if (isStackOverflowError(e))\n          throw e;\n        // Sorry\x2C there's no proper way to pass along the error here.\n      } finally {\n        stream.removeListener('error'\x2C noop);\n      }\n    }\x2C\n  }\x2C\n  [kGetInspectOptions]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    value: function(stream) {\n      let color = this[kColorMode];\n      if (color === 'auto') {\n        color = lazyUtilColors().shouldColorize(stream);\n      }\n\n      const options = optionsMap.get(this);\n      if (options) {\n        if (options.colors === undefined) {\n          options.colors = color;\n        }\n        return options;\n      }\n\n      return color ? kColorInspectOptions : kNoColorInspectOptions;\n    }\x2C\n  }\x2C\n  [kFormatForStdout]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    value: function(args) {\n      const opts = this[kGetInspectOptions](this._stdout);\n      ArrayPrototypeUnshift(args\x2C opts);\n      return ReflectApply(formatWithOptions\x2C null\x2C args);\n    }\x2C\n  }\x2C\n  [kFormatForStderr]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    value: function(args) {\n      const opts = this[kGetInspectOptions](this._stderr);\n      ArrayPrototypeUnshift(args\x2C opts);\n      return ReflectApply(formatWithOptions\x2C null\x2C args);\n    }\x2C\n  }\x2C\n});\n\n// Make a function that can serve as the callback passed to `stream.write()`.\nfunction createWriteErrorHandler(instance\x2C streamSymbol) {\n  return (err) => {\n    // This conditional evaluates to true if and only if there was an error\n    // that was not already emitted (which happens when the _write callback\n    // is invoked asynchronously).\n    const stream = streamSymbol === kUseStdout ?\n      instance._stdout : instance._stderr;\n    if (err !== null && !stream._writableState.errorEmitted) {\n      // If there was an error\x2C it will be emitted on `stream` as\n      // an `error` event. Adding a `once` listener will keep that error\n      // from becoming an uncaught exception\x2C but since the handler is\n      // removed after the event\x2C non-console.* writes won't be affected.\n      // we are only adding noop if there is no one else listening for 'error'\n      if (stream.listenerCount('error') === 0) {\n        stream.once('error'\x2C noop);\n      }\n    }\n  };\n}\n\nconst consoleMethods = {\n  log(...args) {\n    this[kWriteToConsole](kUseStdout\x2C this[kFormatForStdout](args));\n  }\x2C\n\n\n  warn(...args) {\n    this[kWriteToConsole](kUseStderr\x2C this[kFormatForStderr](args));\n  }\x2C\n\n\n  dir(object\x2C options) {\n    this[kWriteToConsole](kUseStdout\x2C inspect(object\x2C {\n      customInspect: false\x2C\n      ...this[kGetInspectOptions](this._stdout)\x2C\n      ...options\x2C\n    }));\n  }\x2C\n\n  time(label = 'default') {\n    // Coerces everything other than Symbol to a string\n    label = `${label}`;\n    if (this._times.has(label)) {\n      process.emitWarning(`Label '${label}' already exists for console.time()`);\n      return;\n    }\n    trace(kTraceBegin\x2C kTraceConsoleCategory\x2C `time::${label}`\x2C 0);\n    this._times.set(label\x2C process.hrtime());\n  }\x2C\n\n  timeEnd(label = 'default') {\n    // Coerces everything other than Symbol to a string\n    label = `${label}`;\n    const found = timeLogImpl(this\x2C 'timeEnd'\x2C label);\n    trace(kTraceEnd\x2C kTraceConsoleCategory\x2C `time::${label}`\x2C 0);\n    if (found) {\n      this._times.delete(label);\n    }\n  }\x2C\n\n  timeLog(label = 'default'\x2C ...data) {\n    // Coerces everything other than Symbol to a string\n    label = `${label}`;\n    timeLogImpl(this\x2C 'timeLog'\x2C label\x2C data);\n    trace(kTraceInstant\x2C kTraceConsoleCategory\x2C `time::${label}`\x2C 0);\n  }\x2C\n\n  trace: function trace(...args) {\n    const err = {\n      name: 'Trace'\x2C\n      message: this[kFormatForStderr](args)\x2C\n    };\n    ErrorCaptureStackTrace(err\x2C trace);\n    this.error(err.stack);\n  }\x2C\n\n  assert(expression\x2C ...args) {\n    if (!expression) {\n      args[0] = `Assertion failed${args.length === 0 ? '' : `: ${args[0]}`}`;\n      // The arguments will be formatted in warn() again\n      ReflectApply(this.warn\x2C this\x2C args);\n    }\n  }\x2C\n\n  // Defined by: https://console.spec.whatwg.org/#clear\n  clear() {\n    // It only makes sense to clear if _stdout is a TTY.\n    // Otherwise\x2C do nothing.\n    if (this._stdout.isTTY && process.env.TERM !== 'dumb') {\n      // The require is here intentionally to avoid readline being\n      // required too early when console is first loaded.\n      const {\n        cursorTo\x2C\n        clearScreenDown\x2C\n      } = require('internal/readline/callbacks');\n      cursorTo(this._stdout\x2C 0\x2C 0);\n      clearScreenDown(this._stdout);\n    }\n  }\x2C\n\n  // Defined by: https://console.spec.whatwg.org/#count\n  count(label = 'default') {\n    // Ensures that label is a string\x2C and only things that can be\n    // coerced to strings. e.g. Symbol is not allowed\n    label = `${label}`;\n    const counts = this[kCounts];\n    let count = counts.get(label);\n    if (count === undefined)\n      count = 1;\n    else\n      count++;\n    counts.set(label\x2C count);\n    trace(kTraceCount\x2C kTraceConsoleCategory\x2C `count::${label}`\x2C 0\x2C count);\n    this.log(`${label}: ${count}`);\n  }\x2C\n\n  // Defined by: https://console.spec.whatwg.org/#countreset\n  countReset(label = 'default') {\n    const counts = this[kCounts];\n    if (!counts.has(label)) {\n      process.emitWarning(`Count for '${label}' does not exist`);\n      return;\n    }\n    trace(kTraceCount\x2C kTraceConsoleCategory\x2C `count::${label}`\x2C 0\x2C 0);\n    counts.delete(`${label}`);\n  }\x2C\n\n  group(...data) {\n    if (data.length > 0) {\n      ReflectApply(this.log\x2C this\x2C data);\n    }\n    this[kGroupIndent] +=\n      StringPrototypeRepeat(' '\x2C this[kGroupIndentationWidth]);\n  }\x2C\n\n  groupEnd() {\n    this[kGroupIndent] = StringPrototypeSlice(\n      this[kGroupIndent]\x2C\n      0\x2C\n      this[kGroupIndent].length - this[kGroupIndentationWidth]\x2C\n    );\n  }\x2C\n\n  // https://console.spec.whatwg.org/#table\n  table(tabularData\x2C properties) {\n    if (properties !== undefined)\n      validateArray(properties\x2C 'properties');\n\n    if (tabularData === null || typeof tabularData !== 'object')\n      return this.log(tabularData);\n\n    cliTable ??= require('internal/cli_table');\n    const final = (k\x2C v) => this.log(cliTable(k\x2C v));\n\n    const _inspect = (v) => {\n      const depth = v !== null &&\n                    typeof v === 'object' &&\n                    !isArray(v) &&\n                    ObjectKeys(v).length > 2 ? -1 : 0;\n      const opt = {\n        depth\x2C\n        maxArrayLength: 3\x2C\n        breakLength: Infinity\x2C\n        ...this[kGetInspectOptions](this._stdout)\x2C\n      };\n      return inspect(v\x2C opt);\n    };\n    const getIndexArray = (length) => ArrayFrom(\n      { length }\x2C (_\x2C i) => _inspect(i));\n\n    const mapIter = isMapIterator(tabularData);\n    let isKeyValue = false;\n    let i = 0;\n    if (mapIter) {\n      const res = previewEntries(tabularData\x2C true);\n      tabularData = res[0];\n      isKeyValue = res[1];\n    }\n\n    if (isKeyValue || isMap(tabularData)) {\n      const keys = [];\n      const values = [];\n      let length = 0;\n      if (mapIter) {\n        for (; i < tabularData.length / 2; ++i) {\n          ArrayPrototypePush(keys\x2C _inspect(tabularData[i * 2]));\n          ArrayPrototypePush(values\x2C _inspect(tabularData[i * 2 + 1]));\n          length++;\n        }\n      } else {\n        for (const { 0: k\x2C 1: v } of tabularData) {\n          ArrayPrototypePush(keys\x2C _inspect(k));\n          ArrayPrototypePush(values\x2C _inspect(v));\n          length++;\n        }\n      }\n      return final([\n        iterKey\x2C keyKey\x2C valuesKey\x2C\n      ]\x2C [\n        getIndexArray(length)\x2C\n        keys\x2C\n        values\x2C\n      ]);\n    }\n\n    const setIter = isSetIterator(tabularData);\n    if (setIter)\n      tabularData = previewEntries(tabularData);\n\n    const setlike = setIter || mapIter || isSet(tabularData);\n    if (setlike) {\n      const values = [];\n      let length = 0;\n      for (const v of tabularData) {\n        ArrayPrototypePush(values\x2C _inspect(v));\n        length++;\n      }\n      return final([iterKey\x2C valuesKey]\x2C [getIndexArray(length)\x2C values]);\n    }\n\n    const map = { __proto__: null };\n    let hasPrimitives = false;\n    const valuesKeyArray = [];\n    const indexKeyArray = ObjectKeys(tabularData);\n\n    for (; i < indexKeyArray.length; i++) {\n      const item = tabularData[indexKeyArray[i]];\n      const primitive = item === null ||\n          (typeof item !== 'function' && typeof item !== 'object');\n      if (properties === undefined && primitive) {\n        hasPrimitives = true;\n        valuesKeyArray[i] = _inspect(item);\n      } else {\n        const keys = properties || ObjectKeys(item);\n        for (const key of keys) {\n          map[key] ??= [];\n          if ((primitive && properties) ||\n               !ObjectPrototypeHasOwnProperty(item\x2C key))\n            map[key][i] = '';\n          else\n            map[key][i] = _inspect(item[key]);\n        }\n      }\n    }\n\n    const keys = ObjectKeys(map);\n    const values = ObjectValues(map);\n    if (hasPrimitives) {\n      ArrayPrototypePush(keys\x2C valuesKey);\n      ArrayPrototypePush(values\x2C valuesKeyArray);\n    }\n    ArrayPrototypeUnshift(keys\x2C indexKey);\n    ArrayPrototypeUnshift(values\x2C indexKeyArray);\n\n    return final(keys\x2C values);\n  }\x2C\n};\n\n// Returns true if label was found\nfunction timeLogImpl(self\x2C name\x2C label\x2C data) {\n  const time = self._times.get(label);\n  if (time === undefined) {\n    process.emitWarning(`No such label '${label}' for console.${name}()`);\n    return false;\n  }\n  const duration = process.hrtime(time);\n  const ms = duration[0] * 1000 + duration[1] / 1e6;\n\n  const formatted = formatTime(ms);\n\n  if (data === undefined) {\n    self.log('%s: %s'\x2C label\x2C formatted);\n  } else {\n    self.log('%s: %s'\x2C label\x2C formatted\x2C ...new SafeArrayIterator(data));\n  }\n  return true;\n}\n\nfunction pad(value) {\n  return StringPrototypePadStart(`${value}`\x2C 2\x2C '0');\n}\n\nfunction formatTime(ms) {\n  let hours = 0;\n  let minutes = 0;\n  let seconds = 0;\n\n  if (ms >= kSecond) {\n    if (ms >= kMinute) {\n      if (ms >= kHour) {\n        hours = MathFloor(ms / kHour);\n        ms = ms % kHour;\n      }\n      minutes = MathFloor(ms / kMinute);\n      ms = ms % kMinute;\n    }\n    seconds = ms / kSecond;\n  }\n\n  if (hours !== 0 || minutes !== 0) {\n    ({ 0: seconds\x2C 1: ms } = StringPrototypeSplit(\n      NumberPrototypeToFixed(seconds\x2C 3)\x2C\n      '.'\x2C\n    ));\n    const res = hours !== 0 ? `${hours}:${pad(minutes)}` : minutes;\n    return `${res}:${pad(seconds)}.${ms} (${hours !== 0 ? 'h:m' : ''}m:ss.mmm)`;\n  }\n\n  if (seconds !== 0) {\n    return `${NumberPrototypeToFixed(seconds\x2C 3)}s`;\n  }\n\n  return `${Number(NumberPrototypeToFixed(ms\x2C 3))}ms`;\n}\n\nconst keyKey = 'Key';\nconst valuesKey = 'Values';\nconst indexKey = '(index)';\nconst iterKey = '(iteration index)';\n\nconst isArray = (v) => ArrayIsArray(v) || isTypedArray(v) || isBuffer(v);\n\nfunction noop() {}\n\nfor (const method of ReflectOwnKeys(consoleMethods))\n  Console.prototype[method] = consoleMethods[method];\n\nConsole.prototype.debug = Console.prototype.log;\nConsole.prototype.info = Console.prototype.log;\nConsole.prototype.dirxml = Console.prototype.log;\nConsole.prototype.error = Console.prototype.warn;\nConsole.prototype.groupCollapsed = Console.prototype.group;\n\nfunction initializeGlobalConsole(globalConsole) {\n  globalConsole[kBindStreamsLazy](process);\n  globalConsole[kBindProperties](true\x2C 'auto');\n\n  const {\n    namespace: {\n      addSerializeCallback\x2C\n      isBuildingSnapshot\x2C\n    }\x2C\n  } = require('internal/v8/startup_snapshot');\n\n  if (!internalBinding('config').hasInspector || !isBuildingSnapshot()) {\n    return;\n  }\n  const { console: consoleFromVM } = internalBinding('inspector');\n  const nodeConsoleKeys = ObjectKeys(Console.prototype);\n  const vmConsoleKeys = ObjectKeys(consoleFromVM);\n  const originalKeys = new SafeSet(vmConsoleKeys.concat(nodeConsoleKeys));\n  const inspectorConsoleKeys = new SafeSet();\n  for (const key of ObjectKeys(globalConsole)) {\n    if (!originalKeys.has(key)) {\n      inspectorConsoleKeys.add(key);\n    }\n  }\n  // During deserialization these should be reinstalled to console by\n  // V8 when the inspector client is created.\n  addSerializeCallback(() => {\n    for (const key of inspectorConsoleKeys) {\n      globalConsole[key] = undefined;\n    }\n  });\n}\n\nmodule.exports = {\n  Console\x2C\n  kBindStreamsLazy\x2C\n  kBindProperties\x2C\n  initializeGlobalConsole\x2C\n  formatTime\x2C // exported for tests\n};\n
code-source-info,0x31e6f6b463de,44,20457,21464,C0O20457C12O20477C19O20491C21O20490C30O20508C35O20521C42O20535C44O20534C53O20551C59O20662C67O20662C72O20593C77O20601C82O20629C87O20706C95O20711C100O20736C106O20754C111O20782C112O20789C113O20831C121O20831C126O20813C131O20887C143O20906C148O20887C153O20942C160O20942C165O20992C172O21018C177O21018C185O20992C191O21075C198O21075C203O21075C205O21110C215O21110C237O21103C267O21103C270O21161C276O21161C283O21179C287O21200C293O21200C298O21092C365O21338C370O21338C375O21463,,
tick,0x7ff8092c91c3,38841,0,0x0,3,0x10c9f09d0,0x31e6f6b4155b,0x31e63e0bd336,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,38877,0x31e6f6b480b6,94,value node:internal/console/constructor:205:20,0x31e647c62f70,~
code-source-info,0x31e6f6b480b6,44,5840,6477,C0O5840C15O5861C16O5861C18O5879C19O5879C21O5893C33O5943C38O6041C46O6148C60O6210C65O6308C73O6419C87O5893C93O6476,,
code-creation,JS,10,38988,0x31e6f6b4873e,414,value node:internal/console/constructor:235:20,0x31e647c63030,~
code-source-info,0x31e6f6b4873e,44,6577,7977,C17O6633C27O6695C34O6737C52O6807C55O6777C73O6877C86O6974C89O6944C104O7023C111O7065C126O7105C129O7105C144O7157C151O7179C166O7213C169O7209C187O7304C191O7314C198O7336C213O7370C216O7366C235O7392C239O7405C246O7427C261O7457C275O7479C279O7492C286O7514C300O7544C314O7561C318O7576C325O7598C340O7628C354O7643C358O7668C365O7710C380O7750C394O7788C398O7808C407O6633C413O7976,,
code-creation,JS,10,39057,0x31e6f6b48cbe,18,createWriteErrorHandler node:internal/console/constructor:357:33,0x31e647c632d8,~
code-source-info,0x31e6f6b48cbe,44,10694,11551,C0O10694C13O10723C17O11549,,
code-creation,JS,10,39157,0x31e6f6b49256,63,addReadOnlyProcessAlias node:internal/process/pre_execution:269:33,0x31e647c797b8,~
code-source-info,0x31e6f6b49256,67,8712,8961,C16O8764C21O8764C26O8790C28O8807C36O8837C43O8923C49O8941C56O8807C62O8960,,
code-creation,JS,10,39202,0x31e6f6b493f6,82,getOptionValue node:internal/options:44:24,0x31e647c44978,~
code-source-info,0x31e6f6b493f6,17,985,1228,C0O1018C3O1018C7O1063C15O1063C22O1113C30O1135C38O1135C43O1122C47O1113C53O1150C55O1175C60O1181C61O1203C66O1203C74O1218C81O1226,,
code-creation,JS,10,39238,0x31e6f6b4954e,33,getCLIOptionsFromBinding node:internal/options:18:34,0x31e647c44760,~
code-source-info,0x31e6f6b4954e,17,497,598,C0O504C6O527C11O554C15O539C28O578C32O596,,
tick,0x10c8cb58e,39379,1,0x10c261f50,5,0x10c9f0700,0x31e6f6b49559,0x31e6f6b493f9,0x31e6f6b4926b,0x31e6f6b41568,0x31e63e0bd336,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,39518,0x31e6f6b49bbe,46,setupTraceCategoryState node:internal/process/pre_execution:481:33,0x31e647c79c00,~
code-source-info,0x31e6f6b49bbe,67,14631,14858,C0O14673C6O14673C11O14646C16O14745C22O14745C27O14716C32O14787C35O14812C40O14787C45O14857,,
code-creation,JS,10,39593,0x31e6f6b49d56,77,toggleTraceCategoryState node:internal/process/per_thread:409:34,0x31e647c56fb0,~
script-source,27,node:internal/process/per_thread,'use strict';\n\n// This files contains process bootstrappers that can be\n// run when setting up each thread\x2C including the main\n// thread and the worker threads.\n\nconst {\n  ArrayPrototypeEvery\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSplice\x2C\n  BigUint64Array\x2C\n  Float64Array\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  ObjectFreeze\x2C\n  ObjectDefineProperty\x2C\n  ReflectApply\x2C\n  RegExpPrototypeExec\x2C\n  SafeArrayIterator\x2C\n  Set\x2C\n  SetPrototypeEntries\x2C\n  SetPrototypeValues\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n  Symbol\x2C\n  SymbolIterator\x2C\n} = primordials;\n\nconst {\n  errnoException\x2C\n  codes: {\n    ERR_ASSERTION\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNKNOWN_SIGNAL\x2C\n  }\x2C\n} = require('internal/errors');\nconst format = require('internal/util/inspect').format;\nconst {\n  validateArray\x2C\n  validateNumber\x2C\n  validateObject\x2C\n} = require('internal/validators');\nconst constants = internalBinding('constants').os.signals;\n\nconst kInternal = Symbol('internal properties');\n\nfunction assert(x\x2C msg) {\n  if (!x) throw new ERR_ASSERTION(msg || 'assertion error');\n}\nconst { exitCodes: { kNoFailure } } = internalBinding('errors');\n\nconst binding = internalBinding('process_methods');\n\nlet hrValues;\nlet hrBigintValues;\n\nfunction refreshHrtimeBuffer() {\n  // The 3 entries filled in by the original process.hrtime contains\n  // the upper/lower 32 bits of the second part of the value\x2C\n  // and the remaining nanoseconds of the value.\n  hrValues = binding.hrtimeBuffer;\n  // Use a BigUint64Array in the closure because this is actually a bit\n  // faster than simply returning a BigInt from C++ in V8 7.1.\n  hrBigintValues = new BigUint64Array(binding.hrtimeBuffer.buffer\x2C 0\x2C 1);\n}\n\n// Create the buffers.\nrefreshHrtimeBuffer();\n\nfunction hrtime(time) {\n  binding.hrtime();\n\n  if (time !== undefined) {\n    validateArray(time\x2C 'time');\n    if (time.length !== 2) {\n      throw new ERR_OUT_OF_RANGE('time'\x2C 2\x2C time.length);\n    }\n\n    const sec = (hrValues[0] * 0x100000000 + hrValues[1]) - time[0];\n    const nsec = hrValues[2] - time[1];\n    const needsBorrow = nsec < 0;\n    return [needsBorrow ? sec - 1 : sec\x2C needsBorrow ? nsec + 1e9 : nsec];\n  }\n\n  return [\n    hrValues[0] * 0x100000000 + hrValues[1]\x2C\n    hrValues[2]\x2C\n  ];\n}\n\nfunction hrtimeBigInt() {\n  binding.hrtimeBigInt();\n  return hrBigintValues[0];\n}\n\nfunction nop() {}\n\n// The execution of this function itself should not cause any side effects.\nfunction wrapProcessMethods(binding) {\n  const {\n    cpuUsage: _cpuUsage\x2C\n    memoryUsage: _memoryUsage\x2C\n    rss\x2C\n    resourceUsage: _resourceUsage\x2C\n  } = binding;\n\n  function _rawDebug(...args) {\n    binding._rawDebug(ReflectApply(format\x2C null\x2C args));\n  }\n\n  // Create the argument array that will be passed to the native function.\n  const cpuValues = new Float64Array(2);\n\n  // Replace the native function with the JS version that calls the native\n  // function.\n  function cpuUsage(prevValue) {\n    // If a previous value was passed in\x2C ensure it has the correct shape.\n    if (prevValue) {\n      if (!previousValueIsValid(prevValue.user)) {\n        validateObject(prevValue\x2C 'prevValue');\n\n        validateNumber(prevValue.user\x2C 'prevValue.user');\n        throw new ERR_INVALID_ARG_VALUE.RangeError('prevValue.user'\x2C\n                                                   prevValue.user);\n      }\n\n      if (!previousValueIsValid(prevValue.system)) {\n        validateNumber(prevValue.system\x2C 'prevValue.system');\n        throw new ERR_INVALID_ARG_VALUE.RangeError('prevValue.system'\x2C\n                                                   prevValue.system);\n      }\n    }\n\n    // Call the native function to get the current values.\n    _cpuUsage(cpuValues);\n\n    // If a previous value was passed in\x2C return diff of current from previous.\n    if (prevValue) {\n      return {\n        user: cpuValues[0] - prevValue.user\x2C\n        system: cpuValues[1] - prevValue.system\x2C\n      };\n    }\n\n    // If no previous value passed in\x2C return current value.\n    return {\n      user: cpuValues[0]\x2C\n      system: cpuValues[1]\x2C\n    };\n  }\n\n  // Ensure that a previously passed in value is valid. Currently\x2C the native\n  // implementation always returns numbers <= Number.MAX_SAFE_INTEGER.\n  function previousValueIsValid(num) {\n    return typeof num === 'number' &&\n        num <= NumberMAX_SAFE_INTEGER &&\n        num >= 0;\n  }\n\n  const memValues = new Float64Array(5);\n  function memoryUsage() {\n    _memoryUsage(memValues);\n    return {\n      rss: memValues[0]\x2C\n      heapTotal: memValues[1]\x2C\n      heapUsed: memValues[2]\x2C\n      external: memValues[3]\x2C\n      arrayBuffers: memValues[4]\x2C\n    };\n  }\n\n  memoryUsage.rss = rss;\n\n  function exit(code) {\n    const {\n      handleProcessExit\x2C\n    } = require('internal/modules/esm/handle_process_exit');\n    process.off('exit'\x2C handleProcessExit);\n\n    if (arguments.length !== 0) {\n      process.exitCode = code;\n    }\n\n    if (!process._exiting) {\n      process._exiting = true;\n      process.emit('exit'\x2C process.exitCode || kNoFailure);\n    }\n    // FIXME(joyeecheung): This is an undocumented API that gets monkey-patched\n    // in the user land. Either document it\x2C or deprecate it in favor of a\n    // better public alternative.\n    process.reallyExit(process.exitCode || kNoFailure);\n\n    // If this is a worker\x2C v8::Isolate::TerminateExecution() is called above.\n    // That function spoofs the stack pointer to cause the stack guard\n    // check to throw the termination exception. Because v8 performs\n    // stack guard check upon every function call\x2C we give it a chance.\n    //\n    // Without this\x2C user code after `process.exit()` would take effect.\n    // test/parallel/test-worker-voluntarily-exit-followed-by-addition.js\n    // test/parallel/test-worker-voluntarily-exit-followed-by-throw.js\n    nop();\n  }\n\n  function kill(pid\x2C sig) {\n    let err;\n\n    // eslint-disable-next-line eqeqeq\n    if (pid != (pid | 0)) {\n      throw new ERR_INVALID_ARG_TYPE('pid'\x2C 'number'\x2C pid);\n    }\n\n    // Preserve null signal\n    if (sig === (sig | 0)) {\n      // XXX(joyeecheung): we have to use process._kill here because\n      // it's monkey-patched by tests.\n      err = process._kill(pid\x2C sig);\n    } else {\n      sig = sig || 'SIGTERM';\n      if (constants[sig]) {\n        err = process._kill(pid\x2C constants[sig]);\n      } else {\n        throw new ERR_UNKNOWN_SIGNAL(sig);\n      }\n    }\n\n    if (err)\n      throw errnoException(err\x2C 'kill');\n\n    return true;\n  }\n\n  const resourceValues = new Float64Array(16);\n  function resourceUsage() {\n    _resourceUsage(resourceValues);\n    return {\n      userCPUTime: resourceValues[0]\x2C\n      systemCPUTime: resourceValues[1]\x2C\n      maxRSS: resourceValues[2]\x2C\n      sharedMemorySize: resourceValues[3]\x2C\n      unsharedDataSize: resourceValues[4]\x2C\n      unsharedStackSize: resourceValues[5]\x2C\n      minorPageFault: resourceValues[6]\x2C\n      majorPageFault: resourceValues[7]\x2C\n      swappedOut: resourceValues[8]\x2C\n      fsRead: resourceValues[9]\x2C\n      fsWrite: resourceValues[10]\x2C\n      ipcSent: resourceValues[11]\x2C\n      ipcReceived: resourceValues[12]\x2C\n      signalsCount: resourceValues[13]\x2C\n      voluntaryContextSwitches: resourceValues[14]\x2C\n      involuntaryContextSwitches: resourceValues[15]\x2C\n    };\n  }\n\n\n  return {\n    _rawDebug\x2C\n    cpuUsage\x2C\n    resourceUsage\x2C\n    memoryUsage\x2C\n    kill\x2C\n    exit\x2C\n  };\n}\n\nconst replaceUnderscoresRegex = /_/g;\nconst leadingDashesRegex = /^--?/;\nconst trailingValuesRegex = /=.*$/;\n\n// This builds the initial process.allowedNodeEnvironmentFlags\n// from data in the config binding.\nfunction buildAllowedFlags() {\n  const {\n    envSettings: { kAllowedInEnvvar }\x2C\n    types: { kBoolean }\x2C\n  } = internalBinding('options');\n  const { options\x2C aliases } = require('internal/options');\n\n  const allowedNodeEnvironmentFlags = [];\n  for (const { 0: name\x2C 1: info } of options) {\n    if (info.envVarSettings === kAllowedInEnvvar) {\n      ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C name);\n      if (info.type === kBoolean) {\n        const negatedName = `--no-${name.slice(2)}`;\n        ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C negatedName);\n      }\n    }\n  }\n\n  function isAccepted(to) {\n    if (!StringPrototypeStartsWith(to\x2C '-') || to === '--') return true;\n    const recursiveExpansion = aliases.get(to);\n    if (recursiveExpansion) {\n      if (recursiveExpansion[0] === to)\n        ArrayPrototypeSplice(recursiveExpansion\x2C 0\x2C 1);\n      return ArrayPrototypeEvery(recursiveExpansion\x2C isAccepted);\n    }\n    return options.get(to).envVarSettings === kAllowedInEnvvar;\n  }\n  for (const { 0: from\x2C 1: expansion } of aliases) {\n    if (ArrayPrototypeEvery(expansion\x2C isAccepted)) {\n      let canonical = from;\n      if (StringPrototypeEndsWith(canonical\x2C '='))\n        canonical = StringPrototypeSlice(canonical\x2C 0\x2C canonical.length - 1);\n      if (StringPrototypeEndsWith(canonical\x2C ' <arg>'))\n        canonical = StringPrototypeSlice(canonical\x2C 0\x2C canonical.length - 4);\n      ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C canonical);\n    }\n  }\n\n  const trimLeadingDashes =\n    (flag) => StringPrototypeReplace(flag\x2C leadingDashesRegex\x2C '');\n\n  // Save these for comparison against flags provided to\n  // process.allowedNodeEnvironmentFlags.has() which lack leading dashes.\n  const nodeFlags = ArrayPrototypeMap(allowedNodeEnvironmentFlags\x2C\n                                      trimLeadingDashes);\n\n  class NodeEnvironmentFlagsSet extends Set {\n    constructor(array) {\n      super();\n      this[kInternal] = { array };\n    }\n\n    add() {\n      // No-op\x2C `Set` API compatible\n      return this;\n    }\n\n    delete() {\n      // No-op\x2C `Set` API compatible\n      return false;\n    }\n\n    clear() {\n      // No-op\x2C `Set` API compatible\n    }\n\n    has(key) {\n      // This will return `true` based on various possible\n      // permutations of a flag\x2C including present/missing leading\n      // dash(es) and/or underscores-for-dashes.\n      // Strips any values after `=`\x2C inclusive.\n      // TODO(addaleax): It might be more flexible to run the option parser\n      // on a dummy option set and see whether it rejects the argument or\n      // not.\n      if (typeof key === 'string') {\n        key = StringPrototypeReplace(key\x2C replaceUnderscoresRegex\x2C '-');\n        if (RegExpPrototypeExec(leadingDashesRegex\x2C key) !== null) {\n          key = StringPrototypeReplace(key\x2C trailingValuesRegex\x2C '');\n          return ArrayPrototypeIncludes(this[kInternal].array\x2C key);\n        }\n        return ArrayPrototypeIncludes(nodeFlags\x2C key);\n      }\n      return false;\n    }\n\n    entries() {\n      this[kInternal].set ??=\n        new Set(new SafeArrayIterator(this[kInternal].array));\n      return SetPrototypeEntries(this[kInternal].set);\n    }\n\n    forEach(callback\x2C thisArg = undefined) {\n      ArrayPrototypeForEach(\n        this[kInternal].array\x2C\n        (v) => ReflectApply(callback\x2C thisArg\x2C [v\x2C v\x2C this])\x2C\n      );\n    }\n\n    get size() {\n      return this[kInternal].array.length;\n    }\n\n    values() {\n      this[kInternal].set ??=\n        new Set(new SafeArrayIterator(this[kInternal].array));\n      return SetPrototypeValues(this[kInternal].set);\n    }\n  }\n  const flagSetValues = NodeEnvironmentFlagsSet.prototype.values;\n  ObjectDefineProperty(NodeEnvironmentFlagsSet.prototype\x2C SymbolIterator\x2C {\n    __proto__: null\x2C\n    value: flagSetValues\x2C\n  });\n  ObjectDefineProperty(NodeEnvironmentFlagsSet.prototype\x2C 'keys'\x2C {\n    __proto__: null\x2C\n    value: flagSetValues\x2C\n  });\n\n  ObjectFreeze(NodeEnvironmentFlagsSet.prototype.constructor);\n  ObjectFreeze(NodeEnvironmentFlagsSet.prototype);\n\n  return ObjectFreeze(new NodeEnvironmentFlagsSet(\n    allowedNodeEnvironmentFlags\x2C\n  ));\n}\n\n// Lazy load internal/trace_events_async_hooks only if the async_hooks\n// trace event category is enabled.\nlet traceEventsAsyncHook;\n// Dynamically enable/disable the traceEventsAsyncHook\nfunction toggleTraceCategoryState(asyncHooksEnabled) {\n  if (asyncHooksEnabled) {\n    if (!traceEventsAsyncHook) {\n      traceEventsAsyncHook =\n        require('internal/trace_events_async_hooks').createHook();\n    }\n    traceEventsAsyncHook.enable();\n  } else if (traceEventsAsyncHook) {\n    traceEventsAsyncHook.disable();\n  }\n}\n\nmodule.exports = {\n  toggleTraceCategoryState\x2C\n  assert\x2C\n  buildAllowedFlags\x2C\n  wrapProcessMethods\x2C\n  hrtime\x2C\n  hrtimeBigInt\x2C\n  refreshHrtimeBuffer\x2C\n};\n
code-source-info,0x31e6f6b49d56,27,11988,12285,C0O12012C4O12041C10O12076C16O12107C21O12151C26O12152C33O12097C39O12176C44O12197C49O12197C55O12216C61O12248C66O12269C71O12269C76O12284,,
code-creation,JS,10,40316,0x31e6f6b4ac7e,62,setupInspectorHooks node:internal/process/pre_execution:487:29,0x31e647c79c50,~
code-source-info,0x31e6f6b4ac7e,67,14888,15442,C0O15231C6O15235C11O15260C17O15326C23O15326C28O15295C33O15309C38O15372C44O15372C49O15400C54O15401C61O15441,,
code-creation,JS,10,40371,0x31e6f6b4af06,126,setupWarningHandler node:internal/process/pre_execution:282:29,0x31e647c79808,~
code-source-info,0x31e6f6b4af06,67,8991,9483,C0O8991C11O9054C19O9054C24O9010C30O9025C36O9093C46O9097C57O9141C62O9145C69O9162C74O9177C79O9185C90O9185C96O9312C103O9316C108O9346C120O9346C125O9482,,
code-creation,JS,10,40466,0x31e6f6b4b566,236,setupUndici node:internal/process/pre_execution:304:21,0x31e647c79858,~
code-source-info,0x31e6f6b4b566,67,9578,10938,C0O9578C19O9585C26O9589C30O9609C36O9634C37O9641C38O9653C39O9653C41O10057C51O10062C62O10271C73O10287C82O10271C87O10321C98O10344C109O10374C120O10416C131O10457C142O10499C150O10321C155O10614C163O10614C168O10645C178O10646C183O10789C193O10793C199O10843C210O10866C221O10897C229O10843C235O10937,,
code-creation,JS,10,40512,0x31e6f6b4b81e,28,getEmbedderOptions node:internal/options:32:28,0x31e647c448d8,~
code-source-info,0x31e6f6b4b81e,17,760,877,C0O767C6O795C11O813C17O811C23O852C27O875,,
code-creation,JS,10,40570,0x31e6f6b4bd9e,33,lazyInterface node:internal/process/pre_execution:319:25,0x31e6f6b4b2f0,~
code-source-info,0x31e6f6b4bd9e,67,9834,10053,C0O9834C9O9847C14O9913C22O9971C32O10049,,
tick,0x10c3ed4a2,40650,0,0x0,2,0x10c9f09d0,0x31e63e0bd356,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,40679,0x31e6f6b4c41e,174,setupWebCrypto node:internal/process/pre_execution:362:24,0x31e647c79908,~
code-source-info,0x31e6f6b4c41e,67,11065,11994,C0O11072C5O11076C9O11096C17O11123C23O11123C29O11183C30O11190C31O11198C37O11202C42O11227C48O11246C55O11284C73O11246C78O11557C85O11585C96O11557C103O11695C110O11716C123O11785C154O11785C167O11695C173O11993,,
new,MemoryChunk,0x31e6f25c0000,262144
new,MemoryChunk,0x112580000,262144
code-creation,JS,11,40935,0x112583040,2532,defineLazyProperties node:internal/util:600:30,0x31e647c43210,^
script-source,16,node:internal/util,'use strict';\n\nconst {\n  ArrayBufferPrototypeGetByteLength\x2C\n  ArrayFrom\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSort\x2C\n  Error\x2C\n  FunctionPrototypeCall\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyDescriptors\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectFreeze\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  ObjectValues\x2C\n  Promise\x2C\n  ReflectApply\x2C\n  ReflectConstruct\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeGetDotAll\x2C\n  RegExpPrototypeGetGlobal\x2C\n  RegExpPrototypeGetHasIndices\x2C\n  RegExpPrototypeGetIgnoreCase\x2C\n  RegExpPrototypeGetMultiline\x2C\n  RegExpPrototypeGetSticky\x2C\n  RegExpPrototypeGetUnicode\x2C\n  RegExpPrototypeGetSource\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  SafeWeakMap\x2C\n  SafeWeakRef\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeToUpperCase\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  SymbolReplace\x2C\n  SymbolSplit\x2C\n} = primordials;\n\nconst {\n  hideStackFrames\x2C\n  codes: {\n    ERR_NO_CRYPTO\x2C\n    ERR_UNKNOWN_SIGNAL\x2C\n  }\x2C\n  uvErrmapGet\x2C\n  overrideStackTrace\x2C\n} = require('internal/errors');\nconst { signals } = internalBinding('constants').os;\nconst {\n  isArrayBufferDetached: _isArrayBufferDetached\x2C\n  guessHandleType: _guessHandleType\x2C\n  privateSymbols: {\n    arrow_message_private_symbol\x2C\n    decorated_private_symbol\x2C\n  }\x2C\n  sleep: _sleep\x2C\n  toUSVString: _toUSVString\x2C\n} = internalBinding('util');\nconst { isNativeError } = internalBinding('types');\nconst { getOptionValue } = require('internal/options');\n\nconst noCrypto = !process.versions.openssl;\n\nconst experimentalWarnings = new SafeSet();\n\nconst colorRegExp = /\\u001b\\[\\d\\d?m/g; // eslint-disable-line no-control-regex\n\nconst unpairedSurrogateRe =\n  /(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])/;\nfunction toUSVString(val) {\n  const str = `${val}`;\n  // As of V8 5.5\x2C `str.search()` (and `unpairedSurrogateRe[@@search]()`) are\n  // slower than `unpairedSurrogateRe.exec()`.\n  const match = RegExpPrototypeExec(unpairedSurrogateRe\x2C str);\n  if (!match)\n    return str;\n  return _toUSVString(str\x2C match.index);\n}\n\nlet uvBinding;\n\nfunction lazyUv() {\n  uvBinding ??= internalBinding('uv');\n  return uvBinding;\n}\n\nfunction removeColors(str) {\n  return StringPrototypeReplace(str\x2C colorRegExp\x2C '');\n}\n\nfunction isError(e) {\n  // An error could be an instance of Error while not being a native error\n  // or could be from a different realm and not be instance of Error but still\n  // be a native error.\n  return isNativeError(e) || e instanceof Error;\n}\n\n// Keep a list of deprecation codes that have been warned on so we only warn on\n// each one once.\nconst codesWarned = new SafeSet();\n\nlet validateString;\n\nfunction getDeprecationWarningEmitter(\n  code\x2C msg\x2C deprecated\x2C useEmitSync\x2C\n  shouldEmitWarning = () => true\x2C\n) {\n  let warned = false;\n  return function() {\n    if (!warned && shouldEmitWarning()) {\n      warned = true;\n      if (code !== undefined) {\n        if (!codesWarned.has(code)) {\n          const emitWarning = useEmitSync ?\n            require('internal/process/warning').emitWarningSync :\n            process.emitWarning;\n          emitWarning(msg\x2C 'DeprecationWarning'\x2C code\x2C deprecated);\n          codesWarned.add(code);\n        }\n      } else {\n        process.emitWarning(msg\x2C 'DeprecationWarning'\x2C deprecated);\n      }\n    }\n  };\n}\n\nfunction isPendingDeprecation() {\n  return getOptionValue('--pending-deprecation') &&\n    !getOptionValue('--no-deprecation');\n}\n\n// Internal deprecator for pending --pending-deprecation. This can be invoked\n// at snapshot building time as the warning permission is only queried at\n// run time.\nfunction pendingDeprecate(fn\x2C msg\x2C code) {\n  const emitDeprecationWarning = getDeprecationWarningEmitter(\n    code\x2C msg\x2C deprecated\x2C false\x2C isPendingDeprecation\x2C\n  );\n  function deprecated(...args) {\n    emitDeprecationWarning();\n    return ReflectApply(fn\x2C this\x2C args);\n  }\n  return deprecated;\n}\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set\x2C then it is a no-op.\nfunction deprecate(fn\x2C msg\x2C code\x2C useEmitSync) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Lazy-load to avoid a circular dependency.\n  if (validateString === undefined)\n    ({ validateString } = require('internal/validators'));\n\n  if (code !== undefined)\n    validateString(code\x2C 'code');\n\n  const emitDeprecationWarning = getDeprecationWarningEmitter(\n    code\x2C msg\x2C deprecated\x2C useEmitSync\x2C\n  );\n\n  function deprecated(...args) {\n    emitDeprecationWarning();\n    if (new.target) {\n      return ReflectConstruct(fn\x2C args\x2C new.target);\n    }\n    return ReflectApply(fn\x2C this\x2C args);\n  }\n\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n  ObjectSetPrototypeOf(deprecated\x2C fn);\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype\x2C as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nfunction decorateErrorStack(err) {\n  if (!(isError(err) && err.stack) || err[decorated_private_symbol])\n    return;\n\n  const arrow = err[arrow_message_private_symbol];\n\n  if (arrow) {\n    err.stack = arrow + err.stack;\n    err[decorated_private_symbol] = true;\n  }\n}\n\nfunction assertCrypto() {\n  if (noCrypto)\n    throw new ERR_NO_CRYPTO();\n}\n\n// Return undefined if there is no match.\n// Move the "slow cases" to a separate function to make sure this function gets\n// inlined properly. That prioritizes the common case.\nfunction normalizeEncoding(enc) {\n  if (enc == null || enc === 'utf8' || enc === 'utf-8') return 'utf8';\n  return slowCases(enc);\n}\n\nfunction slowCases(enc) {\n  switch (enc.length) {\n    case 4:\n      if (enc === 'UTF8') return 'utf8';\n      if (enc === 'ucs2' || enc === 'UCS2') return 'utf16le';\n      enc = StringPrototypeToLowerCase(enc);\n      if (enc === 'utf8') return 'utf8';\n      if (enc === 'ucs2') return 'utf16le';\n      break;\n    case 3:\n      if (enc === 'hex' || enc === 'HEX' ||\n      StringPrototypeToLowerCase(enc) === 'hex')\n        return 'hex';\n      break;\n    case 5:\n      if (enc === 'ascii') return 'ascii';\n      if (enc === 'ucs-2') return 'utf16le';\n      if (enc === 'UTF-8') return 'utf8';\n      if (enc === 'ASCII') return 'ascii';\n      if (enc === 'UCS-2') return 'utf16le';\n      enc = StringPrototypeToLowerCase(enc);\n      if (enc === 'utf-8') return 'utf8';\n      if (enc === 'ascii') return 'ascii';\n      if (enc === 'ucs-2') return 'utf16le';\n      break;\n    case 6:\n      if (enc === 'base64') return 'base64';\n      if (enc === 'latin1' || enc === 'binary') return 'latin1';\n      if (enc === 'BASE64') return 'base64';\n      if (enc === 'LATIN1' || enc === 'BINARY') return 'latin1';\n      enc = StringPrototypeToLowerCase(enc);\n      if (enc === 'base64') return 'base64';\n      if (enc === 'latin1' || enc === 'binary') return 'latin1';\n      break;\n    case 7:\n      if (enc === 'utf16le' || enc === 'UTF16LE' ||\n      StringPrototypeToLowerCase(enc) === 'utf16le')\n        return 'utf16le';\n      break;\n    case 8:\n      if (enc === 'utf-16le' || enc === 'UTF-16LE' ||\n      StringPrototypeToLowerCase(enc) === 'utf-16le')\n        return 'utf16le';\n      break;\n    case 9:\n      if (enc === 'base64url' || enc === 'BASE64URL' ||\n      StringPrototypeToLowerCase(enc) === 'base64url')\n        return 'base64url';\n      break;\n    default:\n      if (enc === '') return 'utf8';\n  }\n}\n\nfunction emitExperimentalWarning(feature) {\n  if (experimentalWarnings.has(feature)) return;\n  const msg = `${feature} is an experimental feature and might change at any time`;\n  experimentalWarnings.add(feature);\n  process.emitWarning(msg\x2C 'ExperimentalWarning');\n}\n\nfunction filterDuplicateStrings(items\x2C low) {\n  const map = new SafeMap();\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    const key = StringPrototypeToLowerCase(item);\n    if (low) {\n      map.set(key\x2C key);\n    } else {\n      map.set(key\x2C item);\n    }\n  }\n  return ArrayPrototypeSort(ArrayFrom(map.values()));\n}\n\nfunction cachedResult(fn) {\n  let result;\n  return () => {\n    if (result === undefined)\n      result = fn();\n    return ArrayPrototypeSlice(result);\n  };\n}\n\n// Useful for Wrapping an ES6 Class with a constructor Function that\n// does not require the new keyword. For instance:\n//   class A { constructor(x) {this.x = x;}}\n//   const B = createClassWrapper(A);\n//   B() instanceof A // true\n//   B() instanceof B // true\nfunction createClassWrapper(type) {\n  function fn(...args) {\n    return ReflectConstruct(type\x2C args\x2C new.target || type);\n  }\n  // Mask the wrapper function name and length values\n  ObjectDefineProperties(fn\x2C {\n    name: { __proto__: null\x2C value: type.name }\x2C\n    length: { __proto__: null\x2C value: type.length }\x2C\n  });\n  ObjectSetPrototypeOf(fn\x2C type);\n  fn.prototype = type.prototype;\n  return fn;\n}\n\nlet signalsToNamesMapping;\nfunction getSignalsToNamesMapping() {\n  if (signalsToNamesMapping !== undefined)\n    return signalsToNamesMapping;\n\n  signalsToNamesMapping = { __proto__: null };\n  for (const key in signals) {\n    signalsToNamesMapping[signals[key]] = key;\n  }\n\n  return signalsToNamesMapping;\n}\n\nfunction convertToValidSignal(signal) {\n  if (typeof signal === 'number' && getSignalsToNamesMapping()[signal])\n    return signal;\n\n  if (typeof signal === 'string') {\n    const signalName = signals[StringPrototypeToUpperCase(signal)];\n    if (signalName) return signalName;\n  }\n\n  throw new ERR_UNKNOWN_SIGNAL(signal);\n}\n\nfunction getConstructorOf(obj) {\n  while (obj) {\n    const descriptor = ObjectGetOwnPropertyDescriptor(obj\x2C 'constructor');\n    if (descriptor !== undefined &&\n        typeof descriptor.value === 'function' &&\n        descriptor.value.name !== '') {\n      return descriptor.value;\n    }\n\n    obj = ObjectGetPrototypeOf(obj);\n  }\n\n  return null;\n}\n\nlet cachedURL;\nlet cachedCWD;\n\n/**\n * Get the current working directory while accounting for the possibility that it has been deleted.\n * `process.cwd()` can fail if the parent directory is deleted while the process runs.\n * @returns {URL} The current working directory or the volume root if it cannot be determined.\n */\nfunction getCWDURL() {\n  const { sep } = require('path');\n  const { pathToFileURL } = require('internal/url');\n\n  let cwd;\n\n  try {\n    // The implementation of `process.cwd()` already uses proper cache when it can.\n    // It's a relatively cheap call performance-wise for the most common use case.\n    cwd = process.cwd();\n  } catch {\n    cachedURL ??= pathToFileURL(sep);\n  }\n\n  if (cwd != null && cwd !== cachedCWD) {\n    cachedURL = pathToFileURL(cwd + sep);\n    cachedCWD = cwd;\n  }\n\n  return cachedURL;\n}\n\nfunction getSystemErrorName(err) {\n  const entry = uvErrmapGet(err);\n  return entry ? entry[0] : `Unknown system error ${err}`;\n}\n\nfunction getSystemErrorMap() {\n  return lazyUv().getErrorMap();\n}\n\nconst kCustomPromisifiedSymbol = SymbolFor('nodejs.util.promisify.custom');\nconst kCustomPromisifyArgsSymbol = Symbol('customPromisifyArgs');\n\nlet validateFunction;\n\nfunction promisify(original) {\n  // Lazy-load to avoid a circular dependency.\n  if (validateFunction === undefined)\n    ({ validateFunction } = require('internal/validators'));\n\n  validateFunction(original\x2C 'original');\n\n  if (original[kCustomPromisifiedSymbol]) {\n    const fn = original[kCustomPromisifiedSymbol];\n\n    validateFunction(fn\x2C 'util.promisify.custom');\n\n    return ObjectDefineProperty(fn\x2C kCustomPromisifiedSymbol\x2C {\n      __proto__: null\x2C\n      value: fn\x2C enumerable: false\x2C writable: false\x2C configurable: true\x2C\n    });\n  }\n\n  // Names to create an object from in case the callback receives multiple\n  // arguments\x2C e.g. ['bytesRead'\x2C 'buffer'] for fs.read.\n  const argumentNames = original[kCustomPromisifyArgsSymbol];\n\n  function fn(...args) {\n    return new Promise((resolve\x2C reject) => {\n      ArrayPrototypePush(args\x2C (err\x2C ...values) => {\n        if (err) {\n          return reject(err);\n        }\n        if (argumentNames !== undefined && values.length > 1) {\n          const obj = {};\n          for (let i = 0; i < argumentNames.length; i++)\n            obj[argumentNames[i]] = values[i];\n          resolve(obj);\n        } else {\n          resolve(values[0]);\n        }\n      });\n      ReflectApply(original\x2C this\x2C args);\n    });\n  }\n\n  ObjectSetPrototypeOf(fn\x2C ObjectGetPrototypeOf(original));\n\n  ObjectDefineProperty(fn\x2C kCustomPromisifiedSymbol\x2C {\n    __proto__: null\x2C\n    value: fn\x2C enumerable: false\x2C writable: false\x2C configurable: true\x2C\n  });\n\n  const descriptors = ObjectGetOwnPropertyDescriptors(original);\n  const propertiesValues = ObjectValues(descriptors);\n  for (let i = 0; i < propertiesValues.length; i++) {\n    // We want to use null-prototype objects to not rely on globally mutable\n    // %Object.prototype%.\n    ObjectSetPrototypeOf(propertiesValues[i]\x2C null);\n  }\n  return ObjectDefineProperties(fn\x2C descriptors);\n}\n\npromisify.custom = kCustomPromisifiedSymbol;\n\n// The built-in Array#join is slower in v8 6.0\nfunction join(output\x2C separator) {\n  let str = '';\n  if (output.length !== 0) {\n    const lastIndex = output.length - 1;\n    for (let i = 0; i < lastIndex; i++) {\n      // It is faster not to use a template string here\n      str += output[i];\n      str += separator;\n    }\n    str += output[lastIndex];\n  }\n  return str;\n}\n\n// As of V8 6.6\x2C depending on the size of the array\x2C this is anywhere\n// between 1.5-10x faster than the two-arg version of Array#splice()\nfunction spliceOne(list\x2C index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nconst kNodeModulesRE = /^(.*)[\\\\/]node_modules[\\\\/]/;\n\nlet getStructuredStack;\n\nfunction isInsideNodeModules() {\n  if (getStructuredStack === undefined) {\n    // Lazy-load to avoid a circular dependency.\n    const { runInNewContext } = require('vm');\n    // Use `runInNewContext()` to get something tamper-proof and\n    // side-effect-free. Since this is currently only used for a deprecated API\x2C\n    // the perf implications should be okay.\n    getStructuredStack = runInNewContext(`(function() {\n      try { Error.stackTraceLimit = Infinity; } catch {}\n      return function structuredStack() {\n        const e = new Error();\n        overrideStackTrace.set(e\x2C (err\x2C trace) => trace);\n        return e.stack;\n      };\n    })()`\x2C { overrideStackTrace }\x2C { filename: 'structured-stack' });\n  }\n\n  const stack = getStructuredStack();\n\n  // Iterate over all stack frames and look for the first one not coming\n  // from inside Node.js itself:\n  if (ArrayIsArray(stack)) {\n    for (const frame of stack) {\n      const filename = frame.getFileName();\n      // If a filename does not start with / or contain \\\x2C\n      // it's likely from Node.js core.\n      if (RegExpPrototypeExec(/^\\/|\\\\/\x2C filename) === null)\n        continue;\n      return RegExpPrototypeExec(kNodeModulesRE\x2C filename) !== null;\n    }\n  }\n  return false;\n}\n\nfunction once(callback) {\n  let called = false;\n  return function(...args) {\n    if (called) return;\n    called = true;\n    return ReflectApply(callback\x2C this\x2C args);\n  };\n}\n\nlet validateUint32;\n\nfunction sleep(msec) {\n  // Lazy-load to avoid a circular dependency.\n  if (validateUint32 === undefined)\n    ({ validateUint32 } = require('internal/validators'));\n\n  validateUint32(msec\x2C 'msec');\n  _sleep(msec);\n}\n\nfunction createDeferredPromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res\x2C rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return { promise\x2C resolve\x2C reject };\n}\n\n// https://heycam.github.io/webidl/#define-the-operations\nfunction defineOperation(target\x2C name\x2C method) {\n  ObjectDefineProperty(target\x2C name\x2C {\n    __proto__: null\x2C\n    writable: true\x2C\n    enumerable: true\x2C\n    configurable: true\x2C\n    value: method\x2C\n  });\n}\n\n// https://heycam.github.io/webidl/#es-interfaces\nfunction exposeInterface(target\x2C name\x2C interfaceObject) {\n  ObjectDefineProperty(target\x2C name\x2C {\n    __proto__: null\x2C\n    writable: true\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: interfaceObject\x2C\n  });\n}\n\n// https://heycam.github.io/webidl/#es-namespaces\nfunction exposeNamespace(target\x2C name\x2C namespaceObject) {\n  ObjectDefineProperty(target\x2C name\x2C {\n    __proto__: null\x2C\n    writable: true\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: namespaceObject\x2C\n  });\n}\n\nfunction exposeGetterAndSetter(target\x2C name\x2C getter\x2C setter = undefined) {\n  ObjectDefineProperty(target\x2C name\x2C {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    get: getter\x2C\n    set: setter\x2C\n  });\n}\n\nfunction defineLazyProperties(target\x2C id\x2C keys\x2C enumerable = true) {\n  const descriptors = { __proto__: null };\n  let mod;\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    let lazyLoadedValue;\n    function set(value) {\n      ObjectDefineProperty(target\x2C key\x2C {\n        __proto__: null\x2C\n        writable: true\x2C\n        value\x2C\n      });\n    }\n    ObjectDefineProperty(set\x2C 'name'\x2C {\n      __proto__: null\x2C\n      value: `set ${key}`\x2C\n    });\n    function get() {\n      mod ??= require(id);\n      if (lazyLoadedValue === undefined) {\n        lazyLoadedValue = mod[key];\n        set(lazyLoadedValue);\n      }\n      return lazyLoadedValue;\n    }\n    ObjectDefineProperty(get\x2C 'name'\x2C {\n      __proto__: null\x2C\n      value: `get ${key}`\x2C\n    });\n    descriptors[key] = {\n      __proto__: null\x2C\n      configurable: true\x2C\n      enumerable\x2C\n      get\x2C\n      set\x2C\n    };\n  }\n  ObjectDefineProperties(target\x2C descriptors);\n}\n\nfunction defineReplaceableLazyAttribute(target\x2C id\x2C keys\x2C writable = true\x2C check) {\n  let mod;\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    let value;\n    let setterCalled = false;\n\n    function get() {\n      if (check !== undefined) {\n        FunctionPrototypeCall(check\x2C this);\n      }\n      if (setterCalled) {\n        return value;\n      }\n      mod ??= require(id);\n      value ??= mod[key];\n      return value;\n    }\n\n    ObjectDefineProperty(get\x2C 'name'\x2C {\n      __proto__: null\x2C\n      value: `get ${key}`\x2C\n    });\n\n    function set(val) {\n      setterCalled = true;\n      value = val;\n    }\n    ObjectDefineProperty(set\x2C 'name'\x2C {\n      __proto__: null\x2C\n      value: `set ${key}`\x2C\n    });\n\n    ObjectDefineProperty(target\x2C key\x2C {\n      __proto__: null\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      get\x2C\n      set: writable ? set : undefined\x2C\n    });\n  }\n}\n\nfunction exposeLazyInterfaces(target\x2C id\x2C keys) {\n  defineLazyProperties(target\x2C id\x2C keys\x2C false);\n}\n\nlet _DOMException;\nconst lazyDOMExceptionClass = () => {\n  _DOMException ??= internalBinding('messaging').DOMException;\n  return _DOMException;\n};\n\nconst lazyDOMException = hideStackFrames((message\x2C name) => {\n  _DOMException ??= internalBinding('messaging').DOMException;\n  return new _DOMException(message\x2C name);\n});\n\nconst kEnumerableProperty = { __proto__: null };\nkEnumerableProperty.enumerable = true;\nObjectFreeze(kEnumerableProperty);\n\nconst kEmptyObject = ObjectFreeze({ __proto__: null });\n\nfunction filterOwnProperties(source\x2C keys) {\n  const filtered = { __proto__: null };\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (ObjectPrototypeHasOwnProperty(source\x2C key)) {\n      filtered[key] = source[key];\n    }\n  }\n\n  return filtered;\n}\n\n/**\n * Mimics `obj[key] = value` but ignoring potential prototype inheritance.\n * @param {any} obj\n * @param {string} key\n * @param {any} value\n * @returns {any}\n */\nfunction setOwnProperty(obj\x2C key\x2C value) {\n  return ObjectDefineProperty(obj\x2C key\x2C {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    value\x2C\n    writable: true\x2C\n  });\n}\n\nlet internalGlobal;\nfunction getInternalGlobal() {\n  if (internalGlobal == null) {\n    // Lazy-load to avoid a circular dependency.\n    const { runInNewContext } = require('vm');\n    internalGlobal = runInNewContext('this'\x2C undefined\x2C { contextName: 'internal' });\n  }\n  return internalGlobal;\n}\n\nfunction SideEffectFreeRegExpPrototypeExec(regex\x2C string) {\n  const { RegExp: RegExpFromAnotherRealm } = getInternalGlobal();\n  return FunctionPrototypeCall(RegExpFromAnotherRealm.prototype.exec\x2C regex\x2C string);\n}\n\nconst crossRelmRegexes = new SafeWeakMap();\nfunction getCrossRelmRegex(regex) {\n  const cached = crossRelmRegexes.get(regex);\n  if (cached) return cached;\n\n  let flagString = '';\n  if (RegExpPrototypeGetHasIndices(regex)) flagString += 'd';\n  if (RegExpPrototypeGetGlobal(regex)) flagString += 'g';\n  if (RegExpPrototypeGetIgnoreCase(regex)) flagString += 'i';\n  if (RegExpPrototypeGetMultiline(regex)) flagString += 'm';\n  if (RegExpPrototypeGetDotAll(regex)) flagString += 's';\n  if (RegExpPrototypeGetUnicode(regex)) flagString += 'u';\n  if (RegExpPrototypeGetSticky(regex)) flagString += 'y';\n\n  const { RegExp: RegExpFromAnotherRealm } = getInternalGlobal();\n  const crossRelmRegex = new RegExpFromAnotherRealm(RegExpPrototypeGetSource(regex)\x2C flagString);\n  crossRelmRegexes.set(regex\x2C crossRelmRegex);\n  return crossRelmRegex;\n}\n\nfunction SideEffectFreeRegExpPrototypeSymbolReplace(regex\x2C string\x2C replacement) {\n  return getCrossRelmRegex(regex)[SymbolReplace](string\x2C replacement);\n}\n\nfunction SideEffectFreeRegExpPrototypeSymbolSplit(regex\x2C string\x2C limit = undefined) {\n  return getCrossRelmRegex(regex)[SymbolSplit](string\x2C limit);\n}\n\n\nfunction isArrayBufferDetached(value) {\n  if (ArrayBufferPrototypeGetByteLength(value) === 0) {\n    return _isArrayBufferDetached(value);\n  }\n\n  return false;\n}\n\n/**\n * Helper function to lazy-load an initialize-once value.\n * @template T Return value of initializer\n * @param {()=>T} initializer Initializer of the lazily loaded value.\n * @returns {()=>T}\n */\nfunction getLazy(initializer) {\n  let value;\n  let initialized = false;\n  return function() {\n    if (initialized === false) {\n      value = initializer();\n      initialized = true;\n    }\n    return value;\n  };\n}\n\n// Setup user-facing NODE_V8_COVERAGE environment variable that writes\n// ScriptCoverage objects to a specified directory.\nfunction setupCoverageHooks(dir) {\n  const cwd = require('internal/process/execution').tryGetCwd();\n  const { resolve } = require('path');\n  const coverageDirectory = resolve(cwd\x2C dir);\n  const { sourceMapCacheToObject } =\n    require('internal/source_map/source_map_cache');\n\n  if (process.features.inspector) {\n    internalBinding('profiler').setCoverageDirectory(coverageDirectory);\n    internalBinding('profiler').setSourceMapCacheGetter(sourceMapCacheToObject);\n  } else {\n    process.emitWarning('The inspector is disabled\x2C ' +\n                        'coverage could not be collected'\x2C\n                        'Warning');\n    return '';\n  }\n  return coverageDirectory;\n}\n\n\nconst handleTypes = ['TCP'\x2C 'TTY'\x2C 'UDP'\x2C 'FILE'\x2C 'PIPE'\x2C 'UNKNOWN'];\nfunction guessHandleType(fd) {\n  const type = _guessHandleType(fd);\n  return handleTypes[type];\n}\n\nclass WeakReference {\n  #weak = null;\n  #strong = null;\n  #refCount = 0;\n  constructor(object) {\n    this.#weak = new SafeWeakRef(object);\n  }\n\n  incRef() {\n    this.#refCount++;\n    if (this.#refCount === 1) {\n      const derefed = this.#weak.deref();\n      if (derefed !== undefined) {\n        this.#strong = derefed;\n      }\n    }\n    return this.#refCount;\n  }\n\n  decRef() {\n    this.#refCount--;\n    if (this.#refCount === 0) {\n      this.#strong = null;\n    }\n    return this.#refCount;\n  }\n\n  get() {\n    return this.#weak.deref();\n  }\n}\n\nmodule.exports = {\n  getLazy\x2C\n  assertCrypto\x2C\n  cachedResult\x2C\n  convertToValidSignal\x2C\n  createClassWrapper\x2C\n  createDeferredPromise\x2C\n  decorateErrorStack\x2C\n  defineOperation\x2C\n  defineLazyProperties\x2C\n  defineReplaceableLazyAttribute\x2C\n  deprecate\x2C\n  emitExperimentalWarning\x2C\n  exposeInterface\x2C\n  exposeLazyInterfaces\x2C\n  exposeNamespace\x2C\n  exposeGetterAndSetter\x2C\n  filterDuplicateStrings\x2C\n  filterOwnProperties\x2C\n  getConstructorOf\x2C\n  getCWDURL\x2C\n  getInternalGlobal\x2C\n  getSystemErrorMap\x2C\n  getSystemErrorName\x2C\n  guessHandleType\x2C\n  isArrayBufferDetached\x2C\n  isError\x2C\n  isInsideNodeModules\x2C\n  join\x2C\n  lazyDOMException\x2C\n  lazyDOMExceptionClass\x2C\n  normalizeEncoding\x2C\n  once\x2C\n  promisify\x2C\n  SideEffectFreeRegExpPrototypeExec\x2C\n  SideEffectFreeRegExpPrototypeSymbolReplace\x2C\n  SideEffectFreeRegExpPrototypeSymbolSplit\x2C\n  sleep\x2C\n  spliceOne\x2C\n  setupCoverageHooks\x2C\n  toUSVString\x2C\n  removeColors\x2C\n\n  // Symbol used to customize promisify conversion\n  customPromisifyArgs: kCustomPromisifyArgsSymbol\x2C\n\n  // Symbol used to provide a custom inspect function for an object as an\n  // alternative to using 'inspect'\n  customInspectSymbol: SymbolFor('nodejs.util.inspect.custom')\x2C\n\n  // Used by the buffer module to capture an internal reference to the\n  // default isEncoding implementation\x2C just in case userland overrides it.\n  kIsEncodingSymbol: Symbol('kIsEncodingSymbol')\x2C\n  kVmBreakFirstLineSymbol: Symbol('kVmBreakFirstLineSymbol')\x2C\n\n  kEmptyObject\x2C\n  kEnumerableProperty\x2C\n  setOwnProperty\x2C\n  pendingDeprecate\x2C\n  WeakReference\x2C\n};\n
code-source-info,0x112583040,16,16694,17598,,,
tick,0x7ff809303a38,42355,0,0x0,0,0x10c9f09d0,0x31e647c43c84,0x31e6f6b4c47e,0x31e63e0bd356,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,11,42377,0x112583a40,628,requireBuiltin node:internal/bootstrap/realm:423:24,0x31e6931b7188,^
script-source,9,node:internal/bootstrap/realm,// This file is executed in every realm that is created by Node.js\x2C including\n// the context of main thread\x2C worker threads\x2C and ShadowRealms.\n// Only per-realm internal states and bindings should be bootstrapped in this\n// file and no globals should be exposed to the user code.\n//\n// This file creates the internal module & binding loaders used by built-in\n// modules. In contrast\x2C user land modules are loaded using\n// lib/internal/modules/cjs/loader.js (CommonJS Modules) or\n// lib/internal/modules/esm/* (ES Modules).\n//\n// This file is compiled and run by node.cc before bootstrap/node.js\n// was called\x2C therefore the loaders are bootstrapped before we start to\n// actually bootstrap Node.js. It creates the following objects:\n//\n// C++ binding loaders:\n// - process.binding(): the legacy C++ binding loader\x2C accessible from user land\n//   because it is an object attached to the global process object.\n//   These C++ bindings are created using NODE_BUILTIN_MODULE_CONTEXT_AWARE()\n//   and have their nm_flags set to NM_F_BUILTIN. We do not make any guarantees\n//   about the stability of these bindings\x2C but still have to take care of\n//   compatibility issues caused by them from time to time.\n// - process._linkedBinding(): intended to be used by embedders to add\n//   additional C++ bindings in their applications. These C++ bindings\n//   can be created using NODE_BINDING_CONTEXT_AWARE_CPP() with the flag\n//   NM_F_LINKED.\n// - internalBinding(): the private internal C++ binding loader\x2C inaccessible\n//   from user land unless through `require('internal/test/binding')`.\n//   These C++ bindings are created using NODE_BINDING_CONTEXT_AWARE_INTERNAL()\n//   and have their nm_flags set to NM_F_INTERNAL.\n//\n// Internal JavaScript module loader:\n// - BuiltinModule: a minimal module system used to load the JavaScript core\n//   modules found in lib/**/*.js and deps/**/*.js. All core modules are\n//   compiled into the node binary via node_javascript.cc generated by js2c.py\x2C\n//   so they can be loaded faster without the cost of I/O. This class makes the\n//   lib/internal/*\x2C deps/internal/* modules and internalBinding() available by\n//   default to core modules\x2C and lets the core modules require itself via\n//   require('internal/bootstrap/realm') even when this file is not written in\n//   CommonJS style.\n//\n// Other objects:\n// - process.moduleLoadList: an array recording the bindings and the modules\n//   loaded in the process and the order in which they are loaded.\n\n'use strict';\n\n// This file is compiled as if it's wrapped in a function with arguments\n// passed by node::RunBootstrapping()\n/* global process\x2C getLinkedBinding\x2C getInternalBinding\x2C primordials */\n\nconst {\n  ArrayFrom\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  Error\x2C\n  ObjectDefineProperty\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectGet\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  String\x2C\n  StringPrototypeStartsWith\x2C\n  StringPrototypeSlice\x2C\n  TypeError\x2C\n} = primordials;\n\n// Set up process.moduleLoadList.\nconst moduleLoadList = [];\nObjectDefineProperty(process\x2C 'moduleLoadList'\x2C {\n  __proto__: null\x2C\n  value: moduleLoadList\x2C\n  configurable: true\x2C\n  enumerable: true\x2C\n  writable: false\x2C\n});\n\n\n// processBindingAllowList contains the name of bindings that are allowed\n// for access via process.binding(). This is used to provide a transition\n// path for modules that are being moved over to internalBinding.\n// Certain bindings may not actually correspond to an internalBinding any\n// more\x2C we just implement them as legacy wrappers instead. See the\n// legacyWrapperList.\nconst processBindingAllowList = new SafeSet([\n  'async_wrap'\x2C\n  'buffer'\x2C\n  'cares_wrap'\x2C\n  'config'\x2C\n  'constants'\x2C\n  'contextify'\x2C\n  'crypto'\x2C\n  'fs'\x2C\n  'fs_event_wrap'\x2C\n  'http_parser'\x2C\n  'icu'\x2C\n  'inspector'\x2C\n  'js_stream'\x2C\n  'natives'\x2C\n  'os'\x2C\n  'pipe_wrap'\x2C\n  'process_wrap'\x2C\n  'signal_wrap'\x2C\n  'spawn_sync'\x2C\n  'stream_wrap'\x2C\n  'tcp_wrap'\x2C\n  'tls_wrap'\x2C\n  'tty_wrap'\x2C\n  'udp_wrap'\x2C\n  'url'\x2C\n  'util'\x2C\n  'uv'\x2C\n  'v8'\x2C\n  'zlib'\x2C\n]);\n\nconst runtimeDeprecatedList = new SafeSet([\n  'async_wrap'\x2C\n  'crypto'\x2C\n  'http_parser'\x2C\n  'signal_wrap'\x2C\n  'url'\x2C\n  'v8'\x2C\n]);\n\nconst legacyWrapperList = new SafeSet([\n  'natives'\x2C\n  'util'\x2C\n]);\n\n// The code bellow assumes that the two lists must not contain any modules\n// beginning with "internal/".\n// Modules that can only be imported via the node: scheme.\nconst schemelessBlockList = new SafeSet([\n  'test'\x2C\n  'test/reporters'\x2C\n]);\n// Modules that will only be enabled at run time.\nconst experimentalModuleList = new SafeSet();\n\n// Set up process.binding() and process._linkedBinding().\n{\n  const bindingObj = { __proto__: null };\n\n  process.binding = function binding(module) {\n    module = String(module);\n    // Deprecated specific process.binding() modules\x2C but not all\x2C allow\n    // selective fallback to internalBinding for the deprecated ones.\n    if (processBindingAllowList.has(module)) {\n      if (runtimeDeprecatedList.has(module)) {\n        runtimeDeprecatedList.delete(module);\n        process.emitWarning(\n          `Access to process.binding('${module}') is deprecated.`\x2C\n          'DeprecationWarning'\x2C\n          'DEP0111');\n      }\n      if (legacyWrapperList.has(module)) {\n        return requireBuiltin('internal/legacy/processbinding')[module]();\n      }\n      return internalBinding(module);\n    }\n    // eslint-disable-next-line no-restricted-syntax\n    throw new Error(`No such module: ${module}`);\n  };\n\n  process._linkedBinding = function _linkedBinding(module) {\n    module = String(module);\n    let mod = bindingObj[module];\n    if (typeof mod !== 'object')\n      mod = bindingObj[module] = getLinkedBinding(module);\n    return mod;\n  };\n}\n\n/**\n * Set up internalBinding() in the closure.\n * @type {import('typings/globals').internalBinding}\n */\nlet internalBinding;\n{\n  const bindingObj = { __proto__: null };\n  // eslint-disable-next-line no-global-assign\n  internalBinding = function internalBinding(module) {\n    let mod = bindingObj[module];\n    if (typeof mod !== 'object') {\n      mod = bindingObj[module] = getInternalBinding(module);\n      ArrayPrototypePush(moduleLoadList\x2C `Internal Binding ${module}`);\n    }\n    return mod;\n  };\n}\n\nconst selfId = 'internal/bootstrap/realm';\nconst {\n  builtinIds\x2C\n  compileFunction\x2C\n  setInternalLoaders\x2C\n} = internalBinding('builtins');\n\nconst getOwn = (target\x2C property\x2C receiver) => {\n  return ObjectPrototypeHasOwnProperty(target\x2C property) ?\n    ReflectGet(target\x2C property\x2C receiver) :\n    undefined;\n};\n\nconst publicBuiltinIds = builtinIds\n  .filter((id) =>\n    !StringPrototypeStartsWith(id\x2C 'internal/') &&\n      !experimentalModuleList.has(id)\x2C\n  );\n// Do not expose the loaders to user land even with --expose-internals.\nconst internalBuiltinIds = builtinIds\n  .filter((id) => StringPrototypeStartsWith(id\x2C 'internal/') && id !== selfId);\n\n// When --expose-internals is on we'll add the internal builtin ids to these.\nlet canBeRequiredByUsersList = new SafeSet(publicBuiltinIds);\nlet canBeRequiredByUsersWithoutSchemeList =\n  new SafeSet(publicBuiltinIds.filter((id) => !schemelessBlockList.has(id)));\n\n/**\n * An internal abstraction for the built-in JavaScript modules of Node.js.\n * Be careful not to expose this to user land unless --expose-internals is\n * used\x2C in which case there is no compatibility guarantee about this class.\n */\nclass BuiltinModule {\n  /**\n   * A map from the module IDs to the module instances.\n   * @type {Map<string\x2C BuiltinModule>}\n   */\n  static map = new SafeMap(\n    ArrayPrototypeMap(builtinIds\x2C (id) => [id\x2C new BuiltinModule(id)])\x2C\n  );\n\n  constructor(id) {\n    this.filename = `${id}.js`;\n    this.id = id;\n\n    // The CJS exports object of the module.\n    this.exports = {};\n    // States used to work around circular dependencies.\n    this.loaded = false;\n    this.loading = false;\n\n    // The following properties are used by the ESM implementation and only\n    // initialized when the built-in module is loaded by users.\n    /**\n     * The C++ ModuleWrap binding used to interface with the ESM implementation.\n     * @type {ModuleWrap|undefined}\n     */\n    this.module = undefined;\n    /**\n     * Exported names for the ESM imports.\n     * @type {string[]|undefined}\n     */\n    this.exportKeys = undefined;\n  }\n\n  static allowRequireByUsers(id) {\n    if (id === selfId) {\n      // No code because this is an assertion against bugs.\n      // eslint-disable-next-line no-restricted-syntax\n      throw new Error(`Should not allow ${id}`);\n    }\n    canBeRequiredByUsersList.add(id);\n    if (!schemelessBlockList.has(id)) {\n      canBeRequiredByUsersWithoutSchemeList.add(id);\n    }\n  }\n\n  static setRealmAllowRequireByUsers(ids) {\n    canBeRequiredByUsersList =\n      new SafeSet(ArrayPrototypeFilter(ids\x2C (id) => ArrayPrototypeIncludes(publicBuiltinIds\x2C id)));\n    canBeRequiredByUsersWithoutSchemeList =\n      new SafeSet(ArrayPrototypeFilter(ids\x2C (id) => !schemelessBlockList.has(id)));\n  }\n\n  // To be called during pre-execution when --expose-internals is on.\n  // Enables the user-land module loader to access internal modules.\n  static exposeInternals() {\n    for (let i = 0; i < internalBuiltinIds.length; ++i) {\n      BuiltinModule.allowRequireByUsers(internalBuiltinIds[i]);\n    }\n  }\n\n  static exists(id) {\n    return BuiltinModule.map.has(id);\n  }\n\n  static canBeRequiredByUsers(id) {\n    return canBeRequiredByUsersList.has(id);\n  }\n\n  static canBeRequiredWithoutScheme(id) {\n    return canBeRequiredByUsersWithoutSchemeList.has(id);\n  }\n\n  static normalizeRequirableId(id) {\n    if (StringPrototypeStartsWith(id\x2C 'node:')) {\n      const normalizedId = StringPrototypeSlice(id\x2C 5);\n      if (BuiltinModule.canBeRequiredByUsers(normalizedId)) {\n        return normalizedId;\n      }\n    } else if (BuiltinModule.canBeRequiredWithoutScheme(id)) {\n      return id;\n    }\n\n    return undefined;\n  }\n\n  static isBuiltin(id) {\n    return BuiltinModule.canBeRequiredWithoutScheme(id) || (\n      typeof id === 'string' &&\n        StringPrototypeStartsWith(id\x2C 'node:') &&\n        BuiltinModule.canBeRequiredByUsers(StringPrototypeSlice(id\x2C 5))\n    );\n  }\n\n  static getCanBeRequiredByUsersWithoutSchemeList() {\n    return ArrayFrom(canBeRequiredByUsersWithoutSchemeList);\n  }\n\n  static getSchemeOnlyModuleNames() {\n    return ArrayFrom(schemelessBlockList);\n  }\n\n  // Used by user-land module loaders to compile and load builtins.\n  compileForPublicLoader() {\n    if (!BuiltinModule.canBeRequiredByUsers(this.id)) {\n      // No code because this is an assertion against bugs\n      // eslint-disable-next-line no-restricted-syntax\n      throw new Error(`Should not compile ${this.id} for public use`);\n    }\n    this.compileForInternalLoader();\n    if (!this.exportKeys) {\n      // When using --expose-internals\x2C we do not want to reflect the named\n      // exports from core modules as this can trigger unnecessary getters.\n      const internal = StringPrototypeStartsWith(this.id\x2C 'internal/');\n      this.exportKeys = internal ? [] : ObjectKeys(this.exports);\n    }\n    this.getESMFacade();\n    this.syncExports();\n    return this.exports;\n  }\n\n  getESMFacade() {\n    if (this.module) return this.module;\n    const { ModuleWrap } = internalBinding('module_wrap');\n    // TODO(aduh95): move this to C++\x2C alongside the initialization of the class.\n    ObjectSetPrototypeOf(ModuleWrap.prototype\x2C null);\n    const url = `node:${this.id}`;\n    const builtin = this;\n    const exportsKeys = ArrayPrototypeSlice(this.exportKeys);\n    ArrayPrototypePush(exportsKeys\x2C 'default');\n    this.module = new ModuleWrap(\n      url\x2C undefined\x2C exportsKeys\x2C\n      function() {\n        builtin.syncExports();\n        this.setExport('default'\x2C builtin.exports);\n      });\n    // Ensure immediate sync execution to capture exports now\n    this.module.instantiate();\n    this.module.evaluate(-1\x2C false);\n    return this.module;\n  }\n\n  // Provide named exports for all builtin libraries so that the libraries\n  // may be imported in a nicer way for ESM users. The default export is left\n  // as the entire namespace (module.exports) and updates when this function is\n  // called so that APMs and other behavior are supported.\n  syncExports() {\n    const names = this.exportKeys;\n    if (this.module) {\n      for (let i = 0; i < names.length; i++) {\n        const exportName = names[i];\n        if (exportName === 'default') continue;\n        this.module.setExport(exportName\x2C\n                              getOwn(this.exports\x2C exportName\x2C this.exports));\n      }\n    }\n  }\n\n  compileForInternalLoader() {\n    if (this.loaded || this.loading) {\n      return this.exports;\n    }\n\n    const id = this.id;\n    this.loading = true;\n\n    try {\n      const requireFn = StringPrototypeStartsWith(this.id\x2C 'internal/deps/') ?\n        requireWithFallbackInDeps : requireBuiltin;\n\n      const fn = compileFunction(id);\n      // Arguments must match the parameters specified in\n      // BuiltinLoader::LookupAndCompile().\n      fn(this.exports\x2C requireFn\x2C this\x2C process\x2C internalBinding\x2C primordials);\n\n      this.loaded = true;\n    } finally {\n      this.loading = false;\n    }\n\n    // "NativeModule" is a legacy name of "BuiltinModule". We keep it\n    // here to avoid breaking users who parse process.moduleLoadList.\n    ArrayPrototypePush(moduleLoadList\x2C `NativeModule ${id}`);\n    return this.exports;\n  }\n}\n\n// Think of this as module.exports in this file even though it is not\n// written in CommonJS style.\nconst loaderExports = {\n  internalBinding\x2C\n  BuiltinModule\x2C\n  require: requireBuiltin\x2C\n};\n\nfunction requireBuiltin(id) {\n  if (id === selfId) {\n    return loaderExports;\n  }\n\n  const mod = BuiltinModule.map.get(id);\n  // Can't load the internal errors module from here\x2C have to use a raw error.\n  // eslint-disable-next-line no-restricted-syntax\n  if (!mod) throw new TypeError(`Missing internal module '${id}'`);\n  return mod.compileForInternalLoader();\n}\n\n// Allow internal modules from dependencies to require\n// other modules from dependencies by providing fallbacks.\nfunction requireWithFallbackInDeps(request) {\n  if (StringPrototypeStartsWith(request\x2C 'node:')) {\n    request = StringPrototypeSlice(request\x2C 5);\n  } else if (!BuiltinModule.map.has(request)) {\n    request = `internal/deps/${request}`;\n  }\n  return requireBuiltin(request);\n}\n\nfunction setupPrepareStackTrace() {\n  const {\n    setEnhanceStackForFatalException\x2C\n    setPrepareStackTraceCallback\x2C\n  } = internalBinding('errors');\n  const {\n    prepareStackTrace\x2C\n    fatalExceptionStackEnhancers: {\n      beforeInspector\x2C\n      afterInspector\x2C\n    }\x2C\n  } = requireBuiltin('internal/errors');\n  // Tell our PrepareStackTraceCallback passed to the V8 API\n  // to call prepareStackTrace().\n  setPrepareStackTraceCallback(prepareStackTrace);\n  // Set the function used to enhance the error stack for printing\n  setEnhanceStackForFatalException(beforeInspector\x2C afterInspector);\n}\n\n// Store the internal loaders in C++.\nsetInternalLoaders(internalBinding\x2C requireBuiltin);\n\n// Setup per-realm bindings.\nsetupPrepareStackTrace();\n
code-source-info,0x112583a40,9,13622,13964,,,
tick,0x7ff8092cbace,43224,0,0x0,0,0x10c9f09d0,0x31e647c43c84,0x31e6f6b4c47e,0x31e63e0bd356,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,11,43252,0x112583d00,1228,compileForInternalLoader node:internal/bootstrap/realm:386:27,0x31e6931b6f18,^
code-source-info,0x112583d00,9,12606,13404,,,
code-creation,JS,11,43295,0x112584200,536,internalBinding node:internal/bootstrap/realm:187:45,0x31e6931b66f0,^
code-source-info,0x112584200,9,6029,6267,,,
code-creation,JS,11,43314,0x112584440,104,isPosixPathSeparator node:path:56:30,0x31e647c5b180,^
code-source-info,0x112584440,34,1854,1902,,,
code-creation,JS,11,43367,0x1125844c0,316,SafeMap node:internal/per_context/primordials:413:16,0x31e6931b4b78,^
script-source,6,node:internal/per_context/primordials,'use strict';\n\n/* eslint-disable node-core/prefer-primordials */\n\n// This file subclasses and stores the JS builtins that come from the VM\n// so that Node.js's builtin modules do not need to later look these up from\n// the global proxy\x2C which can be mutated by users.\n\n// Use of primordials have sometimes a dramatic impact on performance\x2C please\n// benchmark all changes made in performance-sensitive areas of the codebase.\n// See: https://github.com/nodejs/node/pull/38248\n\nconst {\n  defineProperty: ReflectDefineProperty\x2C\n  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor\x2C\n  ownKeys: ReflectOwnKeys\x2C\n} = Reflect;\n\n// `uncurryThis` is equivalent to `func => Function.prototype.call.bind(func)`.\n// It is using `bind.bind(call)` to avoid using `Function.prototype.bind`\n// and `Function.prototype.call` after it may have been mutated by users.\nconst { apply\x2C bind\x2C call } = Function.prototype;\nconst uncurryThis = bind.bind(call);\nprimordials.uncurryThis = uncurryThis;\n\n// `applyBind` is equivalent to `func => Function.prototype.apply.bind(func)`.\n// It is using `bind.bind(apply)` to avoid using `Function.prototype.bind`\n// and `Function.prototype.apply` after it may have been mutated by users.\nconst applyBind = bind.bind(apply);\nprimordials.applyBind = applyBind;\n\n// Methods that accept a variable number of arguments\x2C and thus it's useful to\n// also create `${prefix}${key}Apply`\x2C which uses `Function.prototype.apply`\x2C\n// instead of `Function.prototype.call`\x2C and thus doesn't require iterator\n// destructuring.\nconst varargsMethods = [\n  // 'ArrayPrototypeConcat' is omitted\x2C because it performs the spread\n  // on its own for arrays and array-likes with a truthy\n  // @@isConcatSpreadable symbol property.\n  'ArrayOf'\x2C\n  'ArrayPrototypePush'\x2C\n  'ArrayPrototypeUnshift'\x2C\n  // 'FunctionPrototypeCall' is omitted\x2C since there's 'ReflectApply'\n  // and 'FunctionPrototypeApply'.\n  'MathHypot'\x2C\n  'MathMax'\x2C\n  'MathMin'\x2C\n  'StringFromCharCode'\x2C\n  'StringFromCodePoint'\x2C\n  'StringPrototypeConcat'\x2C\n  'TypedArrayOf'\x2C\n];\n\nfunction getNewKey(key) {\n  return typeof key === 'symbol' ?\n    `Symbol${key.description[7].toUpperCase()}${key.description.slice(8)}` :\n    `${key[0].toUpperCase()}${key.slice(1)}`;\n}\n\nfunction copyAccessor(dest\x2C prefix\x2C key\x2C { enumerable\x2C get\x2C set }) {\n  ReflectDefineProperty(dest\x2C `${prefix}Get${key}`\x2C {\n    __proto__: null\x2C\n    value: uncurryThis(get)\x2C\n    enumerable\x2C\n  });\n  if (set !== undefined) {\n    ReflectDefineProperty(dest\x2C `${prefix}Set${key}`\x2C {\n      __proto__: null\x2C\n      value: uncurryThis(set)\x2C\n      enumerable\x2C\n    });\n  }\n}\n\nfunction copyPropsRenamed(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C { __proto__: null\x2C ...desc });\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          __proto__: null\x2C\n          // `src` is bound as the `this` so that the static `this` points\n          // to the object it was defined on\x2C\n          // e.g.: `ArrayOfApply` gets a `this` of `Array`:\n          value: applyBind(desc.value\x2C src)\x2C\n        });\n      }\n    }\n  }\n}\n\nfunction copyPropsRenamedBound(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const { value } = desc;\n      if (typeof value === 'function') {\n        desc.value = value.bind(src);\n      }\n\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C { __proto__: null\x2C ...desc });\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          __proto__: null\x2C\n          value: applyBind(value\x2C src)\x2C\n        });\n      }\n    }\n  }\n}\n\nfunction copyPrototype(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const { value } = desc;\n      if (typeof value === 'function') {\n        desc.value = uncurryThis(value);\n      }\n\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C { __proto__: null\x2C ...desc });\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          __proto__: null\x2C\n          value: applyBind(value)\x2C\n        });\n      }\n    }\n  }\n}\n\n// Create copies of configurable value properties of the global object\n[\n  'Proxy'\x2C\n  'globalThis'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  primordials[name] = globalThis[name];\n});\n\n// Create copies of URI handling functions\n[\n  decodeURI\x2C\n  decodeURIComponent\x2C\n  encodeURI\x2C\n  encodeURIComponent\x2C\n].forEach((fn) => {\n  primordials[fn.name] = fn;\n});\n\n// Create copies of legacy functions\n[\n  escape\x2C\n  eval\x2C\n  unescape\x2C\n].forEach((fn) => {\n  primordials[fn.name] = fn;\n});\n\n// Create copies of the namespace objects\n[\n  'JSON'\x2C\n  'Math'\x2C\n  'Proxy'\x2C\n  'Reflect'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  copyPropsRenamed(globalThis[name]\x2C primordials\x2C name);\n});\n\n// Create copies of intrinsic objects\n[\n  'AggregateError'\x2C\n  'Array'\x2C\n  'ArrayBuffer'\x2C\n  'BigInt'\x2C\n  'BigInt64Array'\x2C\n  'BigUint64Array'\x2C\n  'Boolean'\x2C\n  'DataView'\x2C\n  'Date'\x2C\n  'Error'\x2C\n  'EvalError'\x2C\n  'FinalizationRegistry'\x2C\n  'Float32Array'\x2C\n  'Float64Array'\x2C\n  'Function'\x2C\n  'Int16Array'\x2C\n  'Int32Array'\x2C\n  'Int8Array'\x2C\n  'Map'\x2C\n  'Number'\x2C\n  'Object'\x2C\n  'RangeError'\x2C\n  'ReferenceError'\x2C\n  'RegExp'\x2C\n  'Set'\x2C\n  'String'\x2C\n  'Symbol'\x2C\n  'SyntaxError'\x2C\n  'TypeError'\x2C\n  'URIError'\x2C\n  'Uint16Array'\x2C\n  'Uint32Array'\x2C\n  'Uint8Array'\x2C\n  'Uint8ClampedArray'\x2C\n  'WeakMap'\x2C\n  'WeakRef'\x2C\n  'WeakSet'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  const original = globalThis[name];\n  primordials[name] = original;\n  copyPropsRenamed(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n// Define Symbol.dispose and Symbol.asyncDispose\n// Until these are defined by the environment.\n// TODO(MoLow): Remove this polyfill once Symbol.dispose and Symbol.asyncDispose are available in V8.\nprimordials.SymbolDispose ??= primordials.SymbolFor('nodejs.dispose');\nprimordials.SymbolAsyncDispose ??= primordials.SymbolFor('nodejs.asyncDispose');\n\n// Create copies of intrinsic objects that require a valid `this` to call\n// static methods.\n// Refs: https://www.ecma-international.org/ecma-262/#sec-promise.all\n[\n  'Promise'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  const original = globalThis[name];\n  primordials[name] = original;\n  copyPropsRenamedBound(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n// Create copies of abstract intrinsic objects that are not directly exposed\n// on the global object.\n// Refs: https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object\n[\n  { name: 'TypedArray'\x2C original: Reflect.getPrototypeOf(Uint8Array) }\x2C\n  { name: 'ArrayIterator'\x2C original: {\n    prototype: Reflect.getPrototypeOf(Array.prototype[Symbol.iterator]())\x2C\n  } }\x2C\n  { name: 'StringIterator'\x2C original: {\n    prototype: Reflect.getPrototypeOf(String.prototype[Symbol.iterator]())\x2C\n  } }\x2C\n].forEach(({ name\x2C original }) => {\n  primordials[name] = original;\n  // The static %TypedArray% methods require a valid `this`\x2C but can't be bound\x2C\n  // as they need a subclass constructor as the receiver:\n  copyPrototype(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\nprimordials.IteratorPrototype = Reflect.getPrototypeOf(primordials.ArrayIteratorPrototype);\n\n/* eslint-enable node-core/prefer-primordials */\n\nconst {\n  Array: ArrayConstructor\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeMap\x2C\n  FinalizationRegistry\x2C\n  FunctionPrototypeCall\x2C\n  Map\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectFreeze\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n  ReflectApply\x2C\n  ReflectConstruct\x2C\n  ReflectSet\x2C\n  ReflectGet\x2C\n  RegExp\x2C\n  RegExpPrototype\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeGetDotAll\x2C\n  RegExpPrototypeGetFlags\x2C\n  RegExpPrototypeGetGlobal\x2C\n  RegExpPrototypeGetHasIndices\x2C\n  RegExpPrototypeGetIgnoreCase\x2C\n  RegExpPrototypeGetMultiline\x2C\n  RegExpPrototypeGetSource\x2C\n  RegExpPrototypeGetSticky\x2C\n  RegExpPrototypeGetUnicode\x2C\n  Set\x2C\n  SymbolIterator\x2C\n  SymbolMatch\x2C\n  SymbolMatchAll\x2C\n  SymbolReplace\x2C\n  SymbolSearch\x2C\n  SymbolSpecies\x2C\n  SymbolSplit\x2C\n  WeakMap\x2C\n  WeakRef\x2C\n  WeakSet\x2C\n} = primordials;\n\n\n/**\n * Creates a class that can be safely iterated over.\n *\n * Because these functions are used by `makeSafe`\x2C which is exposed on the\n * `primordials` object\x2C it's important to use const references to the\n * primordials that they use.\n * @template {Iterable} T\n * @template {*} TReturn\n * @template {*} TNext\n * @param {(self: T) => IterableIterator<T>} factory\n * @param {(...args: [] | [TNext]) => IteratorResult<T\x2C TReturn>} next\n * @returns {Iterator<T\x2C TReturn\x2C TNext>}\n */\nconst createSafeIterator = (factory\x2C next) => {\n  class SafeIterator {\n    constructor(iterable) {\n      this._iterator = factory(iterable);\n    }\n    next() {\n      return next(this._iterator);\n    }\n    [SymbolIterator]() {\n      return this;\n    }\n  }\n  ObjectSetPrototypeOf(SafeIterator.prototype\x2C null);\n  ObjectFreeze(SafeIterator.prototype);\n  ObjectFreeze(SafeIterator);\n  return SafeIterator;\n};\n\nprimordials.SafeArrayIterator = createSafeIterator(\n  primordials.ArrayPrototypeSymbolIterator\x2C\n  primordials.ArrayIteratorPrototypeNext\x2C\n);\nprimordials.SafeStringIterator = createSafeIterator(\n  primordials.StringPrototypeSymbolIterator\x2C\n  primordials.StringIteratorPrototypeNext\x2C\n);\n\nconst copyProps = (src\x2C dest) => {\n  ArrayPrototypeForEach(ReflectOwnKeys(src)\x2C (key) => {\n    if (!ReflectGetOwnPropertyDescriptor(dest\x2C key)) {\n      ReflectDefineProperty(\n        dest\x2C\n        key\x2C\n        { __proto__: null\x2C ...ReflectGetOwnPropertyDescriptor(src\x2C key) });\n    }\n  });\n};\n\n/**\n * @type {typeof primordials.makeSafe}\n */\nconst makeSafe = (unsafe\x2C safe) => {\n  if (SymbolIterator in unsafe.prototype) {\n    const dummy = new unsafe();\n    let next; // We can reuse the same `next` method.\n\n    ArrayPrototypeForEach(ReflectOwnKeys(unsafe.prototype)\x2C (key) => {\n      if (!ReflectGetOwnPropertyDescriptor(safe.prototype\x2C key)) {\n        const desc = ReflectGetOwnPropertyDescriptor(unsafe.prototype\x2C key);\n        if (\n          typeof desc.value === 'function' &&\n          desc.value.length === 0 &&\n          SymbolIterator in (FunctionPrototypeCall(desc.value\x2C dummy) ?? {})\n        ) {\n          const createIterator = uncurryThis(desc.value);\n          next ??= uncurryThis(createIterator(dummy).next);\n          const SafeIterator = createSafeIterator(createIterator\x2C next);\n          desc.value = function() {\n            return new SafeIterator(this);\n          };\n        }\n        ReflectDefineProperty(safe.prototype\x2C key\x2C { __proto__: null\x2C ...desc });\n      }\n    });\n  } else {\n    copyProps(unsafe.prototype\x2C safe.prototype);\n  }\n  copyProps(unsafe\x2C safe);\n\n  ObjectSetPrototypeOf(safe.prototype\x2C null);\n  ObjectFreeze(safe.prototype);\n  ObjectFreeze(safe);\n  return safe;\n};\nprimordials.makeSafe = makeSafe;\n\n// Subclass the constructors because we need to use their prototype\n// methods later.\n// Defining the `constructor` is necessary here to avoid the default\n// constructor which uses the user-mutable `%ArrayIteratorPrototype%.next`.\nprimordials.SafeMap = makeSafe(\n  Map\x2C\n  class SafeMap extends Map {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\x2C\n);\nprimordials.SafeWeakMap = makeSafe(\n  WeakMap\x2C\n  class SafeWeakMap extends WeakMap {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\x2C\n);\n\nprimordials.SafeSet = makeSafe(\n  Set\x2C\n  class SafeSet extends Set {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\x2C\n);\nprimordials.SafeWeakSet = makeSafe(\n  WeakSet\x2C\n  class SafeWeakSet extends WeakSet {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\x2C\n);\n\nprimordials.SafeFinalizationRegistry = makeSafe(\n  FinalizationRegistry\x2C\n  class SafeFinalizationRegistry extends FinalizationRegistry {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(cleanupCallback) { super(cleanupCallback); }\n  }\x2C\n);\nprimordials.SafeWeakRef = makeSafe(\n  WeakRef\x2C\n  class SafeWeakRef extends WeakRef {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(target) { super(target); }\n  }\x2C\n);\n\nconst SafePromise = makeSafe(\n  Promise\x2C\n  class SafePromise extends Promise {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(executor) { super(executor); }\n  }\x2C\n);\n\n/**\n * Attaches a callback that is invoked when the Promise is settled (fulfilled or\n * rejected). The resolved value cannot be modified from the callback.\n * Prefer using async functions when possible.\n * @param {Promise<any>} thisPromise\n * @param {() => void) | undefined | null} onFinally The callback to execute\n *        when the Promise is settled (fulfilled or rejected).\n * @returns {Promise} A Promise for the completion of the callback.\n */\nprimordials.SafePromisePrototypeFinally = (thisPromise\x2C onFinally) =>\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\n  // prototype to user-land.\n  new Promise((a\x2C b) =>\n    new SafePromise((a\x2C b) => PromisePrototypeThen(thisPromise\x2C a\x2C b))\n      .finally(onFinally)\n      .then(a\x2C b)\x2C\n  );\n\nprimordials.AsyncIteratorPrototype =\n  primordials.ReflectGetPrototypeOf(\n    primordials.ReflectGetPrototypeOf(\n      async function* () {}).prototype);\n\nconst arrayToSafePromiseIterable = (promises\x2C mapFn) =>\n  new primordials.SafeArrayIterator(\n    ArrayPrototypeMap(\n      promises\x2C\n      (promise\x2C i) =>\n        new SafePromise((a\x2C b) => PromisePrototypeThen(mapFn == null ? promise : mapFn(promise\x2C i)\x2C a\x2C b))\x2C\n    )\x2C\n  );\n\n/**\n * @template T\x2CU\n * @param {Array<T | PromiseLike<T>>} promises\n * @param {(v: T|PromiseLike<T>\x2C k: number) => U|PromiseLike<U>} [mapFn]\n * @returns {Promise<Awaited<U>[]>}\n */\nprimordials.SafePromiseAll = (promises\x2C mapFn) =>\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\n  // prototype to user-land.\n  new Promise((a\x2C b) =>\n    SafePromise.all(arrayToSafePromiseIterable(promises\x2C mapFn)).then(a\x2C b)\x2C\n  );\n\n/**\n * Should only be used for internal functions\x2C this would produce similar\n * results as `Promise.all` but without prototype pollution\x2C and the return\n * value is not a genuine Array but an array-like object.\n * @template T\x2CU\n * @param {ArrayLike<T | PromiseLike<T>>} promises\n * @param {(v: T|PromiseLike<T>\x2C k: number) => U|PromiseLike<U>} [mapFn]\n * @returns {Promise<ArrayLike<Awaited<U>>>}\n */\nprimordials.SafePromiseAllReturnArrayLike = (promises\x2C mapFn) =>\n  new Promise((resolve\x2C reject) => {\n    const { length } = promises;\n\n    const returnVal = ArrayConstructor(length);\n    ObjectSetPrototypeOf(returnVal\x2C null);\n    if (length === 0) resolve(returnVal);\n\n    let pendingPromises = length;\n    for (let i = 0; i < length; i++) {\n      const promise = mapFn != null ? mapFn(promises[i]\x2C i) : promises[i];\n      PromisePrototypeThen(PromiseResolve(promise)\x2C (result) => {\n        returnVal[i] = result;\n        if (--pendingPromises === 0) resolve(returnVal);\n      }\x2C reject);\n    }\n  });\n\n/**\n * Should only be used when we only care about waiting for all the promises to\n * resolve\x2C not what value they resolve to.\n * @template T\x2CU\n * @param {ArrayLike<T | PromiseLike<T>>} promises\n * @param {(v: T|PromiseLike<T>\x2C k: number) => U|PromiseLike<U>} [mapFn]\n * @returns {Promise<void>}\n */\nprimordials.SafePromiseAllReturnVoid = (promises\x2C mapFn) =>\n  new Promise((resolve\x2C reject) => {\n    let pendingPromises = promises.length;\n    if (pendingPromises === 0) resolve();\n    for (let i = 0; i < promises.length; i++) {\n      const promise = mapFn != null ? mapFn(promises[i]\x2C i) : promises[i];\n      PromisePrototypeThen(PromiseResolve(promise)\x2C () => {\n        if (--pendingPromises === 0) resolve();\n      }\x2C reject);\n    }\n  });\n\n/**\n * @template T\x2CU\n * @param {Array<T|PromiseLike<T>>} promises\n * @param {(v: T|PromiseLike<T>\x2C k: number) => U|PromiseLike<U>} [mapFn]\n * @returns {Promise<PromiseSettledResult<any>[]>}\n */\nprimordials.SafePromiseAllSettled = (promises\x2C mapFn) =>\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\n  // prototype to user-land.\n  new Promise((a\x2C b) =>\n    SafePromise.allSettled(arrayToSafePromiseIterable(promises\x2C mapFn)).then(a\x2C b)\x2C\n  );\n\n/**\n * Should only be used when we only care about waiting for all the promises to\n * settle\x2C not what value they resolve or reject to.\n * @template T\x2CU\n * @param {ArrayLike<T|PromiseLike<T>>} promises\n * @param {(v: T|PromiseLike<T>\x2C k: number) => U|PromiseLike<U>} [mapFn]\n * @returns {Promise<void>}\n */\nprimordials.SafePromiseAllSettledReturnVoid = async (promises\x2C mapFn) => {\n  await primordials.SafePromiseAllSettled(promises\x2C mapFn);\n};\n\n/**\n * @template T\x2CU\n * @param {Array<T|PromiseLike<T>>} promises\n * @param {(v: T|PromiseLike<T>\x2C k: number) => U|PromiseLike<U>} [mapFn]\n * @returns {Promise<Awaited<U>>}\n */\nprimordials.SafePromiseAny = (promises\x2C mapFn) =>\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\n  // prototype to user-land.\n  new Promise((a\x2C b) =>\n    SafePromise.any(arrayToSafePromiseIterable(promises\x2C mapFn)).then(a\x2C b)\x2C\n  );\n\n/**\n * @template T\x2CU\n * @param {Array<T|PromiseLike<T>>} promises\n * @param {(v: T|PromiseLike<T>\x2C k: number) => U|PromiseLike<U>} [mapFn]\n * @returns {Promise<Awaited<U>>}\n */\nprimordials.SafePromiseRace = (promises\x2C mapFn) =>\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\n  // prototype to user-land.\n  new Promise((a\x2C b) =>\n    SafePromise.race(arrayToSafePromiseIterable(promises\x2C mapFn)).then(a\x2C b)\x2C\n  );\n\n\nconst {\n  exec: OriginalRegExpPrototypeExec\x2C\n  [SymbolMatch]: OriginalRegExpPrototypeSymbolMatch\x2C\n  [SymbolMatchAll]: OriginalRegExpPrototypeSymbolMatchAll\x2C\n  [SymbolReplace]: OriginalRegExpPrototypeSymbolReplace\x2C\n  [SymbolSearch]: OriginalRegExpPrototypeSymbolSearch\x2C\n  [SymbolSplit]: OriginalRegExpPrototypeSymbolSplit\x2C\n} = RegExpPrototype;\n\nclass RegExpLikeForStringSplitting {\n  #regex;\n  constructor() {\n    this.#regex = ReflectConstruct(RegExp\x2C arguments);\n  }\n\n  get lastIndex() {\n    return ReflectGet(this.#regex\x2C 'lastIndex');\n  }\n  set lastIndex(value) {\n    ReflectSet(this.#regex\x2C 'lastIndex'\x2C value);\n  }\n\n  exec() {\n    return ReflectApply(OriginalRegExpPrototypeExec\x2C this.#regex\x2C arguments);\n  }\n}\nObjectSetPrototypeOf(RegExpLikeForStringSplitting.prototype\x2C null);\n\n/**\n * @param {RegExp} pattern\n * @returns {RegExp}\n */\nprimordials.hardenRegExp = function hardenRegExp(pattern) {\n  ObjectDefineProperties(pattern\x2C {\n    [SymbolMatch]: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: OriginalRegExpPrototypeSymbolMatch\x2C\n    }\x2C\n    [SymbolMatchAll]: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: OriginalRegExpPrototypeSymbolMatchAll\x2C\n    }\x2C\n    [SymbolReplace]: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: OriginalRegExpPrototypeSymbolReplace\x2C\n    }\x2C\n    [SymbolSearch]: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: OriginalRegExpPrototypeSymbolSearch\x2C\n    }\x2C\n    [SymbolSplit]: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: OriginalRegExpPrototypeSymbolSplit\x2C\n    }\x2C\n    constructor: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: {\n        [SymbolSpecies]: RegExpLikeForStringSplitting\x2C\n      }\x2C\n    }\x2C\n    dotAll: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: RegExpPrototypeGetDotAll(pattern)\x2C\n    }\x2C\n    exec: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: OriginalRegExpPrototypeExec\x2C\n    }\x2C\n    global: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: RegExpPrototypeGetGlobal(pattern)\x2C\n    }\x2C\n    hasIndices: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: RegExpPrototypeGetHasIndices(pattern)\x2C\n    }\x2C\n    ignoreCase: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: RegExpPrototypeGetIgnoreCase(pattern)\x2C\n    }\x2C\n    multiline: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: RegExpPrototypeGetMultiline(pattern)\x2C\n    }\x2C\n    source: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: RegExpPrototypeGetSource(pattern)\x2C\n    }\x2C\n    sticky: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: RegExpPrototypeGetSticky(pattern)\x2C\n    }\x2C\n    unicode: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: RegExpPrototypeGetUnicode(pattern)\x2C\n    }\x2C\n  });\n  ObjectDefineProperty(pattern\x2C 'flags'\x2C {\n    __proto__: null\x2C\n    configurable: true\x2C\n    value: RegExpPrototypeGetFlags(pattern)\x2C\n  });\n  return pattern;\n};\n\n\n/**\n * @param {string} str\n * @param {RegExp} regexp\n * @returns {number}\n */\nprimordials.SafeStringPrototypeSearch = (str\x2C regexp) => {\n  regexp.lastIndex = 0;\n  const match = RegExpPrototypeExec(regexp\x2C str);\n  return match ? match.index : -1;\n};\n\nObjectSetPrototypeOf(primordials\x2C null);\nObjectFreeze(primordials);\n
code-source-info,0x1125844c0,6,11975,11992,,,
code-creation,JS,11,44632,0x112584640,556,getOptionValue node:internal/options:44:24,0x31e647c44978,^
code-source-info,0x112584640,17,985,1228,,,
code-creation,JS,11,44651,0x112584880,132,exposeLazyInterfaces node:internal/util:683:30,0x31e647c43c08,^
code-source-info,0x112584880,16,18531,18602,,,
tick,0x7ff8092271f2,44703,0,0x0,0,0x10c9f09d0,0x31e647c43c84,0x31e6f6b4c47e,0x31e63e0bd356,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,44784,0x31e6f6b5131e,70,setupCustomEvent node:internal/process/pre_execution:410:26,0x31e647c799d0,~
code-source-info,0x31e6f6b5131e,67,12648,12900,C0O12655C5O12659C9O12679C17O12706C23O12706C29O12768C30O12775C31O12806C37O12806C42O12790C47O12842C54O12858C63O12842C69O12899,,
code-creation,JS,10,44847,0x31e6f6b514ee,64,setupCodeCoverage node:internal/process/pre_execution:395:27,0x31e647c79980,~
code-source-info,0x31e6f6b514ee,67,12022,12517,C0O12328C3O12340C8O12344C16O12371C22O12371C28O12425C31O12433C38O12462C44O12489C49O12493C54O12462C58O12454C63O12516,,
code-creation,JS,10,44892,0x31e6f6b516ce,75,setupDebugEnv node:internal/process/pre_execution:441:23,0x31e647c79ae8,~
code-source-info,0x31e6f6b516ce,67,13402,13611,C0O13409C6O13409C11O13442C19O13470C24O13474C29O13443C34O13489C42O13493C48O13537C54O13537C59O13572C64O13586C69O13587C74O13610,,
code-creation,JS,10,44972,0x31e6f6b51a36,153,initializeDebugEnv node:internal/util/debuglog:21:28,0x31e647c4a450,~
script-source,22,node:internal/util/debuglog,'use strict';\n\nconst {\n  ObjectDefineProperty\x2C\n  RegExp\x2C\n  RegExpPrototypeExec\x2C\n  SafeArrayIterator\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeToUpperCase\x2C\n} = primordials;\n\nconst { inspect\x2C format\x2C formatWithOptions } = require('internal/util/inspect');\n\n// `debugImpls` and `testEnabled` are deliberately not initialized so any call\n// to `debuglog()` before `initializeDebugEnv()` is called will throw.\nlet debugImpls;\nlet testEnabled;\n\n\n// `debugEnv` is initial value of process.env.NODE_DEBUG\nfunction initializeDebugEnv(debugEnv) {\n  debugImpls = { __proto__: null };\n  if (debugEnv) {\n    // This is run before any user code\x2C it's OK not to use primordials.\n    debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g\x2C '\\\\$&')\n      .replaceAll('*'\x2C '.*')\n      .replaceAll('\x2C'\x2C '$|^');\n    const debugEnvRegex = new RegExp(`^${debugEnv}$`\x2C 'i');\n    testEnabled = (str) => RegExpPrototypeExec(debugEnvRegex\x2C str) !== null;\n  } else {\n    testEnabled = () => false;\n  }\n}\n\n// Emits warning when user sets\n// NODE_DEBUG=http or NODE_DEBUG=http2.\nfunction emitWarningIfNeeded(set) {\n  if ('HTTP' === set || 'HTTP2' === set) {\n    process.emitWarning('Setting the NODE_DEBUG environment variable ' +\n      'to \\'' + StringPrototypeToLowerCase(set) + '\\' can expose sensitive ' +\n      'data (such as passwords\x2C tokens and authentication headers) ' +\n      'in the resulting log.');\n  }\n}\n\nconst noop = () => {};\n\nlet utilColors;\nfunction lazyUtilColors() {\n  utilColors ??= require('internal/util/colors');\n  return utilColors;\n}\n\nfunction debuglogImpl(enabled\x2C set) {\n  if (debugImpls[set] === undefined) {\n    if (enabled) {\n      const pid = process.pid;\n      emitWarningIfNeeded(set);\n      debugImpls[set] = function debug(...args) {\n        const colors = lazyUtilColors().shouldColorize(process.stderr);\n        const msg = formatWithOptions({ colors }\x2C ...args);\n        const coloredPID = inspect(pid\x2C { colors });\n        process.stderr.write(format('%s %s: %s\\n'\x2C set\x2C coloredPID\x2C msg));\n      };\n    } else {\n      debugImpls[set] = noop;\n    }\n  }\n  return debugImpls[set];\n}\n\n// debuglogImpl depends on process.pid and process.env.NODE_DEBUG\x2C\n// so it needs to be called lazily in top scopes of internal modules\n// that may be loaded before these run time states are allowed to\n// be accessed.\nfunction debuglog(set\x2C cb) {\n  function init() {\n    set = StringPrototypeToUpperCase(set);\n    enabled = testEnabled(set);\n  }\n  let debug = (...args) => {\n    init();\n    // Only invokes debuglogImpl() when the debug function is\n    // called for the first time.\n    debug = debuglogImpl(enabled\x2C set);\n    if (typeof cb === 'function')\n      cb(debug);\n    switch (args.length) {\n      case 1: return debug(args[0]);\n      case 2: return debug(args[0]\x2C args[1]);\n      default: return debug(...new SafeArrayIterator(args));\n    }\n  };\n  let enabled;\n  let test = () => {\n    init();\n    test = () => enabled;\n    return enabled;\n  };\n  const logger = (...args) => {\n    switch (args.length) {\n      case 1: return debug(args[0]);\n      case 2: return debug(args[0]\x2C args[1]);\n      default: return debug(...new SafeArrayIterator(args));\n    }\n  };\n  ObjectDefineProperty(logger\x2C 'enabled'\x2C {\n    __proto__: null\x2C\n    get() {\n      return test();\n    }\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n  });\n  return logger;\n}\n\nmodule.exports = {\n  debuglog\x2C\n  initializeDebugEnv\x2C\n};\n
code-source-info,0x31e6f6b51a36,22,530,976,C0O545C7O556C13O581C24O694C38O694C45O738C56O739C63O767C74O768C82O818C94O833C110O818C115O818C117O856C126O868C138O944C145O956C152O975,,
code-creation,JS,10,45211,0x31e6f6b520ce,31,initializeReport node:internal/process/pre_execution:429:26,0x31e647c79a70,~
code-source-info,0x31e6f6b520ce,67,13154,13378,C0O13161C11O13182C16O13274C24O13161C30O13377,,
code-creation,JS,10,45314,0x31e6f6b5291e,557,initializePermission node:internal/process/pre_execution:594:30,0x31e647c79d90,~
code-source-info,0x31e6f6b5291e,67,18459,20313,C0O18497C8O18497C13O18544C15O18578C22O18594C26O18689C29O18697C41O18697C47O18824C53O18824C58O18810C63O18815C68O18886C73O18973C90O18965C120O18965C123O18992C129O18996C135O19028C139O19036C151O19071C166O19114C175O19036C181O18954C253O19230C258O19313C275O19305C305O19305C308O19351C314O19351C319O19389C327O19396C333O19410C338O19414C348O19414C355O19439C359O19447C371O19477C386O19507C393O19580C400O19623C409O19447C415O19294C487O19751C498O19772C504O19884C512O19894C518O19907C528O19751C535O19978C540O20097C545O20119C550O20097C556O20312,,
code-creation,JS,10,45377,0x31e6f6b52d46,34, node:internal/process/pre_execution:647:53,0x31e6f6b525d8,~
code-source-info,0x31e6f6b52d46,67,20145,20305,C0O20177C5O20177C10O20215C16O20233C26O20239C31O20233C33O20304,,
code-creation,JS,10,45417,0x31e6f6b52f16,35,initializeSourceMapsHandlers node:internal/process/pre_execution:728:38,0x31e647c79f08,~
code-source-info,0x31e6f6b52f16,67,22881,23042,C0O22928C6O22928C11O22900C16O22979C18O23000C24O23000C29O22979C34O23041,,
code-creation,JS,10,45481,0x31e6f6b530c6,94,setSourceMapsEnabled node:internal/source_map/source_map_cache:52:30,0x31e647c5cbc8,~
script-source,38,node:internal/source_map/source_map_cache,'use strict';\n\nconst {\n  ArrayPrototypeMap\x2C\n  JSONParse\x2C\n  ObjectKeys\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeSymbolSplit\x2C\n  SafeMap\x2C\n  StringPrototypeSplit\x2C\n} = primordials;\n\n// See https://sourcemaps.info/spec.html for SourceMap V3 specification.\nconst { Buffer } = require('buffer');\nlet debug = require('internal/util/debuglog').debuglog('source_map'\x2C (fn) => {\n  debug = fn;\n});\n\nconst { validateBoolean } = require('internal/validators');\nconst {\n  setSourceMapsEnabled: setSourceMapsNative\x2C\n  setPrepareStackTraceCallback\x2C\n} = internalBinding('errors');\nconst { getLazy } = require('internal/util');\n\n// Since the CJS module cache is mutable\x2C which leads to memory leaks when\n// modules are deleted\x2C we use a WeakMap so that the source map cache will\n// be purged automatically:\nconst getCjsSourceMapCache = getLazy(() => {\n  const { IterableWeakMap } = require('internal/util/iterable_weak_map');\n  return new IterableWeakMap();\n});\n\n// The esm cache is not mutable\x2C so we can use a Map without memory concerns:\nconst esmSourceMapCache = new SafeMap();\n// The generated sources is not mutable\x2C so we can use a Map without memory concerns:\nconst generatedSourceMapCache = new SafeMap();\nconst kLeadingProtocol = /^\\w+:\\/\\//;\nconst kSourceMappingURLMagicComment = /\\/[*/]#\\s+sourceMappingURL=(?<sourceMappingURL>[^\\s]+)/g;\nconst kSourceURLMagicComment = /\\/[*/]#\\s+sourceURL=(?<sourceURL>[^\\s]+)/g;\n\nconst { fileURLToPath\x2C pathToFileURL\x2C URL } = require('internal/url');\n\nlet SourceMap;\n\n// This is configured with --enable-source-maps during pre-execution.\nlet sourceMapsEnabled = false;\nfunction getSourceMapsEnabled() {\n  return sourceMapsEnabled;\n}\n\nfunction setSourceMapsEnabled(val) {\n  validateBoolean(val\x2C 'val');\n\n  setSourceMapsNative(val);\n  if (val) {\n    const {\n      prepareStackTrace\x2C\n    } = require('internal/source_map/prepare_stack_trace');\n    setPrepareStackTraceCallback(prepareStackTrace);\n  } else if (sourceMapsEnabled !== undefined) {\n    // Reset prepare stack trace callback only when disabling source maps.\n    const {\n      prepareStackTrace\x2C\n    } = require('internal/errors');\n    setPrepareStackTraceCallback(prepareStackTrace);\n  }\n\n  sourceMapsEnabled = val;\n}\n\nfunction extractSourceURLMagicComment(content) {\n  let match;\n  let matchSourceURL;\n  // A while loop is used here to get the last occurrence of sourceURL.\n  // This is needed so that we don't match sourceURL in string literals.\n  while ((match = RegExpPrototypeExec(kSourceURLMagicComment\x2C content))) {\n    matchSourceURL = match;\n  }\n  if (matchSourceURL == null) {\n    return null;\n  }\n  let sourceURL = matchSourceURL.groups.sourceURL;\n  if (sourceURL != null && RegExpPrototypeExec(kLeadingProtocol\x2C sourceURL) === null) {\n    sourceURL = pathToFileURL(sourceURL).href;\n  }\n  return sourceURL;\n}\n\nfunction extractSourceMapURLMagicComment(content) {\n  let match;\n  let lastMatch;\n  // A while loop is used here to get the last occurrence of sourceMappingURL.\n  // This is needed so that we don't match sourceMappingURL in string literals.\n  while ((match = RegExpPrototypeExec(kSourceMappingURLMagicComment\x2C content))) {\n    lastMatch = match;\n  }\n  if (lastMatch == null) {\n    return null;\n  }\n  return lastMatch.groups.sourceMappingURL;\n}\n\nfunction maybeCacheSourceMap(filename\x2C content\x2C cjsModuleInstance\x2C isGeneratedSource\x2C sourceURL\x2C sourceMapURL) {\n  const sourceMapsEnabled = getSourceMapsEnabled();\n  if (!(process.env.NODE_V8_COVERAGE || sourceMapsEnabled)) return;\n  try {\n    const { normalizeReferrerURL } = require('internal/modules/helpers');\n    filename = normalizeReferrerURL(filename);\n  } catch (err) {\n    // This is most likely an invalid filename in sourceURL of [eval]-wrapper.\n    debug(err);\n    return;\n  }\n\n  if (sourceMapURL === undefined) {\n    sourceMapURL = extractSourceMapURLMagicComment(content);\n  }\n\n  // Bail out when there is no source map url.\n  if (typeof sourceMapURL !== 'string') {\n    return;\n  }\n\n  if (sourceURL === undefined) {\n    sourceURL = extractSourceURLMagicComment(content);\n  }\n\n  const data = dataFromUrl(filename\x2C sourceMapURL);\n  const url = data ? null : sourceMapURL;\n  if (cjsModuleInstance) {\n    getCjsSourceMapCache().set(cjsModuleInstance\x2C {\n      __proto__: null\x2C\n      filename\x2C\n      lineLengths: lineLengths(content)\x2C\n      data\x2C\n      url\x2C\n      sourceURL\x2C\n    });\n  } else if (isGeneratedSource) {\n    const entry = {\n      __proto__: null\x2C\n      lineLengths: lineLengths(content)\x2C\n      data\x2C\n      url\x2C\n      sourceURL\x2C\n    };\n    generatedSourceMapCache.set(filename\x2C entry);\n    if (sourceURL) {\n      generatedSourceMapCache.set(sourceURL\x2C entry);\n    }\n  } else {\n    // If there is no cjsModuleInstance and is not generated source assume we are in a\n    // "modules/esm" context.\n    const entry = {\n      __proto__: null\x2C\n      lineLengths: lineLengths(content)\x2C\n      data\x2C\n      url\x2C\n      sourceURL\x2C\n    };\n    esmSourceMapCache.set(filename\x2C entry);\n    if (sourceURL) {\n      esmSourceMapCache.set(sourceURL\x2C entry);\n    }\n  }\n}\n\nfunction maybeCacheGeneratedSourceMap(content) {\n  const sourceMapsEnabled = getSourceMapsEnabled();\n  if (!(process.env.NODE_V8_COVERAGE || sourceMapsEnabled)) return;\n\n  const sourceURL = extractSourceURLMagicComment(content);\n  if (sourceURL === null) {\n    return;\n  }\n  try {\n    maybeCacheSourceMap(sourceURL\x2C content\x2C null\x2C true\x2C sourceURL);\n  } catch (err) {\n    // This can happen if the filename is not a valid URL.\n    // If we fail to cache the source map\x2C we should not fail the whole process.\n    debug(err);\n  }\n}\n\nfunction dataFromUrl(sourceURL\x2C sourceMappingURL) {\n  try {\n    const url = new URL(sourceMappingURL);\n    switch (url.protocol) {\n      case 'data:':\n        return sourceMapFromDataUrl(sourceURL\x2C url.pathname);\n      default:\n        debug(`unknown protocol ${url.protocol}`);\n        return null;\n    }\n  } catch (err) {\n    debug(err);\n    // If no scheme is present\x2C we assume we are dealing with a file path.\n    const mapURL = new URL(sourceMappingURL\x2C sourceURL).href;\n    return sourceMapFromFile(mapURL);\n  }\n}\n\n// Cache the length of each line in the file that a source map was extracted\n// from. This allows translation from byte offset V8 coverage reports\x2C\n// to line/column offset Source Map V3.\nfunction lineLengths(content) {\n  // We purposefully keep \\r as part of the line-length calculation\x2C in\n  // cases where there is a \\r\\n separator\x2C so that this can be taken into\n  // account in coverage calculations.\n  return ArrayPrototypeMap(RegExpPrototypeSymbolSplit(/\\n|\\u2028|\\u2029/\x2C content)\x2C (line) => {\n    return line.length;\n  });\n}\n\nfunction sourceMapFromFile(mapURL) {\n  try {\n    const fs = require('fs');\n    const content = fs.readFileSync(fileURLToPath(mapURL)\x2C 'utf8');\n    const data = JSONParse(content);\n    return sourcesToAbsolute(mapURL\x2C data);\n  } catch (err) {\n    debug(err);\n    return null;\n  }\n}\n\n// data:[<mediatype>][;base64]\x2C<data> see:\n// https://tools.ietf.org/html/rfc2397#section-2\nfunction sourceMapFromDataUrl(sourceURL\x2C url) {\n  const { 0: format\x2C 1: data } = StringPrototypeSplit(url\x2C '\x2C');\n  const splitFormat = StringPrototypeSplit(format\x2C ';');\n  const contentType = splitFormat[0];\n  const base64 = splitFormat[splitFormat.length - 1] === 'base64';\n  if (contentType === 'application/json') {\n    const decodedData = base64 ?\n      Buffer.from(data\x2C 'base64').toString('utf8') : data;\n    try {\n      const parsedData = JSONParse(decodedData);\n      return sourcesToAbsolute(sourceURL\x2C parsedData);\n    } catch (err) {\n      debug(err);\n      return null;\n    }\n  } else {\n    debug(`unknown content-type ${contentType}`);\n    return null;\n  }\n}\n\n// If the sources are not absolute URLs after prepending of the "sourceRoot"\x2C\n// the sources are resolved relative to the SourceMap (like resolving script\n// src in a html document).\nfunction sourcesToAbsolute(baseURL\x2C data) {\n  data.sources = data.sources.map((source) => {\n    source = (data.sourceRoot || '') + source;\n    return new URL(source\x2C baseURL).href;\n  });\n  // The sources array is now resolved to absolute URLs\x2C sourceRoot should\n  // be updated to noop.\n  data.sourceRoot = '';\n  return data;\n}\n\n// WARNING: The `sourceMapCacheToObject` and `appendCJSCache` run during\n// shutdown. In particular\x2C they also run when Workers are terminated\x2C making\n// it important that they do not call out to any user-provided code\x2C including\n// built-in prototypes that might have been tampered with.\n\n// Get serialized representation of source-map cache\x2C this is used\n// to persist a cache of source-maps to disk when NODE_V8_COVERAGE is enabled.\nfunction sourceMapCacheToObject() {\n  const obj = { __proto__: null };\n\n  for (const { 0: k\x2C 1: v } of esmSourceMapCache) {\n    obj[k] = v;\n  }\n\n  appendCJSCache(obj);\n\n  if (ObjectKeys(obj).length === 0) {\n    return undefined;\n  }\n  return obj;\n}\n\nfunction appendCJSCache(obj) {\n  for (const value of getCjsSourceMapCache()) {\n    obj[value.filename] = {\n      __proto__: null\x2C\n      lineLengths: value.lineLengths\x2C\n      data: value.data\x2C\n      url: value.url\x2C\n    };\n  }\n}\n\nfunction findSourceMap(sourceURL) {\n  if (RegExpPrototypeExec(kLeadingProtocol\x2C sourceURL) === null) {\n    sourceURL = pathToFileURL(sourceURL).href;\n  }\n  if (!SourceMap) {\n    SourceMap = require('internal/source_map/source_map').SourceMap;\n  }\n  let entry = esmSourceMapCache.get(sourceURL) ?? generatedSourceMapCache.get(sourceURL);\n  if (entry === undefined) {\n    for (const value of getCjsSourceMapCache()) {\n      const filename = value.filename;\n      const cachedSourceURL = value.sourceURL;\n      if (sourceURL === filename || sourceURL === cachedSourceURL) {\n        entry = value;\n      }\n    }\n  }\n  if (entry === undefined) {\n    return undefined;\n  }\n  let sourceMap = entry.sourceMap;\n  if (sourceMap === undefined) {\n    sourceMap = new SourceMap(entry.data\x2C { lineLengths: entry.lineLengths });\n    entry.sourceMap = sourceMap;\n  }\n  return sourceMap;\n}\n\nmodule.exports = {\n  findSourceMap\x2C\n  getSourceMapsEnabled\x2C\n  setSourceMapsEnabled\x2C\n  maybeCacheSourceMap\x2C\n  maybeCacheGeneratedSourceMap\x2C\n  sourceMapCacheToObject\x2C\n};\n
code-source-info,0x31e6f6b530c6,38,1690,2203,C0O1700C8O1700C13O1732C18O1732C22O1760C26O1816C32O1816C37O1789C42O1872C47O1872C53O1930C59O2089C65O2089C70O2062C75O2121C80O2121C84O2177C86O2195C93O2202,,
tick,0x7ff809303900,46185,0,0x0,3,0x10c9f09d0,0x31e6f6b52f33,0x31e63e0bd37a,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,46223,0x31e6f6b53cae,30,validateBoolean node:internal/validators:216:25,0x31e6931bf4d8,~
script-source,15,node:internal/validators,/* eslint jsdoc/require-jsdoc: "error" */\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  NumberIsInteger\x2C\n  NumberIsNaN\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  NumberMIN_SAFE_INTEGER\x2C\n  NumberParseInt\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExpPrototypeExec\x2C\n  String\x2C\n  StringPrototypeToUpperCase\x2C\n  StringPrototypeTrim\x2C\n} = primordials;\n\nconst {\n  hideStackFrames\x2C\n  codes: {\n    ERR_SOCKET_BAD_PORT\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNKNOWN_SIGNAL\x2C\n  }\x2C\n} = require('internal/errors');\nconst { normalizeEncoding } = require('internal/util');\nconst {\n  isAsyncFunction\x2C\n  isArrayBufferView\x2C\n} = require('internal/util/types');\nconst { signals } = internalBinding('constants').os;\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nfunction isInt32(value) {\n  return value === (value | 0);\n}\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nfunction isUint32(value) {\n  return value === (value >>> 0);\n}\n\nconst octalReg = /^[0-7]+$/;\nconst modeDesc = 'must be a 32-bit unsigned integer or an octal string';\n\n/**\n * Parse and validate values that will be converted into mode_t (the S_*\n * constants). Only valid numbers and octal strings are allowed. They could be\n * converted to 32-bit unsigned integers or non-negative signed integers in the\n * C++ land\x2C but any value higher than 0o777 will result in platform-specific\n * behaviors.\n * @param {*} value Values to be validated\n * @param {string} name Name of the argument\n * @param {number} [def] If specified\x2C will be returned for invalid values\n * @returns {number}\n */\nfunction parseFileMode(value\x2C name\x2C def) {\n  value ??= def;\n  if (typeof value === 'string') {\n    if (RegExpPrototypeExec(octalReg\x2C value) === null) {\n      throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C modeDesc);\n    }\n    value = NumberParseInt(value\x2C 8);\n  }\n\n  validateUint32(value\x2C name);\n  return value;\n}\n\n/**\n * @callback validateInteger\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateInteger} */\nconst validateInteger = hideStackFrames(\n  (value\x2C name\x2C min = NumberMIN_SAFE_INTEGER\x2C max = NumberMAX_SAFE_INTEGER) => {\n    if (typeof value !== 'number')\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n    if (!NumberIsInteger(value))\n      throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n    if (value < min || value > max)\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n  }\x2C\n);\n\n/**\n * @callback validateInt32\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateInt32} */\nconst validateInt32 = hideStackFrames(\n  (value\x2C name\x2C min = -2147483648\x2C max = 2147483647) => {\n    // The defaults for min and max correspond to the limits of 32-bit integers.\n    if (typeof value !== 'number') {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n    }\n    if (!NumberIsInteger(value)) {\n      throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n    }\n    if (value < min || value > max) {\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n    }\n  }\x2C\n);\n\n/**\n * @callback validateUint32\n * @param {*} value\n * @param {string} name\n * @param {number|boolean} [positive=false]\n * @returns {asserts value is number}\n */\n\n/** @type {validateUint32} */\nconst validateUint32 = hideStackFrames((value\x2C name\x2C positive = false) => {\n  if (typeof value !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n  }\n  if (!NumberIsInteger(value)) {\n    throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n  }\n  const min = positive ? 1 : 0;\n  // 2 ** 32 === 4294967296\n  const max = 4_294_967_295;\n  if (value < min || value > max) {\n    throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n  }\n});\n\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */\n\n/** @type {validateString} */\nfunction validateString(value\x2C name) {\n  if (typeof value !== 'string')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'string'\x2C value);\n}\n\n/**\n * @callback validateNumber\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateNumber} */\nfunction validateNumber(value\x2C name\x2C min = undefined\x2C max) {\n  if (typeof value !== 'number')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n\n  if ((min != null && value < min) || (max != null && value > max) ||\n    ((min != null || max != null) && NumberIsNaN(value))) {\n    throw new ERR_OUT_OF_RANGE(\n      name\x2C\n      `${min != null ? `>= ${min}` : ''}${min != null && max != null ? ' && ' : ''}${max != null ? `<= ${max}` : ''}`\x2C\n      value);\n  }\n}\n\n/**\n * @callback validateOneOf\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} oneOf\n */\n\n/** @type {validateOneOf} */\nconst validateOneOf = hideStackFrames((value\x2C name\x2C oneOf) => {\n  if (!ArrayPrototypeIncludes(oneOf\x2C value)) {\n    const allowed = ArrayPrototypeJoin(\n      ArrayPrototypeMap(oneOf\x2C (v) =>\n        (typeof v === 'string' ? `'${v}'` : String(v)))\x2C\n      '\x2C ');\n    const reason = 'must be one of: ' + allowed;\n    throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C reason);\n  }\n});\n\n/**\n * @callback validateBoolean\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean}\n */\n\n/** @type {validateBoolean} */\nfunction validateBoolean(value\x2C name) {\n  if (typeof value !== 'boolean')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'boolean'\x2C value);\n}\n\nconst kValidateObjectNone = 0;\nconst kValidateObjectAllowNullable = 1 << 0;\nconst kValidateObjectAllowArray = 1 << 1;\nconst kValidateObjectAllowFunction = 1 << 2;\n\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {number} [options]\n */\n\n/** @type {validateObject} */\nconst validateObject = hideStackFrames(\n  (value\x2C name\x2C options = kValidateObjectNone) => {\n    if (options === kValidateObjectNone) {\n      if (value === null || ArrayIsArray(value)) {\n        throw new ERR_INVALID_ARG_TYPE(name\x2C 'Object'\x2C value);\n      }\n\n      if (typeof value !== 'object') {\n        throw new ERR_INVALID_ARG_TYPE(name\x2C 'Object'\x2C value);\n      }\n    } else {\n      const throwOnNullable = (kValidateObjectAllowNullable & options) === 0;\n\n      if (throwOnNullable && value === null) {\n        throw new ERR_INVALID_ARG_TYPE(name\x2C 'Object'\x2C value);\n      }\n\n      const throwOnArray = (kValidateObjectAllowArray & options) === 0;\n\n      if (throwOnArray && ArrayIsArray(value)) {\n        throw new ERR_INVALID_ARG_TYPE(name\x2C 'Object'\x2C value);\n      }\n\n      const throwOnFunction = (kValidateObjectAllowFunction & options) === 0;\n      const typeofValue = typeof value;\n\n      if (typeofValue !== 'object' && (throwOnFunction || typeofValue !== 'function')) {\n        throw new ERR_INVALID_ARG_TYPE(name\x2C 'Object'\x2C value);\n      }\n    }\n  });\n\n/**\n * @callback validateDictionary - We are using the Web IDL Standard definition\n *                                of "dictionary" here\x2C which means any value\n *                                whose Type is either Undefined\x2C Null\x2C or\n *                                Object (which includes functions).\n * @param {*} value\n * @param {string} name\n * @see https://webidl.spec.whatwg.org/#es-dictionary\n * @see https://tc39.es/ecma262/#table-typeof-operator-results\n */\n\n/** @type {validateDictionary} */\nconst validateDictionary = hideStackFrames(\n  (value\x2C name) => {\n    if (value != null && typeof value !== 'object' && typeof value !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'a dictionary'\x2C value);\n    }\n  });\n\n/**\n * @callback validateArray\n * @param {*} value\n * @param {string} name\n * @param {number} [minLength]\n * @returns {asserts value is any[]}\n */\n\n/** @type {validateArray} */\nconst validateArray = hideStackFrames((value\x2C name\x2C minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Array'\x2C value);\n  }\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C reason);\n  }\n});\n\n/**\n * @callback validateStringArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string[]}\n */\n\n/** @type {validateStringArray} */\nfunction validateStringArray(value\x2C name) {\n  validateArray(value\x2C name);\n  for (let i = 0; i < value.length; ++i) {\n    // Don't use validateString here for performance reasons\x2C as\n    // we would generate intermediate strings for the name.\n    if (typeof value[i] !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE(`${name}[${i}]`\x2C 'string'\x2C value[i]);\n    }\n  }\n}\n\n/**\n * @callback validateBooleanArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean[]}\n */\n\n/** @type {validateBooleanArray} */\nfunction validateBooleanArray(value\x2C name) {\n  validateArray(value\x2C name);\n  for (let i = 0; i < value.length; ++i) {\n    // Don't use validateBoolean here for performance reasons\x2C as\n    // we would generate intermediate strings for the name.\n    if (value[i] !== true && value[i] !== false) {\n      throw new ERR_INVALID_ARG_TYPE(`${name}[${i}]`\x2C 'boolean'\x2C value[i]);\n    }\n  }\n}\n\n/**\n * @callback validateAbortSignalArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is AbortSignal[]}\n */\n\n/** @type {validateAbortSignalArray} */\nfunction validateAbortSignalArray(value\x2C name) {\n  validateArray(value\x2C name);\n  for (let i = 0; i < value.length; i++) {\n    const signal = value[i];\n    const indexedName = `${name}[${i}]`;\n    if (signal == null) {\n      throw new ERR_INVALID_ARG_TYPE(indexedName\x2C 'AbortSignal'\x2C signal);\n    }\n    validateAbortSignal(signal\x2C indexedName);\n  }\n}\n\n/**\n * @param {*} signal\n * @param {string} [name='signal']\n * @returns {asserts signal is keyof signals}\n */\nfunction validateSignalName(signal\x2C name = 'signal') {\n  validateString(signal\x2C name);\n\n  if (signals[signal] === undefined) {\n    if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {\n      throw new ERR_UNKNOWN_SIGNAL(signal +\n                                   ' (signals must use all capital letters)');\n    }\n\n    throw new ERR_UNKNOWN_SIGNAL(signal);\n  }\n}\n\n/**\n * @callback validateBuffer\n * @param {*} buffer\n * @param {string} [name='buffer']\n * @returns {asserts buffer is ArrayBufferView}\n */\n\n/** @type {validateBuffer} */\nconst validateBuffer = hideStackFrames((buffer\x2C name = 'buffer') => {\n  if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C\n                                   ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n                                   buffer);\n  }\n});\n\n/**\n * @param {string} data\n * @param {string} encoding\n */\nfunction validateEncoding(data\x2C encoding) {\n  const normalizedEncoding = normalizeEncoding(encoding);\n  const length = data.length;\n\n  if (normalizedEncoding === 'hex' && length % 2 !== 0) {\n    throw new ERR_INVALID_ARG_VALUE('encoding'\x2C encoding\x2C\n                                    `is invalid for data of length ${length}`);\n  }\n}\n\n/**\n * Check that the port number is not NaN when coerced to a number\x2C\n * is an integer and that it falls within the legal range of port numbers.\n * @param {*} port\n * @param {string} [name='Port']\n * @param {boolean} [allowZero=true]\n * @returns {number}\n */\nfunction validatePort(port\x2C name = 'Port'\x2C allowZero = true) {\n  if ((typeof port !== 'number' && typeof port !== 'string') ||\n      (typeof port === 'string' && StringPrototypeTrim(port).length === 0) ||\n      +port !== (+port >>> 0) ||\n      port > 0xFFFF ||\n      (port === 0 && !allowZero)) {\n    throw new ERR_SOCKET_BAD_PORT(name\x2C port\x2C allowZero);\n  }\n  return port | 0;\n}\n\n/**\n * @callback validateAbortSignal\n * @param {*} signal\n * @param {string} name\n */\n\n/** @type {validateAbortSignal} */\nconst validateAbortSignal = hideStackFrames((signal\x2C name) => {\n  if (signal !== undefined &&\n      (signal === null ||\n       typeof signal !== 'object' ||\n       !('aborted' in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'AbortSignal'\x2C signal);\n  }\n});\n\n/**\n * @callback validateFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validateFunction} */\nconst validateFunction = hideStackFrames((value\x2C name) => {\n  if (typeof value !== 'function')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Function'\x2C value);\n});\n\n/**\n * @callback validatePlainFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validatePlainFunction} */\nconst validatePlainFunction = hideStackFrames((value\x2C name) => {\n  if (typeof value !== 'function' || isAsyncFunction(value))\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Function'\x2C value);\n});\n\n/**\n * @callback validateUndefined\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is undefined}\n */\n\n/** @type {validateUndefined} */\nconst validateUndefined = hideStackFrames((value\x2C name) => {\n  if (value !== undefined)\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'undefined'\x2C value);\n});\n\n/**\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} union\n */\nfunction validateUnion(value\x2C name\x2C union) {\n  if (!ArrayPrototypeIncludes(union\x2C value)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C `('${ArrayPrototypeJoin(union\x2C '|')}')`\x2C value);\n  }\n}\n\n/*\n  The rules for the Link header field are described here:\n  https://www.rfc-editor.org/rfc/rfc8288.html#section-3\n\n  This regex validates any string surrounded by angle brackets\n  (not necessarily a valid URI reference) followed by zero or more\n  link-params separated by semicolons.\n*/\nconst linkValueRegExp = /^(?:<[^>]*>)(?:\\s*;\\s*[^;"\\s]+(?:=(")?[^;"\\s]*\\1)?)*$/;\n\n/**\n * @param {any} value\n * @param {string} name\n */\nfunction validateLinkHeaderFormat(value\x2C name) {\n  if (\n    typeof value === 'undefined' ||\n    !RegExpPrototypeExec(linkValueRegExp\x2C value)\n  ) {\n    throw new ERR_INVALID_ARG_VALUE(\n      name\x2C\n      value\x2C\n      'must be an array or string of format "</styles.css>; rel=preload; as=style"'\x2C\n    );\n  }\n}\n\nconst validateInternalField = hideStackFrames((object\x2C fieldKey\x2C className) => {\n  if (typeof object !== 'object' || object === null || !ObjectPrototypeHasOwnProperty(object\x2C fieldKey)) {\n    throw new ERR_INVALID_ARG_TYPE('this'\x2C className\x2C object);\n  }\n});\n\n/**\n * @param {any} hints\n * @return {string}\n */\nfunction validateLinkHeaderValue(hints) {\n  if (typeof hints === 'string') {\n    validateLinkHeaderFormat(hints\x2C 'hints');\n    return hints;\n  } else if (ArrayIsArray(hints)) {\n    const hintsLength = hints.length;\n    let result = '';\n\n    if (hintsLength === 0) {\n      return result;\n    }\n\n    for (let i = 0; i < hintsLength; i++) {\n      const link = hints[i];\n      validateLinkHeaderFormat(link\x2C 'hints');\n      result += link;\n\n      if (i !== hintsLength - 1) {\n        result += '\x2C ';\n      }\n    }\n\n    return result;\n  }\n\n  throw new ERR_INVALID_ARG_VALUE(\n    'hints'\x2C\n    hints\x2C\n    'must be an array or string of format "</styles.css>; rel=preload; as=style"'\x2C\n  );\n}\n\nmodule.exports = {\n  isInt32\x2C\n  isUint32\x2C\n  parseFileMode\x2C\n  validateArray\x2C\n  validateStringArray\x2C\n  validateBooleanArray\x2C\n  validateAbortSignalArray\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateDictionary\x2C\n  validateEncoding\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateInteger\x2C\n  validateNumber\x2C\n  validateObject\x2C\n  kValidateObjectNone\x2C\n  kValidateObjectAllowNullable\x2C\n  kValidateObjectAllowArray\x2C\n  kValidateObjectAllowFunction\x2C\n  validateOneOf\x2C\n  validatePlainFunction\x2C\n  validatePort\x2C\n  validateSignalName\x2C\n  validateString\x2C\n  validateUint32\x2C\n  validateUndefined\x2C\n  validateUnion\x2C\n  validateAbortSignal\x2C\n  validateLinkHeaderValue\x2C\n  validateInternalField\x2C\n};\n
code-source-info,0x31e6f6b53cae,15,5595,5706,C0O5613C6O5649C22O5655C27O5649C29O5705,,
tick,0x7ff809303b0d,47324,0,0x0,3,0x10c9f09d0,0x31e6f6b530ce,0x31e6f6b52f33,0x31e63e0bd37a,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,47374,0x31e6f6b5552e,348,initializeDeprecations node:internal/process/pre_execution:505:32,0x31e647c79ca0,~
code-source-info,0x31e6f6b5552e,67,15668,17589,C0O15697C6O15697C11O15683C16O15752C24O15752C29O15943C35O15943C40O15984C46O15984C51O16037C73O16029C101O16029C104O16355C112O16375C116O16417C127O16491C138O16581C149O16536C158O16402C167O16640C170O16373C174O16018C239O16917C245O16917C250O16896C255O16946C257O16974C268O16995C275O17136C279O16974C284O17169C288O17199C294O17235C304O17312C311O17217C316O17215C320O17398C326O17440C337O17422C342O17420C347O17588,,
code-creation,JS,10,47492,0x31e6f6b558ce,72,initializeDns node:internal/dns/utils:204:23,0x31e647c7c098,~
script-source,71,node:internal/dns/utils,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  FunctionPrototypeBind\x2C\n  NumberParseInt\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  Symbol\x2C\n} = primordials;\n\nconst errors = require('internal/errors');\nconst { isIP } = require('internal/net');\nconst { getOptionValue } = require('internal/options');\nconst {\n  validateArray\x2C\n  validateInt32\x2C\n  validateOneOf\x2C\n  validateString\x2C\n} = require('internal/validators');\nlet binding;\nfunction lazyBinding() {\n  binding ??= internalBinding('cares_wrap');\n  return binding;\n}\nconst IANA_DNS_PORT = 53;\nconst IPv6RE = /^\\[([^[\\]]*)\\]/;\nconst addrSplitRE = /(^.+?)(?::(\\d+))?$/;\nconst {\n  ERR_DNS_SET_SERVERS_FAILED\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_INVALID_IP_ADDRESS\x2C\n} = errors.codes;\n\nconst {\n  namespace: {\n    addSerializeCallback\x2C\n    addDeserializeCallback\x2C\n    isBuildingSnapshot\x2C\n  }\x2C\n} = require('internal/v8/startup_snapshot');\n\nfunction validateTimeout(options) {\n  const { timeout = -1 } = { ...options };\n  validateInt32(timeout\x2C 'options.timeout'\x2C -1);\n  return timeout;\n}\n\nfunction validateTries(options) {\n  const { tries = 4 } = { ...options };\n  validateInt32(tries\x2C 'options.tries'\x2C 1);\n  return tries;\n}\n\nconst kSerializeResolver = Symbol('dns:resolver:serialize');\nconst kDeserializeResolver = Symbol('dns:resolver:deserialize');\nconst kSnapshotStates = Symbol('dns:resolver:config');\nconst kInitializeHandle = Symbol('dns:resolver:initializeHandle');\nconst kSetServersInteral = Symbol('dns:resolver:setServers');\n\n// Resolver instances correspond 1:1 to c-ares channels.\n\nclass ResolverBase {\n  constructor(options = undefined) {\n    const timeout = validateTimeout(options);\n    const tries = validateTries(options);\n    // If we are building snapshot\x2C save the states of the resolver along\n    // the way.\n    if (isBuildingSnapshot()) {\n      this[kSnapshotStates] = { timeout\x2C tries };\n    }\n    this[kInitializeHandle](timeout\x2C tries);\n  }\n\n  [kInitializeHandle](timeout\x2C tries) {\n    const { ChannelWrap } = lazyBinding();\n    this._handle = new ChannelWrap(timeout\x2C tries);\n  }\n\n  cancel() {\n    this._handle.cancel();\n  }\n\n  getServers() {\n    return ArrayPrototypeMap(this._handle.getServers() || []\x2C (val) => {\n      if (!val[1] || val[1] === IANA_DNS_PORT)\n        return val[0];\n\n      const host = isIP(val[0]) === 6 ? `[${val[0]}]` : val[0];\n      return `${host}:${val[1]}`;\n    });\n  }\n\n  setServers(servers) {\n    validateArray(servers\x2C 'servers');\n\n    // Cache the original servers because in the event of an error while\n    // setting the servers\x2C c-ares won't have any servers available for\n    // resolution.\n    const newSet = [];\n    ArrayPrototypeForEach(servers\x2C (serv\x2C index) => {\n      validateString(serv\x2C `servers[${index}]`);\n      let ipVersion = isIP(serv);\n\n      if (ipVersion !== 0)\n        return ArrayPrototypePush(newSet\x2C [ipVersion\x2C serv\x2C IANA_DNS_PORT]);\n\n      const match = RegExpPrototypeExec(IPv6RE\x2C serv);\n\n      // Check for an IPv6 in brackets.\n      if (match) {\n        ipVersion = isIP(match[1]);\n\n        if (ipVersion !== 0) {\n          const port = NumberParseInt(\n            RegExpPrototypeSymbolReplace(addrSplitRE\x2C serv\x2C '$2')) || IANA_DNS_PORT;\n          return ArrayPrototypePush(newSet\x2C [ipVersion\x2C match[1]\x2C port]);\n        }\n      }\n\n      // addr::port\n      const addrSplitMatch = RegExpPrototypeExec(addrSplitRE\x2C serv);\n\n      if (addrSplitMatch) {\n        const hostIP = addrSplitMatch[1];\n        const port = addrSplitMatch[2] || IANA_DNS_PORT;\n\n        ipVersion = isIP(hostIP);\n\n        if (ipVersion !== 0) {\n          return ArrayPrototypePush(\n            newSet\x2C [ipVersion\x2C hostIP\x2C NumberParseInt(port)]);\n        }\n      }\n\n      throw new ERR_INVALID_IP_ADDRESS(serv);\n    });\n\n    this[kSetServersInteral](newSet\x2C servers);\n  }\n\n  [kSetServersInteral](newSet\x2C servers) {\n    const orig = ArrayPrototypeMap(this._handle.getServers() || []\x2C (val) => {\n      val.unshift(isIP(val[0]));\n      return val;\n    });\n    const errorNumber = this._handle.setServers(newSet);\n\n    if (errorNumber !== 0) {\n      // Reset the servers to the old servers\x2C because ares probably unset them.\n      this._handle.setServers(orig);\n      const { strerror } = lazyBinding();\n      const err = strerror(errorNumber);\n      throw new ERR_DNS_SET_SERVERS_FAILED(err\x2C servers);\n    }\n\n    if (isBuildingSnapshot()) {\n      this[kSnapshotStates].servers = newSet;\n    }\n  }\n\n\n  setLocalAddress(ipv4\x2C ipv6) {\n    validateString(ipv4\x2C 'ipv4');\n\n    if (ipv6 !== undefined) {\n      validateString(ipv6\x2C 'ipv6');\n    }\n\n    this._handle.setLocalAddress(ipv4\x2C ipv6);\n\n    if (isBuildingSnapshot()) {\n      this[kSnapshotStates].localAddress = { ipv4\x2C ipv6 };\n    }\n  }\n\n  // TODO(joyeecheung): consider exposing this if custom DNS resolvers\n  // end up being useful for snapshot users.\n  [kSerializeResolver]() {\n    this._handle = null;  // We'll restore it during deserialization.\n    addDeserializeCallback(function deserializeResolver(resolver) {\n      resolver[kDeserializeResolver]();\n    }\x2C this);\n  }\n\n  [kDeserializeResolver]() {\n    const { timeout\x2C tries\x2C localAddress\x2C servers } = this[kSnapshotStates];\n    this[kInitializeHandle](timeout\x2C tries);\n    if (localAddress) {\n      const { ipv4\x2C ipv6 } = localAddress;\n      this._handle.setLocalAddress(ipv4\x2C ipv6);\n    }\n    if (servers) {\n      this[kSetServersInteral](servers\x2C servers);\n    }\n  }\n}\n\nlet defaultResolver;\nlet dnsOrder;\n\nfunction initializeDns() {\n  const orderFromCLI = getOptionValue('--dns-result-order');\n  if (!orderFromCLI) {\n    dnsOrder ??= 'verbatim';\n  } else {\n    // Allow the deserialized application to override order from CLI.\n    dnsOrder = orderFromCLI;\n  }\n\n  if (!isBuildingSnapshot()) {\n    return;\n  }\n\n  addSerializeCallback(() => {\n    defaultResolver?.[kSerializeResolver]();\n  });\n}\n\nconst resolverKeys = [\n  'getServers'\x2C\n  'resolve'\x2C\n  'resolve4'\x2C\n  'resolve6'\x2C\n  'resolveAny'\x2C\n  'resolveCaa'\x2C\n  'resolveCname'\x2C\n  'resolveMx'\x2C\n  'resolveNaptr'\x2C\n  'resolveNs'\x2C\n  'resolvePtr'\x2C\n  'resolveSoa'\x2C\n  'resolveSrv'\x2C\n  'resolveTxt'\x2C\n  'reverse'\x2C\n];\n\nfunction getDefaultResolver() {\n  // We do this here instead of pre-execution so that the default resolver is\n  // only ever created when the user loads any dns module.\n  if (defaultResolver === undefined) {\n    defaultResolver = new ResolverBase();\n  }\n  return defaultResolver;\n}\n\nfunction setDefaultResolver(resolver) {\n  defaultResolver = resolver;\n}\n\nfunction bindDefaultResolver(target\x2C source) {\n  const defaultResolver = getDefaultResolver();\n  ArrayPrototypeForEach(resolverKeys\x2C (key) => {\n    target[key] = FunctionPrototypeBind(source[key]\x2C defaultResolver);\n  });\n}\n\nfunction validateHints(hints) {\n  const { AI_ADDRCONFIG\x2C AI_ALL\x2C AI_V4MAPPED } = lazyBinding();\n  if ((hints & ~(AI_ADDRCONFIG | AI_ALL | AI_V4MAPPED)) !== 0) {\n    throw new ERR_INVALID_ARG_VALUE('hints'\x2C hints);\n  }\n}\n\nlet invalidHostnameWarningEmitted = false;\nfunction emitInvalidHostnameWarning(hostname) {\n  if (!invalidHostnameWarningEmitted) {\n    process.emitWarning(\n      `The provided hostname "${hostname}" is not a valid ` +\n      'hostname\x2C and is supported in the dns module solely for compatibility.'\x2C\n      'DeprecationWarning'\x2C\n      'DEP0118'\x2C\n    );\n    invalidHostnameWarningEmitted = true;\n  }\n}\n\nfunction getDefaultVerbatim() {\n  return dnsOrder !== 'ipv4first';\n}\n\nfunction setDefaultResultOrder(value) {\n  validateOneOf(value\x2C 'dnsOrder'\x2C ['verbatim'\x2C 'ipv4first']);\n  dnsOrder = value;\n}\n\nfunction getDefaultResultOrder() {\n  return dnsOrder;\n}\n\nfunction createResolverClass(resolver) {\n  const resolveMap = { __proto__: null };\n\n  class Resolver extends ResolverBase {}\n\n  Resolver.prototype.resolveAny = resolveMap.ANY = resolver('queryAny');\n  Resolver.prototype.resolve4 = resolveMap.A = resolver('queryA');\n  Resolver.prototype.resolve6 = resolveMap.AAAA = resolver('queryAaaa');\n  Resolver.prototype.resolveCaa = resolveMap.CAA = resolver('queryCaa');\n  Resolver.prototype.resolveCname = resolveMap.CNAME = resolver('queryCname');\n  Resolver.prototype.resolveMx = resolveMap.MX = resolver('queryMx');\n  Resolver.prototype.resolveNs = resolveMap.NS = resolver('queryNs');\n  Resolver.prototype.resolveTxt = resolveMap.TXT = resolver('queryTxt');\n  Resolver.prototype.resolveSrv = resolveMap.SRV = resolver('querySrv');\n  Resolver.prototype.resolvePtr = resolveMap.PTR = resolver('queryPtr');\n  Resolver.prototype.resolveNaptr = resolveMap.NAPTR = resolver('queryNaptr');\n  Resolver.prototype.resolveSoa = resolveMap.SOA = resolver('querySoa');\n  Resolver.prototype.reverse = resolver('getHostByAddr');\n\n  return {\n    resolveMap\x2C\n    Resolver\x2C\n  };\n}\n\n// ERROR CODES\nconst errorCodes = {\n  NODATA: 'ENODATA'\x2C\n  FORMERR: 'EFORMERR'\x2C\n  SERVFAIL: 'ESERVFAIL'\x2C\n  NOTFOUND: 'ENOTFOUND'\x2C\n  NOTIMP: 'ENOTIMP'\x2C\n  REFUSED: 'EREFUSED'\x2C\n  BADQUERY: 'EBADQUERY'\x2C\n  BADNAME: 'EBADNAME'\x2C\n  BADFAMILY: 'EBADFAMILY'\x2C\n  BADRESP: 'EBADRESP'\x2C\n  CONNREFUSED: 'ECONNREFUSED'\x2C\n  TIMEOUT: 'ETIMEOUT'\x2C\n  EOF: 'EOF'\x2C\n  FILE: 'EFILE'\x2C\n  NOMEM: 'ENOMEM'\x2C\n  DESTRUCTION: 'EDESTRUCTION'\x2C\n  BADSTR: 'EBADSTR'\x2C\n  BADFLAGS: 'EBADFLAGS'\x2C\n  NONAME: 'ENONAME'\x2C\n  BADHINTS: 'EBADHINTS'\x2C\n  NOTINITIALIZED: 'ENOTINITIALIZED'\x2C\n  LOADIPHLPAPI: 'ELOADIPHLPAPI'\x2C\n  ADDRGETNETWORKPARAMS: 'EADDRGETNETWORKPARAMS'\x2C\n  CANCELLED: 'ECANCELLED'\x2C\n};\n\nmodule.exports = {\n  bindDefaultResolver\x2C\n  getDefaultResolver\x2C\n  setDefaultResolver\x2C\n  validateHints\x2C\n  validateTimeout\x2C\n  validateTries\x2C\n  emitInvalidHostnameWarning\x2C\n  getDefaultVerbatim\x2C\n  getDefaultResultOrder\x2C\n  setDefaultResultOrder\x2C\n  errorCodes\x2C\n  createResolverClass\x2C\n  initializeDns\x2C\n};\n
code-source-info,0x31e6f6b558ce,71,5490,5854,C0O5518C8O5518C13O5558C15O5583C28O5592C36O5693C38O5702C44O5725C49O5730C54O5758C55O5765C56O5773C66O5773C71O5853,,
code-creation,JS,10,48060,0x31e6f6b566b6,90,setupSymbolDisposePolyfill node:internal/process/pre_execution:158:36,0x31e647c79678,~
code-source-info,0x31e6f6b566b6,67,4483,5183,C0O4653C5O4671C13O4699C20O4720C33O4829C39O4699C44O4941C49O4959C57O4992C64O5013C77O5127C83O4992C89O5182,,
code-creation,JS,10,48117,0x31e6f6b5687e,21,assert node:internal/assert:11:16,0x31e6931bb988,~
script-source,11,node:internal/assert,'use strict';\n\nlet error;\nfunction lazyError() {\n  if (!error) {\n    error = require('internal/errors').codes.ERR_INTERNAL_ASSERTION;\n  }\n  return error;\n}\n\nfunction assert(value\x2C message) {\n  if (!value) {\n    const ERR_INTERNAL_ASSERTION = lazyError();\n    throw new ERR_INTERNAL_ASSERTION(message);\n  }\n}\n\nfunction fail(message) {\n  const ERR_INTERNAL_ASSERTION = lazyError();\n  throw new ERR_INTERNAL_ASSERTION(message);\n}\n\nassert.fail = fail;\n\nmodule.exports = assert;\n
code-source-info,0x31e6f6b5687e,11,172,307,C0O193C4O242C7O242C11O259C13O265C18O259C20O306,,
tick,0x7ff8091ad74b,48186,0,0x0,3,0x10c9f09d0,0x31e63e0bd3b6,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,48253,0x31e6f6b56dee,432,readPolicyFromDisk node:internal/process/pre_execution:656:28,0x31e647c79e18,~
code-source-info,0x31e6f6b56dee,67,20342,22134,C0O20376C10O20376C15O20419C17O20449C21O20457C35O20457C41O20582C49O20582C55O20559C60O20574C65O20701C67O20718C75O20722C81O20737C87O20738C94O20792C101O20861C105O20883C111O20883C117O20861C123O20897C134O20913C138O20927C146O20941C152O20999C160O20999C165O21033C175O21033C182O21108C192O21108C197O21150C199O21203C207O21203C212O21281C220O21281C226O21249C231O21261C236O21330C242O21330C248O21380C254O21380C260O21439C262O21465C264O21489C268O21470C273O21580C275O21596C280O21530C285O21558C290O21622C296O21658C302O21658C307O21699C313O21699C319O21728C325O21748C329O21735C334O21768C341O21815C343O21844C345O21885C351O21907C361O21907C368O21885C374O21498C379O21452C383O21942C387O21969C401O21975C406O21969C407O22058C415O22086C419O22116C429O22128C431O22133,,
code-creation,JS,10,48332,0x31e6f6b571fe,49,setupStacktracePrinterOnSigint node:internal/process/pre_execution:419:40,0x31e647c79a20,~
code-source-info,0x31e6f6b571fe,67,12941,13127,C0O12948C8O12953C14O12993C15O13000C16O13034C22O13034C27O13015C32O13084C38O13117C43O13117C48O13126,,
code-creation,JS,10,48368,0x31e6f6b5739e,35,initializeReportSignalHandlers node:internal/process/pre_execution:449:40,0x31e647c79b38,~
code-source-info,0x31e6f6b5739e,67,13712,13861,C0O13719C8O13723C14O13796C20O13796C25O13775C30O13836C34O13860,,
code-creation,JS,10,48415,0x31e6f6b5769e,155,initializeHeapSnapshotSignalHandlers node:internal/process/pre_execution:456:46,0x31e647c79b88,~
code-source-info,0x31e6f6b5769e,67,13908,14597,C0O13908C20O13930C30O13930C34O13930C36O13995C46O13995C50O13995C52O14034C56O14051C57O14058C58O14062C66O14062C71O14092C79O14093C84O14153C92O14153C97O14131C103O14328C108O14336C119O14336C125O14464C132O14468C137O14496C149O14496C154O14596,,
code-creation,JS,10,48469,0x31e6f6b579e6,138,setupChildProcessIpcChannel node:internal/process/pre_execution:566:37,0x31e647c79cf0,~
code-source-info,0x31e6f6b579e6,67,17627,18156,C0O17634C3O17646C8O17650C14O17688C20O17688C25O17732C33O17755C38O17759C46O17732C52O17785C53O17795C57O17785C61O17876C64O17891C73O17949C76O17957C81O17961C90O18008C93O18023C102O18065C108O18065C113O18089C118O18090C124O18129C127O18144C132O18129C137O18155,,
code-creation,JS,10,48518,0x31e6f6b57c06,63,initializeClusterIPC node:internal/process/pre_execution:585:30,0x31e647c79d40,~
code-source-info,0x31e6f6b57c06,67,18187,18428,C0O18194C3O18206C10O18210C18O18225C23O18229C29O18267C35O18267C40O18299C45O18299C49O18388C52O18403C62O18427,,
code-creation,JS,10,48570,0x31e6f6b57d46,54,runDeserializeCallbacks node:internal/v8/startup_snapshot:39:33,0x31e647c69460,~
script-source,53,node:internal/v8/startup_snapshot,'use strict';\n\nconst {\n  validateFunction\x2C\n} = require('internal/validators');\nconst {\n  codes: {\n    ERR_NOT_BUILDING_SNAPSHOT\x2C\n    ERR_NOT_SUPPORTED_IN_SNAPSHOT\x2C\n    ERR_DUPLICATE_STARTUP_SNAPSHOT_MAIN_FUNCTION\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  setSerializeCallback\x2C\n  setDeserializeCallback\x2C\n  setDeserializeMainFunction: _setDeserializeMainFunction\x2C\n  isBuildingSnapshotBuffer\x2C\n} = internalBinding('mksnapshot');\n\nfunction isBuildingSnapshot() {\n  return isBuildingSnapshotBuffer[0];\n}\n\nfunction throwIfNotBuildingSnapshot() {\n  if (!isBuildingSnapshot()) {\n    throw new ERR_NOT_BUILDING_SNAPSHOT();\n  }\n}\n\nfunction throwIfBuildingSnapshot(reason) {\n  if (isBuildingSnapshot()) {\n    throw new ERR_NOT_SUPPORTED_IN_SNAPSHOT(reason);\n  }\n}\n\nconst deserializeCallbacks = [];\nlet deserializeCallbackIsSet = false;\nfunction runDeserializeCallbacks() {\n  while (deserializeCallbacks.length > 0) {\n    const { 0: callback\x2C 1: data } = deserializeCallbacks.shift();\n    callback(data);\n  }\n}\n\nfunction addDeserializeCallback(callback\x2C data) {\n  throwIfNotBuildingSnapshot();\n  validateFunction(callback\x2C 'callback');\n  if (!deserializeCallbackIsSet) {\n    // TODO(joyeecheung): when the main function handling is done in JS\x2C\n    // the deserialize callbacks can always be invoked. For now only\n    // store it in C++ when it's actually used to avoid unnecessary\n    // C++ -> JS costs.\n    setDeserializeCallback(runDeserializeCallbacks);\n    deserializeCallbackIsSet = true;\n  }\n  deserializeCallbacks.push([callback\x2C data]);\n}\n\nconst serializeCallbacks = [];\nfunction runSerializeCallbacks() {\n  while (serializeCallbacks.length > 0) {\n    const { 0: callback\x2C 1: data } = serializeCallbacks.shift();\n    callback(data);\n  }\n}\n\nfunction addSerializeCallback(callback\x2C data) {\n  throwIfNotBuildingSnapshot();\n  validateFunction(callback\x2C 'callback');\n  serializeCallbacks.push([callback\x2C data]);\n}\n\nfunction initializeCallbacks() {\n  // Only run the serialize callbacks in snapshot building mode\x2C otherwise\n  // they throw.\n  if (isBuildingSnapshot()) {\n    setSerializeCallback(runSerializeCallbacks);\n  }\n}\n\nlet deserializeMainIsSet = false;\nfunction setDeserializeMainFunction(callback\x2C data) {\n  throwIfNotBuildingSnapshot();\n  // TODO(joyeecheung): In lib/internal/bootstrap/node.js\x2C create a default\n  // main function to run the lib/internal/main scripts and make sure that\n  // the main function set in the snapshot building process takes precedence.\n  validateFunction(callback\x2C 'callback');\n  if (deserializeMainIsSet) {\n    throw new ERR_DUPLICATE_STARTUP_SNAPSHOT_MAIN_FUNCTION();\n  }\n  deserializeMainIsSet = true;\n\n  _setDeserializeMainFunction(function deserializeMain() {\n    const {\n      prepareMainThreadExecution\x2C\n      markBootstrapComplete\x2C\n    } = require('internal/process/pre_execution');\n\n    // This should be in sync with run_main_module.js until we make that\n    // a built-in main function.\n    // TODO(joyeecheung): make a copy of argv[0] and insert it as argv[1].\n    prepareMainThreadExecution(false);\n    markBootstrapComplete();\n    callback(data);\n  });\n}\n\nmodule.exports = {\n  initializeCallbacks\x2C\n  runDeserializeCallbacks\x2C\n  throwIfBuildingSnapshot\x2C\n  // Exposed to require('v8').startupSnapshot\n  namespace: {\n    addDeserializeCallback\x2C\n    addSerializeCallback\x2C\n    setDeserializeMainFunction\x2C\n    isBuildingSnapshot\x2C\n  }\x2C\n};\n
code-source-info,0x31e6f6b57d46,53,863,1004,C0O905C5O898C11O905C16O949C21O970C26O970C33O927C40O940C44O983C48O870C53O1003,,
code-creation,JS,10,48802,0x31e6f6b58276,67,setupUserModules node:internal/process/pre_execution:183:26,0x31e647c796c8,~
code-source-info,0x31e6f6b58276,67,5210,5763,C10O5243C13O5243C16O5268C19O5268C23O5329C29O5329C34O5371C39O5389C45O5371C49O5629C53O5660C56O5660C59O5732C62O5732C66O5762,,
code-creation,JS,10,48836,0x31e6f6b583be,21,initializeCJSLoader node:internal/process/pre_execution:706:29,0x31e647c79e68,~
code-source-info,0x31e6f6b583be,67,22164,22257,C0O22197C6O22197C11O22179C16O22239C20O22256,,
code-creation,JS,10,48943,0x31e6f6b5851e,90,initializeCJS node:internal/modules/cjs/loader:383:23,0x31e647c76a28,~
script-source,63,node:internal/modules/cjs/loader,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypePushApply\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeUnshift\x2C\n  ArrayPrototypeUnshiftApply\x2C\n  Boolean\x2C\n  Error\x2C\n  JSONParse\x2C\n  ObjectDefineProperty\x2C\n  ObjectFreeze\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectKeys\x2C\n  ObjectPrototype\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  Proxy\x2C\n  ReflectApply\x2C\n  ReflectSet\x2C\n  RegExpPrototypeExec\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  String\x2C\n  Symbol\x2C\n  StringPrototypeCharAt\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeRepeat\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\n\n// Map used to store CJS parsing data.\nconst cjsParseCache = new SafeWeakMap();\n\n// Set first due to cycle with ESM loader functions.\nmodule.exports = {\n  wrapSafe\x2C Module\x2C cjsParseCache\x2C\n  get hasLoadedAnyUserCJSModule() { return hasLoadedAnyUserCJSModule; }\x2C\n  initializeCJS\x2C\n};\n\nconst { BuiltinModule } = require('internal/bootstrap/realm');\nconst {\n  maybeCacheSourceMap\x2C\n} = require('internal/source_map/source_map_cache');\nconst { pathToFileURL\x2C fileURLToPath\x2C isURL } = require('internal/url');\nconst {\n  pendingDeprecate\x2C\n  emitExperimentalWarning\x2C\n  kEmptyObject\x2C\n  setOwnProperty\x2C\n  getLazy\x2C\n} = require('internal/util');\nconst {\n  internalCompileFunction\x2C\n  makeContextifyScript\x2C\n  runScriptInThisContext\x2C\n} = require('internal/vm');\nconst { containsModuleSyntax } = internalBinding('contextify');\n\nconst assert = require('internal/assert');\nconst fs = require('fs');\nconst path = require('path');\nconst { internalModuleStat } = internalBinding('fs');\nconst { safeGetenv } = internalBinding('credentials');\nconst {\n  privateSymbols: {\n    require_private_symbol\x2C\n  }\x2C\n} = internalBinding('util');\nconst {\n  getCjsConditions\x2C\n  initializeCjsConditions\x2C\n  loadBuiltinModule\x2C\n  makeRequireFunction\x2C\n  normalizeReferrerURL\x2C\n  stripBOM\x2C\n  toRealPath\x2C\n} = require('internal/modules/helpers');\nconst packageJsonReader = require('internal/modules/package_json_reader');\nconst { getOptionValue\x2C getEmbedderOptions } = require('internal/options');\nconst policy = getLazy(\n  () => (getOptionValue('--experimental-policy') ? require('internal/process/policy') : null)\x2C\n);\nconst shouldReportRequiredModules = getLazy(() => process.env.WATCH_REPORT_DEPENDENCIES);\n\nconst getCascadedLoader = getLazy(\n  () => require('internal/process/esm_loader').esmLoader\x2C\n);\n\nconst permission = require('internal/process/permission');\n\n// Whether any user-provided CJS modules had been loaded (executed).\n// Used for internal assertions.\nlet hasLoadedAnyUserCJSModule = false;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_MODULE_SPECIFIER\x2C\n    ERR_REQUIRE_ESM\x2C\n    ERR_UNKNOWN_BUILTIN_MODULE\x2C\n  }\x2C\n  setArrowMessage\x2C\n} = require('internal/errors');\nconst { validateString } = require('internal/validators');\n\nconst {\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_COLON\x2C\n  CHAR_DOT\x2C\n  CHAR_FORWARD_SLASH\x2C\n} = require('internal/constants');\n\nconst {\n  isProxy\x2C\n} = require('internal/util/types');\n\nconst { kEvaluated } = internalBinding('module_wrap');\nconst isWindows = process.platform === 'win32';\n\nconst relativeResolveCache = { __proto__: null };\n\nlet requireDepth = 0;\nlet isPreloading = false;\nlet statCache = null;\n\n/**\n * Our internal implementation of `require`.\n * @param {Module} module Parent module of what is being required\n * @param {string} id Specifier of the child module being imported\n */\nfunction internalRequire(module\x2C id) {\n  validateString(id\x2C 'id');\n  if (id === '') {\n    throw new ERR_INVALID_ARG_VALUE('id'\x2C id\x2C\n                                    'must be a non-empty string');\n  }\n  requireDepth++;\n  try {\n    return Module._load(id\x2C module\x2C /* isMain */ false);\n  } finally {\n    requireDepth--;\n  }\n}\n\n/**\n * Get a path's properties\x2C using an in-memory cache to minimize lookups.\n * @param {string} filename Absolute path to the file\n */\nfunction stat(filename) {\n  filename = path.toNamespacedPath(filename);\n  if (statCache !== null) {\n    const result = statCache.get(filename);\n    if (result !== undefined) { return result; }\n  }\n  const result = internalModuleStat(filename);\n  if (statCache !== null && result >= 0) {\n    // Only set cache when `internalModuleStat(filename)` succeeds.\n    statCache.set(filename\x2C result);\n  }\n  return result;\n}\n\nlet _stat = stat;\nObjectDefineProperty(Module\x2C '_stat'\x2C {\n  __proto__: null\x2C\n  get() { return _stat; }\x2C\n  set(stat) {\n    emitExperimentalWarning('Module._stat');\n    _stat = stat;\n    return true;\n  }\x2C\n  configurable: true\x2C\n});\n\n/**\n * Update the parent's children array with the child module.\n * @param {Module} parent Module requiring the children\n * @param {Module} child Module being required\n * @param {boolean} scan Add the child to the parent's children if not already present\n */\nfunction updateChildren(parent\x2C child\x2C scan) {\n  const children = parent?.children;\n  if (children && !(scan && ArrayPrototypeIncludes(children\x2C child))) {\n    ArrayPrototypePush(children\x2C child);\n  }\n}\n\n/**\n * Tell the watch mode that a module was required.\n * @param {string} filename Absolute path of the module\n */\nfunction reportModuleToWatchMode(filename) {\n  if (shouldReportRequiredModules() && process.send) {\n    process.send({ 'watch:require': [filename] });\n  }\n}\n\n/**\n * Tell the watch mode that a module was not found.\n * @param {string} basePath The absolute path that errored\n * @param {string[]} extensions The extensions that were tried\n */\nfunction reportModuleNotFoundToWatchMode(basePath\x2C extensions) {\n  if (shouldReportRequiredModules() && process.send) {\n    process.send({ 'watch:require': ArrayPrototypeMap(extensions\x2C (ext) => path.resolve(`${basePath}${ext}`)) });\n  }\n}\n\n/** @type {Map<Module\x2C Module>} */\nconst moduleParentCache = new SafeWeakMap();\n/**\n * Create a new module instance.\n * @param {string} id\n * @param {Module} parent\n */\nfunction Module(id = ''\x2C parent) {\n  this.id = id;\n  this.path = path.dirname(id);\n  setOwnProperty(this\x2C 'exports'\x2C {});\n  moduleParentCache.set(this\x2C parent);\n  updateChildren(parent\x2C this\x2C false);\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n  let redirects;\n  const manifest = policy()?.manifest;\n  if (manifest) {\n    const moduleURL = pathToFileURL(id);\n    redirects = manifest.getDependencyMapper(moduleURL);\n    // TODO(rafaelgss): remove the necessity of this branch\n    setOwnProperty(this\x2C 'require'\x2C makeRequireFunction(this\x2C redirects));\n    // eslint-disable-next-line no-proto\n    setOwnProperty(this.__proto__\x2C 'require'\x2C makeRequireFunction(this\x2C redirects));\n  }\n  this[require_private_symbol] = internalRequire;\n}\n\n/** @type {Record<string\x2C Module>} */\nModule._cache = { __proto__: null };\n/** @type {Record<string\x2C string>} */\nModule._pathCache = { __proto__: null };\n/** @type {Record<string\x2C (module: Module\x2C filename: string) => void>} */\nModule._extensions = { __proto__: null };\n/** @type {string[]} */\nlet modulePaths = [];\n/** @type {string[]} */\nModule.globalPaths = [];\n\nlet patched = false;\n\n/**\n * Add the CommonJS wrapper around a module's source code.\n * @param {string} script Module source code\n */\nlet wrap = function(script) { // eslint-disable-line func-style\n  return Module.wrapper[0] + script + Module.wrapper[1];\n};\n\nconst wrapper = [\n  '(function (exports\x2C require\x2C module\x2C __filename\x2C __dirname) { '\x2C\n  '\\n});'\x2C\n];\n\nlet wrapperProxy = new Proxy(wrapper\x2C {\n  __proto__: null\x2C\n\n  set(target\x2C property\x2C value\x2C receiver) {\n    patched = true;\n    return ReflectSet(target\x2C property\x2C value\x2C receiver);\n  }\x2C\n\n  defineProperty(target\x2C property\x2C descriptor) {\n    patched = true;\n    return ObjectDefineProperty(target\x2C property\x2C descriptor);\n  }\x2C\n});\n\nObjectDefineProperty(Module\x2C 'wrap'\x2C {\n  __proto__: null\x2C\n  get() {\n    return wrap;\n  }\x2C\n\n  set(value) {\n    patched = true;\n    wrap = value;\n  }\x2C\n});\n\nObjectDefineProperty(Module\x2C 'wrapper'\x2C {\n  __proto__: null\x2C\n  get() {\n    return wrapperProxy;\n  }\x2C\n\n  set(value) {\n    patched = true;\n    wrapperProxy = value;\n  }\x2C\n});\n\nconst isPreloadingDesc = { get() { return isPreloading; } };\nObjectDefineProperty(Module.prototype\x2C 'isPreloading'\x2C isPreloadingDesc);\nObjectDefineProperty(BuiltinModule.prototype\x2C 'isPreloading'\x2C isPreloadingDesc);\n\n/**\n * Get the parent of the current module from our cache.\n */\nfunction getModuleParent() {\n  return moduleParentCache.get(this);\n}\n\n/**\n * Set the parent of the current module in our cache.\n * @param {Module} value\n */\nfunction setModuleParent(value) {\n  moduleParentCache.set(this\x2C value);\n}\n\nlet debug = require('internal/util/debuglog').debuglog('module'\x2C (fn) => {\n  debug = fn;\n});\n\nObjectDefineProperty(Module.prototype\x2C 'parent'\x2C {\n  __proto__: null\x2C\n  get: pendingDeprecate(\n    getModuleParent\x2C\n    'module.parent is deprecated due to accuracy issues. Please use ' +\n      'require.main to find program entry point instead.'\x2C\n    'DEP0144'\x2C\n  )\x2C\n  set: pendingDeprecate(\n    setModuleParent\x2C\n    'module.parent is deprecated due to accuracy issues. Please use ' +\n      'require.main to find program entry point instead.'\x2C\n    'DEP0144'\x2C\n  )\x2C\n});\nModule._debug = pendingDeprecate(debug\x2C 'Module._debug is deprecated.'\x2C 'DEP0077');\nModule.isBuiltin = BuiltinModule.isBuiltin;\n\n/**\n * Prepare to run CommonJS code.\n * This function is called during pre-execution\x2C before any user code is run.\n */\nfunction initializeCJS() {\n  // This need to be done at runtime in case --expose-internals is set.\n  const builtinModules = BuiltinModule.getCanBeRequiredByUsersWithoutSchemeList();\n  Module.builtinModules = ObjectFreeze(builtinModules);\n\n  initializeCjsConditions();\n\n  if (!getEmbedderOptions().noGlobalSearchPaths) {\n    Module._initPaths();\n  }\n\n  // TODO(joyeecheung): deprecate this in favor of a proper hook?\n  Module.runMain =\n    require('internal/modules/run_main').executeUserEntryPoint;\n}\n\n// Given a module name\x2C and a list of paths to test\x2C returns the first\n// matching file in the following precedence.\n//\n// require("a.<ext>")\n//   -> a.<ext>\n//\n// require("a")\n//   -> a\n//   -> a.<ext>\n//   -> a/index.<ext>\n\nlet _readPackage = packageJsonReader.readPackage;\nObjectDefineProperty(Module\x2C '_readPackage'\x2C {\n  __proto__: null\x2C\n  get() { return _readPackage; }\x2C\n  set(readPackage) {\n    emitExperimentalWarning('Module._readPackage');\n    _readPackage = readPackage;\n    return true;\n  }\x2C\n  configurable: true\x2C\n});\n\n/**\n * Try to load a specifier as a package.\n * @param {string} requestPath The path to what we are trying to load\n * @param {string[]} exts File extensions to try appending in order to resolve the file\n * @param {boolean} isMain Whether the file is the main entry point of the app\n * @param {string} originalPath The specifier passed to `require`\n */\nfunction tryPackage(requestPath\x2C exts\x2C isMain\x2C originalPath) {\n  const pkg = _readPackage(requestPath).main;\n\n  if (!pkg) {\n    return tryExtensions(path.resolve(requestPath\x2C 'index')\x2C exts\x2C isMain);\n  }\n\n  const filename = path.resolve(requestPath\x2C pkg);\n  let actual = tryFile(filename\x2C isMain) ||\n    tryExtensions(filename\x2C exts\x2C isMain) ||\n    tryExtensions(path.resolve(filename\x2C 'index')\x2C exts\x2C isMain);\n  if (actual === false) {\n    actual = tryExtensions(path.resolve(requestPath\x2C 'index')\x2C exts\x2C isMain);\n    if (!actual) {\n      // eslint-disable-next-line no-restricted-syntax\n      const err = new Error(\n        `Cannot find module '${filename}'. ` +\n        'Please verify that the package.json has a valid "main" entry'\x2C\n      );\n      err.code = 'MODULE_NOT_FOUND';\n      err.path = path.resolve(requestPath\x2C 'package.json');\n      err.requestPath = originalPath;\n      // TODO(BridgeAR): Add the requireStack as well.\n      throw err;\n    } else {\n      const jsonPath = path.resolve(requestPath\x2C 'package.json');\n      process.emitWarning(\n        `Invalid 'main' field in '${jsonPath}' of '${pkg}'. ` +\n          'Please either fix that or report it to the module author'\x2C\n        'DeprecationWarning'\x2C\n        'DEP0128'\x2C\n      );\n    }\n  }\n  return actual;\n}\n\n/**\n * Check if the file exists and is not a directory if using `--preserve-symlinks` and `isMain` is false\x2C keep symlinks\n * intact\x2C otherwise resolve to the absolute realpath.\n * @param {string} requestPath The path to the file to load.\n * @param {boolean} isMain Whether the file is the main module.\n */\nfunction tryFile(requestPath\x2C isMain) {\n  const rc = _stat(requestPath);\n  if (rc !== 0) { return; }\n  if (getOptionValue('--preserve-symlinks') && !isMain) {\n    return path.resolve(requestPath);\n  }\n  return toRealPath(requestPath);\n}\n\n/**\n * Given a path\x2C check if the file exists with any of the set extensions.\n * @param {string} basePath The path and filename without extension\n * @param {string[]} exts The extensions to try\n * @param {boolean} isMain Whether the module is the main module\n */\nfunction tryExtensions(basePath\x2C exts\x2C isMain) {\n  for (let i = 0; i < exts.length; i++) {\n    const filename = tryFile(basePath + exts[i]\x2C isMain);\n\n    if (filename) {\n      return filename;\n    }\n  }\n  return false;\n}\n\n/**\n * Find the longest (possibly multi-dot) extension registered in `Module._extensions`.\n * @param {string} filename The filename to find the longest registered extension for.\n */\nfunction findLongestRegisteredExtension(filename) {\n  const name = path.basename(filename);\n  let currentExtension;\n  let index;\n  let startIndex = 0;\n  while ((index = StringPrototypeIndexOf(name\x2C '.'\x2C startIndex)) !== -1) {\n    startIndex = index + 1;\n    if (index === 0) { continue; } // Skip dotfiles like .gitignore\n    currentExtension = StringPrototypeSlice(name\x2C index);\n    if (Module._extensions[currentExtension]) { return currentExtension; }\n  }\n  return '.js';\n}\n\n/**\n * Tries to get the absolute file path of the parent module.\n * @param {Module} parent The parent module object.\n */\nfunction trySelfParentPath(parent) {\n  if (!parent) { return false; }\n\n  if (parent.filename) {\n    return parent.filename;\n  } else if (parent.id === '<repl>' || parent.id === 'internal/preload') {\n    try {\n      return process.cwd() + path.sep;\n    } catch {\n      return false;\n    }\n  }\n}\n\n/**\n * Attempt to resolve a module request using the parent module package metadata.\n * @param {string} parentPath The path of the parent module\n * @param {string} request The module request to resolve\n */\nfunction trySelf(parentPath\x2C request) {\n  if (!parentPath) { return false; }\n\n  const { data: pkg\x2C path: pkgPath } = packageJsonReader.readPackageScope(parentPath);\n  if (!pkg || pkg.exports == null || pkg.name === undefined) {\n    return false;\n  }\n\n  let expansion;\n  if (request === pkg.name) {\n    expansion = '.';\n  } else if (StringPrototypeStartsWith(request\x2C `${pkg.name}/`)) {\n    expansion = '.' + StringPrototypeSlice(request\x2C pkg.name.length);\n  } else {\n    return false;\n  }\n\n  try {\n    const { packageExportsResolve } = require('internal/modules/esm/resolve');\n    return finalizeEsmResolution(packageExportsResolve(\n      pathToFileURL(pkgPath + '/package.json')\x2C expansion\x2C pkg\x2C\n      pathToFileURL(parentPath)\x2C getCjsConditions())\x2C parentPath\x2C pkgPath);\n  } catch (e) {\n    if (e.code === 'ERR_MODULE_NOT_FOUND') {\n      throw createEsmNotFoundErr(request\x2C pkgPath + '/package.json');\n    }\n    throw e;\n  }\n}\n\n/**\n * This only applies to requests of a specific form:\n * 1. `name/.*`\n * 2. `@scope/name/.*`\n */\nconst EXPORTS_PATTERN = /^((?:@[^/\\\\%]+\\/)?[^./\\\\%][^/\\\\%]*)(\\/.*)?$/;\n\n/**\n * Resolves the exports for a given module path and request.\n * @param {string} nmPath The path to the module.\n * @param {string} request The request for the module.\n */\nfunction resolveExports(nmPath\x2C request) {\n  // The implementation's behavior is meant to mirror resolution in ESM.\n  const { 1: name\x2C 2: expansion = '' } =\n    RegExpPrototypeExec(EXPORTS_PATTERN\x2C request) || kEmptyObject;\n  if (!name) { return; }\n  const pkgPath = path.resolve(nmPath\x2C name);\n  const pkg = _readPackage(pkgPath);\n  if (pkg.exists && pkg.exports != null) {\n    try {\n      const { packageExportsResolve } = require('internal/modules/esm/resolve');\n      return finalizeEsmResolution(packageExportsResolve(\n        pathToFileURL(pkgPath + '/package.json')\x2C '.' + expansion\x2C pkg\x2C null\x2C\n        getCjsConditions())\x2C null\x2C pkgPath);\n    } catch (e) {\n      if (e.code === 'ERR_MODULE_NOT_FOUND') {\n        throw createEsmNotFoundErr(request\x2C pkgPath + '/package.json');\n      }\n      throw e;\n    }\n  }\n}\n\n/**\n * Get the absolute path to a module.\n * @param {string} request Relative or absolute file path\n * @param {Array<string>} paths Folders to search as file paths\n * @param {boolean} isMain Whether the request is the main app entry point\n * @returns {string | false}\n */\nModule._findPath = function(request\x2C paths\x2C isMain) {\n  const absoluteRequest = path.isAbsolute(request);\n  if (absoluteRequest) {\n    paths = [''];\n  } else if (!paths || paths.length === 0) {\n    return false;\n  }\n\n  const cacheKey = request + '\\x00' + ArrayPrototypeJoin(paths\x2C '\\x00');\n  const entry = Module._pathCache[cacheKey];\n  if (entry) {\n    return entry;\n  }\n\n  let exts;\n  const trailingSlash = request.length > 0 &&\n    (StringPrototypeCharCodeAt(request\x2C request.length - 1) === CHAR_FORWARD_SLASH || (\n      StringPrototypeCharCodeAt(request\x2C request.length - 1) === CHAR_DOT &&\n      (\n        request.length === 1 ||\n        StringPrototypeCharCodeAt(request\x2C request.length - 2) === CHAR_FORWARD_SLASH ||\n        (StringPrototypeCharCodeAt(request\x2C request.length - 2) === CHAR_DOT && (\n          request.length === 2 ||\n          StringPrototypeCharCodeAt(request\x2C request.length - 3) === CHAR_FORWARD_SLASH\n        ))\n      )\n    ));\n\n  const isRelative = StringPrototypeCharCodeAt(request\x2C 0) === CHAR_DOT &&\n    (\n      request.length === 1 ||\n      StringPrototypeCharCodeAt(request\x2C 1) === CHAR_FORWARD_SLASH ||\n      (isWindows && StringPrototypeCharCodeAt(request\x2C 1) === CHAR_BACKWARD_SLASH) ||\n      (StringPrototypeCharCodeAt(request\x2C 1) === CHAR_DOT && ((\n        request.length === 2 ||\n        StringPrototypeCharCodeAt(request\x2C 2) === CHAR_FORWARD_SLASH) ||\n        (isWindows && StringPrototypeCharCodeAt(request\x2C 2) === CHAR_BACKWARD_SLASH)))\n    );\n  let insidePath = true;\n  if (isRelative) {\n    const normalizedRequest = path.normalize(request);\n    if (StringPrototypeStartsWith(normalizedRequest\x2C '..')) {\n      insidePath = false;\n    }\n  }\n\n  // For each path\n  for (let i = 0; i < paths.length; i++) {\n    // Don't search further if path doesn't exist\n    // or doesn't have permission to it\n    const curPath = paths[i];\n    if (insidePath && curPath &&\n      ((permission.isEnabled() && !permission.has('fs.read'\x2C curPath)) || _stat(curPath) < 1)\n    ) {\n      continue;\n    }\n\n    if (!absoluteRequest) {\n      const exportsResolved = resolveExports(curPath\x2C request);\n      if (exportsResolved) {\n        return exportsResolved;\n      }\n    }\n\n    const basePath = path.resolve(curPath\x2C request);\n    let filename;\n\n    const rc = _stat(basePath);\n    if (!trailingSlash) {\n      if (rc === 0) {  // File.\n        if (!isMain) {\n          if (getOptionValue('--preserve-symlinks')) {\n            filename = path.resolve(basePath);\n          } else {\n            filename = toRealPath(basePath);\n          }\n        } else if (getOptionValue('--preserve-symlinks-main')) {\n          // For the main module\x2C we use the --preserve-symlinks-main flag instead\n          // mainly for backward compatibility\x2C as the preserveSymlinks flag\n          // historically has not applied to the main module.  Most likely this\n          // was intended to keep .bin/ binaries working\x2C as following those\n          // symlinks is usually required for the imports in the corresponding\n          // files to resolve; that said\x2C in some use cases following symlinks\n          // causes bigger problems which is why the --preserve-symlinks-main option\n          // is needed.\n          filename = path.resolve(basePath);\n        } else {\n          filename = toRealPath(basePath);\n        }\n      }\n\n      if (!filename) {\n        // Try it with each of the extensions\n        if (exts === undefined) {\n          exts = ObjectKeys(Module._extensions);\n        }\n        filename = tryExtensions(basePath\x2C exts\x2C isMain);\n      }\n    }\n\n    if (!filename && rc === 1) {  // Directory.\n      // try it with each of the extensions at "index"\n      if (exts === undefined) {\n        exts = ObjectKeys(Module._extensions);\n      }\n      filename = tryPackage(basePath\x2C exts\x2C isMain\x2C request);\n    }\n\n    if (filename) {\n      Module._pathCache[cacheKey] = filename;\n      return filename;\n    }\n\n    const extensions = [''];\n    if (exts !== undefined) {\n      ArrayPrototypePushApply(extensions\x2C exts);\n    }\n    reportModuleNotFoundToWatchMode(basePath\x2C extensions);\n  }\n\n  return false;\n};\n\n/** `node_modules` character codes reversed */\nconst nmChars = [ 115\x2C 101\x2C 108\x2C 117\x2C 100\x2C 111\x2C 109\x2C 95\x2C 101\x2C 100\x2C 111\x2C 110 ];\nconst nmLen = nmChars.length;\nif (isWindows) {\n  /**\n   * Get the paths to the `node_modules` folder for a given path.\n   * @param {string} from `__dirname` of the module\n   */\n  Module._nodeModulePaths = function(from) {\n    // Guarantee that 'from' is absolute.\n    from = path.resolve(from);\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n\n    // return root node_modules when path is 'D:\\\\'.\n    // path.resolve will make sure from.length >=3 in Windows.\n    if (StringPrototypeCharCodeAt(from\x2C from.length - 1) ===\n          CHAR_BACKWARD_SLASH &&\n        StringPrototypeCharCodeAt(from\x2C from.length - 2) === CHAR_COLON) {\n      return [from + 'node_modules'];\n    }\n\n    /** @type {string[]} */\n    const paths = [];\n    for (let i = from.length - 1\x2C p = 0\x2C last = from.length; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(from\x2C i);\n      // The path segment separator check ('\\' and '/') was used to get\n      // node_modules path for every path segment.\n      // Use colon as an extra condition since we can get node_modules\n      // path for drive root like 'C:\\node_modules' and don't need to\n      // parse drive name.\n      if (code === CHAR_BACKWARD_SLASH ||\n          code === CHAR_FORWARD_SLASH ||\n          code === CHAR_COLON) {\n        if (p !== nmLen) {\n          ArrayPrototypePush(\n            paths\x2C\n            StringPrototypeSlice(from\x2C 0\x2C last) + '\\\\node_modules'\x2C\n          );\n        }\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n\n    return paths;\n  };\n} else { // posix\n  /**\n   * Get the paths to the `node_modules` folder for a given path.\n   * @param {string} from `__dirname` of the module\n   */\n  Module._nodeModulePaths = function(from) {\n    // Guarantee that 'from' is absolute.\n    from = path.resolve(from);\n    // Return early not only to avoid unnecessary work\x2C but to *avoid* returning\n    // an array of two items for a root: [ '//node_modules'\x2C '/node_modules' ]\n    if (from === '/') {\n      return ['/node_modules'];\n    }\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n    /** @type {string[]} */\n    const paths = [];\n    for (let i = from.length - 1\x2C p = 0\x2C last = from.length; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(from\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        if (p !== nmLen) {\n          ArrayPrototypePush(\n            paths\x2C\n            StringPrototypeSlice(from\x2C 0\x2C last) + '/node_modules'\x2C\n          );\n        }\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n\n    // Append /node_modules to handle root paths.\n    ArrayPrototypePush(paths\x2C '/node_modules');\n\n    return paths;\n  };\n}\n\n/**\n * Get the paths for module resolution.\n * @param {string} request\n * @param {Module} parent\n */\nModule._resolveLookupPaths = function(request\x2C parent) {\n  if (BuiltinModule.normalizeRequirableId(request)) {\n    debug('looking for %j in []'\x2C request);\n    return null;\n  }\n\n  // Check for node modules paths.\n  if (StringPrototypeCharAt(request\x2C 0) !== '.' ||\n      (request.length > 1 &&\n      StringPrototypeCharAt(request\x2C 1) !== '.' &&\n      StringPrototypeCharAt(request\x2C 1) !== '/' &&\n      (!isWindows || StringPrototypeCharAt(request\x2C 1) !== '\\\\'))) {\n\n    /** @type {string[]} */\n    let paths;\n    if (parent?.paths?.length) {\n      paths = ArrayPrototypeSlice(modulePaths);\n      ArrayPrototypeUnshiftApply(paths\x2C parent.paths);\n    } else {\n      paths = modulePaths;\n    }\n\n    debug('looking for %j in %j'\x2C request\x2C paths);\n    return paths.length > 0 ? paths : null;\n  }\n\n  // In REPL\x2C parent.filename is null.\n  if (!parent || !parent.id || !parent.filename) {\n    // Make require('./path/to/foo') work - normally the path is taken\n    // from realpath(__filename) but in REPL there is no filename\n    const mainPaths = ['.'];\n\n    debug('looking for %j in %j'\x2C request\x2C mainPaths);\n    return mainPaths;\n  }\n\n  debug('RELATIVE: requested: %s from parent.id %s'\x2C request\x2C parent.id);\n\n  const parentDir = [path.dirname(parent.filename)];\n  debug('looking for %j'\x2C parentDir);\n  return parentDir;\n};\n\n/**\n * Emits a warning when a non-existent property of module exports is accessed inside a circular dependency.\n * @param {string} prop The name of the non-existent property.\n */\nfunction emitCircularRequireWarning(prop) {\n  process.emitWarning(\n    `Accessing non-existent property '${String(prop)}' of module exports ` +\n    'inside circular dependency'\x2C\n  );\n}\n\n// A Proxy that can be used as the prototype of a module.exports object and\n// warns when non-existent properties are accessed.\nconst CircularRequirePrototypeWarningProxy = new Proxy({}\x2C {\n  __proto__: null\x2C\n\n  get(target\x2C prop) {\n    // Allow __esModule access in any case because it is used in the output\n    // of transpiled code to determine whether something comes from an\n    // ES module\x2C and is not used as a regular key of `module.exports`.\n    if (prop in target || prop === '__esModule') { return target[prop]; }\n    emitCircularRequireWarning(prop);\n    return undefined;\n  }\x2C\n\n  getOwnPropertyDescriptor(target\x2C prop) {\n    if (ObjectPrototypeHasOwnProperty(target\x2C prop) || prop === '__esModule') {\n      return ObjectGetOwnPropertyDescriptor(target\x2C prop);\n    }\n    emitCircularRequireWarning(prop);\n    return undefined;\n  }\x2C\n});\n\n/**\n * Returns the exports object for a module that has a circular `require`.\n * If the exports object is a plain object\x2C it is wrapped in a proxy that warns\n * about circular dependencies.\n * @param {Module} module The module instance\n */\nfunction getExportsForCircularRequire(module) {\n  if (module.exports &&\n      !isProxy(module.exports) &&\n      ObjectGetPrototypeOf(module.exports) === ObjectPrototype &&\n      // Exclude transpiled ES6 modules / TypeScript code because those may\n      // employ unusual patterns for accessing 'module.exports'. That should\n      // be okay because ES6 modules have a different approach to circular\n      // dependencies anyway.\n      !module.exports.__esModule) {\n    // This is later unset once the module is done loading.\n    ObjectSetPrototypeOf(\n      module.exports\x2C CircularRequirePrototypeWarningProxy);\n  }\n\n  return module.exports;\n}\n\n/**\n * Load a module from cache if it exists\x2C otherwise create a new module instance.\n * 1. If a module already exists in the cache: return its exports object.\n * 2. If the module is native: call\n *    `BuiltinModule.prototype.compileForPublicLoader()` and return the exports.\n * 3. Otherwise\x2C create a new module for the file and save it to the cache.\n *    Then have it load the file contents before returning its exports object.\n * @param {string} request Specifier of module to load via `require`\n * @param {string} parent Absolute path of the module importing the child\n * @param {boolean} isMain Whether the module is the main entry point\n */\nModule._load = function(request\x2C parent\x2C isMain) {\n  let relResolveCacheIdentifier;\n  if (parent) {\n    debug('Module._load REQUEST %s parent: %s'\x2C request\x2C parent.id);\n    // Fast path for (lazy loaded) modules in the same directory. The indirect\n    // caching is required to allow cache invalidation without changing the old\n    // cache key names.\n    relResolveCacheIdentifier = `${parent.path}\\x00${request}`;\n    const filename = relativeResolveCache[relResolveCacheIdentifier];\n    reportModuleToWatchMode(filename);\n    if (filename !== undefined) {\n      const cachedModule = Module._cache[filename];\n      if (cachedModule !== undefined) {\n        updateChildren(parent\x2C cachedModule\x2C true);\n        if (!cachedModule.loaded) {\n          return getExportsForCircularRequire(cachedModule);\n        }\n        return cachedModule.exports;\n      }\n      delete relativeResolveCache[relResolveCacheIdentifier];\n    }\n  }\n\n  if (StringPrototypeStartsWith(request\x2C 'node:')) {\n    // Slice 'node:' prefix\n    const id = StringPrototypeSlice(request\x2C 5);\n\n    if (!BuiltinModule.canBeRequiredByUsers(id)) {\n      throw new ERR_UNKNOWN_BUILTIN_MODULE(request);\n    }\n\n    const module = loadBuiltinModule(id\x2C request);\n    return module.exports;\n  }\n\n  const filename = Module._resolveFilename(request\x2C parent\x2C isMain);\n  const cachedModule = Module._cache[filename];\n  if (cachedModule !== undefined) {\n    updateChildren(parent\x2C cachedModule\x2C true);\n    if (!cachedModule.loaded) {\n      const parseCachedModule = cjsParseCache.get(cachedModule);\n      if (!parseCachedModule || parseCachedModule.loaded) {\n        return getExportsForCircularRequire(cachedModule);\n      }\n      parseCachedModule.loaded = true;\n    } else {\n      return cachedModule.exports;\n    }\n  }\n\n  if (BuiltinModule.canBeRequiredWithoutScheme(filename)) {\n    const mod = loadBuiltinModule(filename\x2C request);\n    return mod.exports;\n  }\n\n  // Don't call updateChildren()\x2C Module constructor already does.\n  const module = cachedModule || new Module(filename\x2C parent);\n\n  if (isMain) {\n    setOwnProperty(process\x2C 'mainModule'\x2C module);\n    setOwnProperty(module.require\x2C 'main'\x2C process.mainModule);\n    module.id = '.';\n  }\n\n  reportModuleToWatchMode(filename);\n\n  Module._cache[filename] = module;\n  if (parent !== undefined) {\n    relativeResolveCache[relResolveCacheIdentifier] = filename;\n  }\n\n  let threw = true;\n  try {\n    module.load(filename);\n    threw = false;\n  } finally {\n    if (threw) {\n      delete Module._cache[filename];\n      if (parent !== undefined) {\n        delete relativeResolveCache[relResolveCacheIdentifier];\n        const children = parent?.children;\n        if (ArrayIsArray(children)) {\n          const index = ArrayPrototypeIndexOf(children\x2C module);\n          if (index !== -1) {\n            ArrayPrototypeSplice(children\x2C index\x2C 1);\n          }\n        }\n      }\n    } else if (module.exports &&\n               !isProxy(module.exports) &&\n               ObjectGetPrototypeOf(module.exports) ===\n                 CircularRequirePrototypeWarningProxy) {\n      ObjectSetPrototypeOf(module.exports\x2C ObjectPrototype);\n    }\n  }\n\n  return module.exports;\n};\n\n/**\n * Given a `require` string and its context\x2C get its absolute file path.\n * @param {string} request The specifier to resolve\n * @param {Module} parent The module containing the `require` call\n * @param {boolean} isMain Whether the module is the main entry point\n * @param {ResolveFilenameOptions} options Options object\n * @typedef {object} ResolveFilenameOptions\n * @property {string[]} paths Paths to search for modules in\n */\nModule._resolveFilename = function(request\x2C parent\x2C isMain\x2C options) {\n  if (BuiltinModule.normalizeRequirableId(request)) {\n    return request;\n  }\n\n  let paths;\n\n  if (typeof options === 'object' && options !== null) {\n    if (ArrayIsArray(options.paths)) {\n      const isRelative = StringPrototypeStartsWith(request\x2C './') ||\n          StringPrototypeStartsWith(request\x2C '../') ||\n          ((isWindows && StringPrototypeStartsWith(request\x2C '.\\\\')) ||\n          StringPrototypeStartsWith(request\x2C '..\\\\'));\n\n      if (isRelative) {\n        paths = options.paths;\n      } else {\n        const fakeParent = new Module(''\x2C null);\n\n        paths = [];\n\n        for (let i = 0; i < options.paths.length; i++) {\n          const path = options.paths[i];\n          fakeParent.paths = Module._nodeModulePaths(path);\n          const lookupPaths = Module._resolveLookupPaths(request\x2C fakeParent);\n\n          for (let j = 0; j < lookupPaths.length; j++) {\n            if (!ArrayPrototypeIncludes(paths\x2C lookupPaths[j])) {\n              ArrayPrototypePush(paths\x2C lookupPaths[j]);\n            }\n          }\n        }\n      }\n    } else if (options.paths === undefined) {\n      paths = Module._resolveLookupPaths(request\x2C parent);\n    } else {\n      throw new ERR_INVALID_ARG_VALUE('options.paths'\x2C options.paths);\n    }\n  } else {\n    paths = Module._resolveLookupPaths(request\x2C parent);\n  }\n\n  if (request[0] === '#' && (parent?.filename || parent?.id === '<repl>')) {\n    const parentPath = parent?.filename ?? process.cwd() + path.sep;\n    const pkg = packageJsonReader.readPackageScope(parentPath) || { __proto__: null };\n    if (pkg.data?.imports != null) {\n      try {\n        const { packageImportsResolve } = require('internal/modules/esm/resolve');\n        return finalizeEsmResolution(\n          packageImportsResolve(request\x2C pathToFileURL(parentPath)\x2C\n                                getCjsConditions())\x2C parentPath\x2C\n          pkg.path);\n      } catch (e) {\n        if (e.code === 'ERR_MODULE_NOT_FOUND') {\n          throw createEsmNotFoundErr(request);\n        }\n        throw e;\n      }\n    }\n  }\n\n  // Try module self resolution first\n  const parentPath = trySelfParentPath(parent);\n  const selfResolved = trySelf(parentPath\x2C request);\n  if (selfResolved) {\n    const cacheKey = request + '\\x00' +\n         (paths.length === 1 ? paths[0] : ArrayPrototypeJoin(paths\x2C '\\x00'));\n    Module._pathCache[cacheKey] = selfResolved;\n    return selfResolved;\n  }\n\n  // Look up the filename first\x2C since that's the cache key.\n  const filename = Module._findPath(request\x2C paths\x2C isMain);\n  if (filename) { return filename; }\n  const requireStack = [];\n  for (let cursor = parent;\n    cursor;\n    cursor = moduleParentCache.get(cursor)) {\n    ArrayPrototypePush(requireStack\x2C cursor.filename || cursor.id);\n  }\n  let message = `Cannot find module '${request}'`;\n  if (requireStack.length > 0) {\n    message = message + '\\nRequire stack:\\n- ' +\n              ArrayPrototypeJoin(requireStack\x2C '\\n- ');\n  }\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  err.code = 'MODULE_NOT_FOUND';\n  err.requireStack = requireStack;\n  throw err;\n};\n\n/**\n * Finishes resolving an ES module specifier into an absolute file path.\n * @param {string} resolved The resolved module specifier\n * @param {string} parentPath The path of the parent module\n * @param {string} pkgPath The path of the package.json file\n * @throws {ERR_INVALID_MODULE_SPECIFIER} If the resolved module specifier contains encoded `/` or `\\\\` characters\n * @throws {Error} If the module cannot be found\n */\nfunction finalizeEsmResolution(resolved\x2C parentPath\x2C pkgPath) {\n  const { encodedSepRegEx } = require('internal/modules/esm/resolve');\n  if (RegExpPrototypeExec(encodedSepRegEx\x2C resolved) !== null) {\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved\x2C 'must not include encoded "/" or "\\\\" characters'\x2C parentPath);\n  }\n  const filename = fileURLToPath(resolved);\n  const actual = tryFile(filename);\n  if (actual) {\n    return actual;\n  }\n  const err = createEsmNotFoundErr(filename\x2C\n                                   path.resolve(pkgPath\x2C 'package.json'));\n  throw err;\n}\n\n/**\n * Creates an error object for when a requested ES module cannot be found.\n * @param {string} request The name of the requested module\n * @param {string} [path] The path to the requested module\n */\nfunction createEsmNotFoundErr(request\x2C path) {\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(`Cannot find module '${request}'`);\n  err.code = 'MODULE_NOT_FOUND';\n  if (path) {\n    err.path = path;\n  }\n  // TODO(BridgeAR): Add the requireStack as well.\n  return err;\n}\n\n/**\n * Given a file name\x2C pass it to the proper extension handler.\n * @param {string} filename The `require` specifier\n */\nModule.prototype.load = function(filename) {\n  debug('load %j for module %j'\x2C filename\x2C this.id);\n\n  assert(!this.loaded);\n  this.filename = filename;\n  this.paths = Module._nodeModulePaths(path.dirname(filename));\n\n  const extension = findLongestRegisteredExtension(filename);\n  // allow .mjs to be overridden\n  if (StringPrototypeEndsWith(filename\x2C '.mjs') && !Module._extensions['.mjs']) {\n    throw new ERR_REQUIRE_ESM(filename\x2C true);\n  }\n\n  Module._extensions[extension](this\x2C filename);\n  this.loaded = true;\n\n  const cascadedLoader = getCascadedLoader();\n  // Create module entry at load time to snapshot exports correctly\n  const exports = this.exports;\n  // Preemptively cache\n  if ((module?.module === undefined ||\n       module.module.getStatus() < kEvaluated) &&\n      !cascadedLoader.cjsCache.has(this)) {\n    cascadedLoader.cjsCache.set(this\x2C exports);\n  }\n};\n\n/**\n * Loads a module at the given file path. Returns that module's `exports` property.\n * Note: when using the experimental policy mechanism this function is overridden.\n * @param {string} id\n * @throws {ERR_INVALID_ARG_TYPE} When `id` is not a string\n */\nModule.prototype.require = function(id) {\n  validateString(id\x2C 'id');\n  if (id === '') {\n    throw new ERR_INVALID_ARG_VALUE('id'\x2C id\x2C\n                                    'must be a non-empty string');\n  }\n  requireDepth++;\n  try {\n    return Module._load(id\x2C this\x2C /* isMain */ false);\n  } finally {\n    requireDepth--;\n  }\n};\n\n/**\n * Resolved path to `process.argv[1]` will be lazily placed here\n * (needed for setting breakpoint when called with `--inspect-brk`).\n * @type {string | undefined}\n */\nlet resolvedArgv;\nlet hasPausedEntry = false;\n/** @type {import('vm').Script} */\n\n/**\n * Wraps the given content in a script and runs it in a new context.\n * @param {string} filename The name of the file being loaded\n * @param {string} content The content of the file being loaded\n * @param {Module} cjsModuleInstance The CommonJS loader instance\n * @param {object} codeCache The SEA code cache\n */\nfunction wrapSafe(filename\x2C content\x2C cjsModuleInstance\x2C codeCache) {\n  const hostDefinedOptionId = Symbol(`cjs:${filename}`);\n  async function importModuleDynamically(specifier\x2C _\x2C importAttributes) {\n    const cascadedLoader = getCascadedLoader();\n    return cascadedLoader.import(specifier\x2C normalizeReferrerURL(filename)\x2C\n                                 importAttributes);\n  }\n  if (patched) {\n    const wrapped = Module.wrap(content);\n    const script = makeContextifyScript(\n      wrapped\x2C                 // code\n      filename\x2C                // filename\n      0\x2C                       // lineOffset\n      0\x2C                       // columnOffset\n      undefined\x2C               // cachedData\n      false\x2C                   // produceCachedData\n      undefined\x2C               // parsingContext\n      hostDefinedOptionId\x2C     // hostDefinedOptionId\n      importModuleDynamically\x2C // importModuleDynamically\n    );\n\n    // Cache the source map for the module if present.\n    if (script.sourceMapURL) {\n      maybeCacheSourceMap(filename\x2C content\x2C this\x2C false\x2C undefined\x2C script.sourceMapURL);\n    }\n\n    return runScriptInThisContext(script\x2C true\x2C false);\n  }\n\n  const params = [ 'exports'\x2C 'require'\x2C 'module'\x2C '__filename'\x2C '__dirname' ];\n  try {\n    const result = internalCompileFunction(\n      content\x2C                           // code\x2C\n      filename\x2C                          // filename\n      0\x2C                                 // lineOffset\n      0\x2C                                 // columnOffset\x2C\n      codeCache\x2C                         // cachedData\n      false\x2C                             // produceCachedData\n      undefined\x2C                         // parsingContext\n      undefined\x2C                         // contextExtensions\n      params\x2C                            // params\n      hostDefinedOptionId\x2C               // hostDefinedOptionId\n      importModuleDynamically\x2C           // importModuleDynamically\n    );\n\n    // The code cache is used for SEAs only.\n    if (codeCache &&\n        result.cachedDataRejected !== false &&\n        internalBinding('sea').isSea()) {\n      process.emitWarning('Code cache data rejected.');\n    }\n\n    // Cache the source map for the module if present.\n    if (result.sourceMapURL) {\n      maybeCacheSourceMap(filename\x2C content\x2C this\x2C false\x2C undefined\x2C result.sourceMapURL);\n    }\n\n    return result.function;\n  } catch (err) {\n    if (process.mainModule === cjsModuleInstance) {\n      const { enrichCJSError } = require('internal/modules/esm/translators');\n      enrichCJSError(err\x2C content\x2C filename);\n    }\n    throw err;\n  }\n}\n\n/**\n * Run the file contents in the correct scope or sandbox. Expose the correct helper variables (`require`\x2C `module`\x2C\n * `exports`) to the file. Returns exception\x2C if any.\n * @param {string} content The source code of the module\n * @param {string} filename The file path of the module\n */\nModule.prototype._compile = function(content\x2C filename) {\n  let moduleURL;\n  let redirects;\n  const manifest = policy()?.manifest;\n  if (manifest) {\n    moduleURL = pathToFileURL(filename);\n    redirects = manifest.getDependencyMapper(moduleURL);\n    manifest.assertIntegrity(moduleURL\x2C content);\n  }\n\n  const compiledWrapper = wrapSafe(filename\x2C content\x2C this);\n\n  let inspectorWrapper = null;\n  if (getOptionValue('--inspect-brk') && process._eval == null) {\n    if (!resolvedArgv) {\n      // We enter the repl if we're not given a filename argument.\n      if (process.argv[1]) {\n        try {\n          resolvedArgv = Module._resolveFilename(process.argv[1]\x2C null\x2C false);\n        } catch {\n          // We only expect this codepath to be reached in the case of a\n          // preloaded module (it will fail earlier with the main entry)\n          assert(ArrayIsArray(getOptionValue('--require')));\n        }\n      } else {\n        resolvedArgv = 'repl';\n      }\n    }\n\n    // Set breakpoint on module start\n    if (resolvedArgv && !hasPausedEntry && filename === resolvedArgv) {\n      hasPausedEntry = true;\n      inspectorWrapper = internalBinding('inspector').callAndPauseOnStart;\n    }\n  }\n  const dirname = path.dirname(filename);\n  const require = makeRequireFunction(this\x2C redirects);\n  let result;\n  const exports = this.exports;\n  const thisValue = exports;\n  const module = this;\n  if (requireDepth === 0) { statCache = new SafeMap(); }\n  if (inspectorWrapper) {\n    result = inspectorWrapper(compiledWrapper\x2C thisValue\x2C exports\x2C\n                              require\x2C module\x2C filename\x2C dirname);\n  } else {\n    result = ReflectApply(compiledWrapper\x2C thisValue\x2C\n                          [exports\x2C require\x2C module\x2C filename\x2C dirname]);\n  }\n  hasLoadedAnyUserCJSModule = true;\n  if (requireDepth === 0) { statCache = null; }\n  return result;\n};\n\n/**\n * Native handler for `.js` files.\n * @param {Module} module The module to compile\n * @param {string} filename The file path of the module\n */\nModule._extensions['.js'] = function(module\x2C filename) {\n  // If already analyzed the source\x2C then it will be cached.\n  const cached = cjsParseCache.get(module);\n  let content;\n  if (cached?.source) {\n    content = cached.source;\n    cached.source = undefined;\n  } else {\n    content = fs.readFileSync(filename\x2C 'utf8');\n  }\n  if (StringPrototypeEndsWith(filename\x2C '.js')) {\n    const pkg = packageJsonReader.readPackageScope(filename) || { __proto__: null };\n    // Function require shouldn't be used in ES modules.\n    if (pkg.data?.type === 'module') {\n      // This is an error path because `require` of a `.js` file in a `"type": "module"` scope is not allowed.\n      const parent = moduleParentCache.get(module);\n      const parentPath = parent?.filename;\n      const packageJsonPath = path.resolve(pkg.path\x2C 'package.json');\n      const usesEsm = containsModuleSyntax(content\x2C filename);\n      const err = new ERR_REQUIRE_ESM(filename\x2C usesEsm\x2C parentPath\x2C\n                                      packageJsonPath);\n      // Attempt to reconstruct the parent require frame.\n      if (Module._cache[parentPath]) {\n        let parentSource;\n        try {\n          parentSource = fs.readFileSync(parentPath\x2C 'utf8');\n        } catch {\n          // Continue regardless of error.\n        }\n        if (parentSource) {\n          const errLine = StringPrototypeSplit(\n            StringPrototypeSlice(err.stack\x2C StringPrototypeIndexOf(\n              err.stack\x2C '    at '))\x2C '\\n'\x2C 1)[0];\n          const { 1: line\x2C 2: col } =\n              RegExpPrototypeExec(/(\\d+):(\\d+)\\)/\x2C errLine) || [];\n          if (line && col) {\n            const srcLine = StringPrototypeSplit(parentSource\x2C '\\n')[line - 1];\n            const frame = `${parentPath}:${line}\\n${srcLine}\\n${\n              StringPrototypeRepeat(' '\x2C col - 1)}^\\n`;\n            setArrowMessage(err\x2C frame);\n          }\n        }\n      }\n      throw err;\n    }\n  }\n  module._compile(content\x2C filename);\n};\n\n/**\n * Native handler for `.json` files.\n * @param {Module} module The module to compile\n * @param {string} filename The file path of the module\n */\nModule._extensions['.json'] = function(module\x2C filename) {\n  const content = fs.readFileSync(filename\x2C 'utf8');\n\n  const manifest = policy()?.manifest;\n  if (manifest) {\n    const moduleURL = pathToFileURL(filename);\n    manifest.assertIntegrity(moduleURL\x2C content);\n  }\n\n  try {\n    setOwnProperty(module\x2C 'exports'\x2C JSONParse(stripBOM(content)));\n  } catch (err) {\n    err.message = filename + ': ' + err.message;\n    throw err;\n  }\n};\n\n/**\n * Native handler for `.node` files.\n * @param {Module} module The module to compile\n * @param {string} filename The file path of the module\n */\nModule._extensions['.node'] = function(module\x2C filename) {\n  const manifest = policy()?.manifest;\n  if (manifest) {\n    const content = fs.readFileSync(filename);\n    const moduleURL = pathToFileURL(filename);\n    manifest.assertIntegrity(moduleURL\x2C content);\n  }\n  // Be aware this doesn't use `content`\n  return process.dlopen(module\x2C path.toNamespacedPath(filename));\n};\n\n/**\n * Creates a `require` function that can be used to load modules from the specified path.\n * @param {string} filename The path to the module\n */\nfunction createRequireFromPath(filename) {\n  // Allow a directory to be passed as the filename\n  const trailingSlash =\n    StringPrototypeEndsWith(filename\x2C '/') ||\n    (isWindows && StringPrototypeEndsWith(filename\x2C '\\\\'));\n\n  const proxyPath = trailingSlash ?\n    path.join(filename\x2C 'noop.js') :\n    filename;\n\n  const m = new Module(proxyPath);\n  m.filename = proxyPath;\n\n  m.paths = Module._nodeModulePaths(m.path);\n  return makeRequireFunction(m\x2C null);\n}\n\nconst createRequireError = 'must be a file URL object\x2C file URL string\x2C or ' +\n  'absolute path string';\n\n/**\n * Creates a new `require` function that can be used to load modules.\n * @param {string | URL} filename The path or URL to the module context for this `require`\n * @throws {ERR_INVALID_ARG_VALUE} If `filename` is not a string or URL\x2C or if it is a relative path that cannot be\n * resolved to an absolute path.\n */\nfunction createRequire(filename) {\n  let filepath;\n\n  if (isURL(filename) ||\n      (typeof filename === 'string' && !path.isAbsolute(filename))) {\n    try {\n      filepath = fileURLToPath(filename);\n    } catch {\n      throw new ERR_INVALID_ARG_VALUE('filename'\x2C filename\x2C\n                                      createRequireError);\n    }\n  } else if (typeof filename !== 'string') {\n    throw new ERR_INVALID_ARG_VALUE('filename'\x2C filename\x2C createRequireError);\n  } else {\n    filepath = filename;\n  }\n  return createRequireFromPath(filepath);\n}\n\nModule.createRequire = createRequire;\n\n/**\n * Define the paths to use for resolving a module.\n */\nModule._initPaths = function() {\n  const homeDir = isWindows ? process.env.USERPROFILE : safeGetenv('HOME');\n  const nodePath = isWindows ? process.env.NODE_PATH : safeGetenv('NODE_PATH');\n\n  // process.execPath is $PREFIX/bin/node except on Windows where it is\n  // $PREFIX\\node.exe where $PREFIX is the root of the Node.js installation.\n  const prefixDir = isWindows ?\n    path.resolve(process.execPath\x2C '..') :\n    path.resolve(process.execPath\x2C '..'\x2C '..');\n\n  const paths = [path.resolve(prefixDir\x2C 'lib'\x2C 'node')];\n\n  if (homeDir) {\n    ArrayPrototypeUnshift(paths\x2C path.resolve(homeDir\x2C '.node_libraries'));\n    ArrayPrototypeUnshift(paths\x2C path.resolve(homeDir\x2C '.node_modules'));\n  }\n\n  if (nodePath) {\n    ArrayPrototypeUnshiftApply(paths\x2C ArrayPrototypeFilter(\n      StringPrototypeSplit(nodePath\x2C path.delimiter)\x2C\n      Boolean\x2C\n    ));\n  }\n\n  modulePaths = paths;\n\n  // Clone as a shallow copy\x2C for introspection.\n  Module.globalPaths = ArrayPrototypeSlice(modulePaths);\n};\n\n/**\n * Handle modules loaded via `--require`.\n * @param {string[]} requests The values of `--require`\n */\nModule._preloadModules = function(requests) {\n  if (!ArrayIsArray(requests)) { return; }\n\n  isPreloading = true;\n\n  // Preloaded modules have a dummy parent module which is deemed to exist\n  // in the current working directory. This seeds the search path for\n  // preloaded modules.\n  const parent = new Module('internal/preload'\x2C null);\n  try {\n    parent.paths = Module._nodeModulePaths(process.cwd());\n  } catch (e) {\n    if (e.code !== 'ENOENT') {\n      isPreloading = false;\n      throw e;\n    }\n  }\n  for (let n = 0; n < requests.length; n++) {\n    internalRequire(parent\x2C requests[n]);\n  }\n  isPreloading = false;\n};\n\n/**\n * If the user has overridden an export from a builtin module\x2C this function can ensure that the override is used in\n * both CommonJS and ES module contexts.\n */\nModule.syncBuiltinESMExports = function syncBuiltinESMExports() {\n  for (const mod of BuiltinModule.map.values()) {\n    if (BuiltinModule.canBeRequiredWithoutScheme(mod.id)) {\n      mod.syncExports();\n    }\n  }\n};\n\nObjectDefineProperty(Module.prototype\x2C 'constructor'\x2C {\n  __proto__: null\x2C\n  get: function() {\n    return policy() ? undefined : Module;\n  }\x2C\n  configurable: false\x2C\n  enumerable: false\x2C\n});\n\n// Backwards compatibility\nModule.Module = Module;\n
code-source-info,0x31e6f6b5851e,63,10714,11192,C0O10816C5O10830C10O10830C15O10876C20O10900C23O10900C27O10898C31O10933C36O10933C39O10963C44O10968C48O10988C54O11016C57O11023C62O11023C66O11110C75O11131C80O11167C84O11125C89O11191,,
tick,0x10c1658e3,51849,0,0x0,3,0x10c9f09d0,0x31e6f6b583ce,0x31e6f6b58283,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
tick,0x7ff8092cbace,51870,0,0x0,3,0x10c9f09d0,0x31e6f6b583ce,0x31e6f6b58283,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
tick,0x7ff8093038b3,51877,0,0x0,3,0x10c9f09d0,0x31e6f6b583ce,0x31e6f6b58283,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,51887,0x31e6f6b5b8e6,19,getCanBeRequiredByUsersWithoutSchemeList node:internal/bootstrap/realm:322:50,0x31e6931b6d60,~
code-source-info,0x31e6f6b5b8e6,9,10233,10302,C0O10242C11O10259C14O10249C18O10298,,
code-creation,JS,10,51941,0x31e6f6b5b9d6,13,desc.value node:internal/per_context/primordials:387:32,0x31e6931b49a0,~
code-source-info,0x31e6f6b5b9d6,6,11247,11306,C0O11264C7O11271C12O11294,,
code-creation,JS,10,51977,0x31e6f6b5baf6,13,SafeIterator node:internal/per_context/primordials:332:16,0x31e6931b40f0,~
code-source-info,0x31e6f6b5baf6,6,9510,9570,C0O9529C3O9546C7O9544C12O9569,,
code-creation,JS,10,52025,0x31e6f6b5bcfe,13,next node:internal/per_context/primordials:335:9,0x31e6931b4140,~
code-source-info,0x31e6f6b5bcfe,6,9579,9624,C0O9590C3O9607C8O9597C12O9618,,
code-creation,JS,10,52123,0x31e6f6b5bfee,158,initializeCjsConditions node:internal/modules/helpers:65:33,0x31e647c77e48,~
script-source,64,node:internal/modules/helpers,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeJoin\x2C\n  ObjectDefineProperty\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_MANIFEST_DEPENDENCY_MISSING\x2C\n  ERR_UNKNOWN_BUILTIN_MODULE\x2C\n} = require('internal/errors').codes;\nconst { BuiltinModule } = require('internal/bootstrap/realm');\n\nconst { validateString } = require('internal/validators');\nconst fs = require('fs'); // Import all of `fs` so that it can be monkey-patched.\nconst internalFS = require('internal/fs/utils');\nconst path = require('path');\nconst { pathToFileURL\x2C fileURLToPath\x2C URL } = require('internal/url');\n\nconst { getOptionValue } = require('internal/options');\nconst { setOwnProperty } = require('internal/util');\n\nconst {\n  privateSymbols: {\n    require_private_symbol\x2C\n  }\x2C\n} = internalBinding('util');\n\nlet debug = require('internal/util/debuglog').debuglog('module'\x2C (fn) => {\n  debug = fn;\n});\n\n/** @typedef {import('internal/modules/cjs/loader.js').Module} Module */\n\n/**\n * Cache for storing resolved real paths of modules.\n * In order to minimize unnecessary lstat() calls\x2C this cache is a list of known-real paths.\n * Set to an empty Map to reset.\n * @type {Map<string\x2C string>}\n */\nconst realpathCache = new SafeMap();\n/**\n * Resolves the path of a given `require` specifier\x2C following symlinks.\n * @param {string} requestPath The `require` specifier\n */\nfunction toRealPath(requestPath) {\n  return fs.realpathSync(requestPath\x2C {\n    [internalFS.realpathCacheKey]: realpathCache\x2C\n  });\n}\n\n/** @type {Set<string>} */\nlet cjsConditions;\n/**\n * Define the conditions that apply to the CommonJS loader.\n */\nfunction initializeCjsConditions() {\n  const userConditions = getOptionValue('--conditions');\n  const noAddons = getOptionValue('--no-addons');\n  const addonConditions = noAddons ? [] : ['node-addons'];\n  // TODO: Use this set when resolving pkg#exports conditions in loader.js.\n  cjsConditions = new SafeSet([\n    'require'\x2C\n    'node'\x2C\n    ...addonConditions\x2C\n    ...userConditions\x2C\n  ]);\n}\n\n/**\n * Get the conditions that apply to the CommonJS loader.\n */\nfunction getCjsConditions() {\n  if (cjsConditions === undefined) {\n    initializeCjsConditions();\n  }\n  return cjsConditions;\n}\n\n/**\n * Provide one of Node.js' public modules to user code.\n * @param {string} id - The identifier/specifier of the builtin module to load\n * @param {string} request - The module requiring or importing the builtin module\n */\nfunction loadBuiltinModule(id\x2C request) {\n  if (!BuiltinModule.canBeRequiredByUsers(id)) {\n    return;\n  }\n  /** @type {import('internal/bootstrap/realm.js').BuiltinModule} */\n  const mod = BuiltinModule.map.get(id);\n  debug('load built-in module %s'\x2C request);\n  // compileForPublicLoader() throws if canBeRequiredByUsers is false:\n  mod.compileForPublicLoader();\n  return mod;\n}\n\n/** @type {Module} */\nlet $Module = null;\n/**\n * Import the Module class on first use.\n */\nfunction lazyModule() {\n  $Module = $Module || require('internal/modules/cjs/loader').Module;\n  return $Module;\n}\n\n/**\n * Invoke with `makeRequireFunction(module)` where `module` is the `Module` object to use as the context for the\n * `require()` function.\n * Use redirects to set up a mapping from a policy and restrict dependencies.\n */\nconst urlToFileCache = new SafeMap();\n/**\n * Create the module-scoped `require` function to pass into CommonJS modules.\n * @param {Module} mod - The module to create the `require` function for.\n * @param {ReturnType<import('internal/policy/manifest.js').Manifest['getDependencyMapper']>} redirects\n * @typedef {(specifier: string) => unknown} RequireFunction\n */\nfunction makeRequireFunction(mod\x2C redirects) {\n  // lazy due to cycle\n  const Module = lazyModule();\n  if (mod instanceof Module !== true) {\n    throw new ERR_INVALID_ARG_TYPE('mod'\x2C 'Module'\x2C mod);\n  }\n\n  /** @type {RequireFunction} */\n  let require;\n  if (redirects) {\n    const id = mod.filename || mod.id;\n    const conditions = getCjsConditions();\n    const { resolve\x2C reaction } = redirects;\n    require = function require(specifier) {\n      let missing = true;\n      const destination = resolve(specifier\x2C conditions);\n      if (destination === true) {\n        missing = false;\n      } else if (destination) {\n        const { href\x2C protocol } = destination;\n        if (protocol === 'node:') {\n          const specifier = destination.pathname;\n\n          if (BuiltinModule.canBeRequiredByUsers(specifier)) {\n            const mod = loadBuiltinModule(specifier\x2C href);\n            return mod.exports;\n          }\n          throw new ERR_UNKNOWN_BUILTIN_MODULE(specifier);\n        } else if (protocol === 'file:') {\n          let filepath = urlToFileCache.get(href);\n          if (!filepath) {\n            filepath = fileURLToPath(destination);\n            urlToFileCache.set(href\x2C filepath);\n          }\n          return mod[require_private_symbol](mod\x2C filepath);\n        }\n      }\n      if (missing) {\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(\n          id\x2C\n          specifier\x2C\n          ArrayPrototypeJoin([...conditions]\x2C '\x2C ')\x2C\n        ));\n      }\n      return mod[require_private_symbol](mod\x2C specifier);\n    };\n  } else {\n    require = function require(path) {\n      // When no policy manifest\x2C the original prototype.require is sustained\n      return mod.require(path);\n    };\n  }\n\n  /**\n   * The `resolve` method that gets attached to module-scope `require`.\n   * @param {string} request\n   * @param {Parameters<Module['_resolveFilename']>[3]} options\n   */\n  function resolve(request\x2C options) {\n    validateString(request\x2C 'request');\n    return Module._resolveFilename(request\x2C mod\x2C false\x2C options);\n  }\n\n  require.resolve = resolve;\n\n  /**\n   * The `paths` method that gets attached to module-scope `require`.\n   * @param {string} request\n   */\n  function paths(request) {\n    validateString(request\x2C 'request');\n    return Module._resolveLookupPaths(request\x2C mod);\n  }\n\n  resolve.paths = paths;\n\n  setOwnProperty(require\x2C 'main'\x2C process.mainModule);\n\n  // Enable support to add extra extension types.\n  require.extensions = Module._extensions;\n\n  require.cache = Module._cache;\n\n  return require;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n * because the buffer-to-string conversion in `fs.readFileSync()`\n * translates it to FEFF\x2C the UTF-16 BOM.\n * @param {string} content\n */\nfunction stripBOM(content) {\n  if (StringPrototypeCharCodeAt(content) === 0xFEFF) {\n    content = StringPrototypeSlice(content\x2C 1);\n  }\n  return content;\n}\n\n/**\n * Add built-in modules to a global or REPL scope object.\n * @param {Record<string\x2C unknown>} object - The object such as `globalThis` to add the built-in modules to.\n * @param {string} dummyModuleName - The label representing the set of built-in modules to add.\n */\nfunction addBuiltinLibsToObject(object\x2C dummyModuleName) {\n  // Make built-in modules available directly (loaded lazily).\n  const Module = require('internal/modules/cjs/loader').Module;\n  const { builtinModules } = Module;\n\n  // To require built-in modules in user-land and ignore modules whose\n  // `canBeRequiredByUsers` is false. So we create a dummy module object and not\n  // use `require()` directly.\n  const dummyModule = new Module(dummyModuleName);\n\n  ArrayPrototypeForEach(builtinModules\x2C (name) => {\n    // Neither add underscored modules\x2C nor ones that contain slashes (e.g.\x2C\n    // 'fs/promises') or ones that are already defined.\n    if (StringPrototypeStartsWith(name\x2C '_') ||\n        StringPrototypeIncludes(name\x2C '/') ||\n        ObjectPrototypeHasOwnProperty(object\x2C name)) {\n      return;\n    }\n    // Goals of this mechanism are:\n    // - Lazy loading of built-in modules\n    // - Having all built-in modules available as non-enumerable properties\n    // - Allowing the user to re-assign these variables as if there were no\n    //   pre-existing globals with the same name.\n\n    const setReal = (val) => {\n      // Deleting the property before re-assigning it disables the\n      // getter/setter mechanism.\n      delete object[name];\n      object[name] = val;\n    };\n\n    ObjectDefineProperty(object\x2C name\x2C {\n      __proto__: null\x2C\n      get: () => {\n        const lib = dummyModule.require(name);\n\n        try {\n          // Override the current getter/setter and set up a new\n          // non-enumerable property.\n          ObjectDefineProperty(object\x2C name\x2C {\n            __proto__: null\x2C\n            get: () => lib\x2C\n            set: setReal\x2C\n            configurable: true\x2C\n            enumerable: false\x2C\n          });\n        } catch {\n          // If the property is no longer configurable\x2C ignore the error.\n        }\n\n        return lib;\n      }\x2C\n      set: setReal\x2C\n      configurable: true\x2C\n      enumerable: false\x2C\n    });\n  });\n}\n\n/**\n * If a referrer is an URL instance or absolute path\x2C convert it into an URL string.\n * @param {string | URL} referrer\n */\nfunction normalizeReferrerURL(referrer) {\n  if (typeof referrer === 'string' && path.isAbsolute(referrer)) {\n    return pathToFileURL(referrer).href;\n  }\n  return new URL(referrer).href;\n}\n\nmodule.exports = {\n  addBuiltinLibsToObject\x2C\n  getCjsConditions\x2C\n  initializeCjsConditions\x2C\n  loadBuiltinModule\x2C\n  makeRequireFunction\x2C\n  normalizeReferrerURL\x2C\n  stripBOM\x2C\n  toRealPath\x2C\n};\n
code-source-info,0x31e6f6b5bfee,64,1806,2166,C0O1836C8O1836C13O1887C21O1887C26O1944C37O2055C50O2119C95O2143C142O2071C150O2069C157O2165,,
code-creation,JS,10,52732,0x31e6f6b5cd86,315,Module._initPaths node:internal/modules/cjs/loader:1530:29,0x31e647c776d8,~
code-source-info,0x31e6f6b5cd86,63,49693,50650,C0O49716C9O49736C14O49740C22O49754C28O49754C33O49793C42O49813C47O49817C55O49829C61O49829C66O50024C74O50040C77O50045C85O50061C93O50045C103O50083C106O50088C114O50104C125O50088C131O50144C140O50145C143O50150C157O50150C169O50189C173O50208C180O50237C183O50242C191O50242C198O50208C203O50284C210O50313C213O50318C221O50318C228O50284C233O50361C237O50381C244O50415C249O50443C254O50474C257O50479C262O50443C270O50497C273O50415C279O50381C284O50521C286O50533C292O50594C297O50615C302O50635C305O50615C309O50613C314O50649,,
code-creation,JS,11,52859,0x112584940,1348,resolve node:path:1095:10,0x31e647c5b680,^
code-source-info,0x112584940,34,33911,34827,,,
code-creation,JS,11,52885,0x112584ec0,412,getCLIOptionsFromBinding node:internal/options:18:34,0x31e647c44760,^
code-source-info,0x112584ec0,17,497,598,,,
code-creation,JS,11,52906,0x112585080,100,next node:internal/per_context/primordials:335:9,0x31e6931b4140,^
code-source-info,0x112585080,6,9579,9624,,,
code-creation,JS,11,52925,0x112585100,316,SafeSet node:internal/per_context/primordials:426:16,0x31e6931b4dc8,^
code-source-info,0x112585100,6,12304,12321,,,
code-creation,JS,11,53003,0x112585280,3028,normalizeString node:path:66:25,0x31e647c5b220,^
code-source-info,0x112585280,34,2161,4085,,,
tick,0x10c8d1ab0,53159,0,0x0,0,0x10c9f9070,0x31e6f6b42a48,0x31e6f6b5ce63,0x31e6f6b5855c,0x31e6f6b583ce,0x31e6f6b58283,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,53213,0x31e6f6b5d7ae,91,initializeESMLoader node:internal/process/pre_execution:711:29,0x31e647c79eb8,~
code-source-info,0x31e6f6b5d7ae,67,22287,22842,C0O22338C6O22338C11O22320C16O22379C20O22546C28O22550C34O22666C40O22666C45O22615C50O22623C55O22641C60O22712C66O22712C71O22731C73O22741C77O22755C79O22775C83O22799C85O22818C90O22841,,
code-creation,JS,10,53290,0x31e6f6b5d926,50,initializeESM node:internal/modules/esm/utils:223:23,0x31e647c78c48,~
script-source,66,node:internal/modules/esm/utils,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  SafeSet\x2C\n  SafeWeakMap\x2C\n  Symbol\x2C\n  ObjectFreeze\x2C\n} = primordials;\n\nconst {\n  privateSymbols: {\n    host_defined_option_symbol\x2C\n  }\x2C\n} = internalBinding('util');\nconst {\n  default_host_defined_options\x2C\n  vm_dynamic_import_missing_flag\x2C\n} = internalBinding('symbols');\n\nconst {\n  ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING_FLAG\x2C\n  ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n} = require('internal/errors').codes;\nconst { getOptionValue } = require('internal/options');\nconst {\n  loadPreloadModules\x2C\n  initializeFrozenIntrinsics\x2C\n} = require('internal/process/pre_execution');\nconst { getCWDURL } = require('internal/util');\nconst {\n  setImportModuleDynamicallyCallback\x2C\n  setInitializeImportMetaObjectCallback\x2C\n} = internalBinding('module_wrap');\nconst assert = require('internal/assert');\n\nlet defaultConditions;\n/**\n * Returns the default conditions for ES module loading.\n */\nfunction getDefaultConditions() {\n  assert(defaultConditions !== undefined);\n  return defaultConditions;\n}\n\n/** @type {Set<string>} */\nlet defaultConditionsSet;\n/**\n * Returns the default conditions for ES module loading\x2C as a Set.\n */\nfunction getDefaultConditionsSet() {\n  assert(defaultConditionsSet !== undefined);\n  return defaultConditionsSet;\n}\n\n/**\n * Initializes the default conditions for ESM module loading.\n * This function is called during pre-execution\x2C before any user code is run.\n */\nfunction initializeDefaultConditions() {\n  const userConditions = getOptionValue('--conditions');\n  const noAddons = getOptionValue('--no-addons');\n  const addonConditions = noAddons ? [] : ['node-addons'];\n\n  defaultConditions = ObjectFreeze([\n    'node'\x2C\n    'import'\x2C\n    ...addonConditions\x2C\n    ...userConditions\x2C\n  ]);\n  defaultConditionsSet = new SafeSet(defaultConditions);\n}\n\n/**\n * @param {string[]} [conditions]\n * @returns {Set<string>}\n */\nfunction getConditionsSet(conditions) {\n  if (conditions !== undefined && conditions !== getDefaultConditions()) {\n    if (!ArrayIsArray(conditions)) {\n      throw new ERR_INVALID_ARG_VALUE('conditions'\x2C conditions\x2C\n                                      'expected an array');\n    }\n    return new SafeSet(conditions);\n  }\n  return getDefaultConditionsSet();\n}\n\n/**\n * @callback ImportModuleDynamicallyCallback\n * @param {string} specifier\n * @param {ModuleWrap|ContextifyScript|Function|vm.Module} callbackReferrer\n * @param {Record<string\x2C string>} attributes\n * @returns { Promise<void> }\n */\n\n/**\n * @callback InitializeImportMetaCallback\n * @param {object} meta\n * @param {ModuleWrap|ContextifyScript|Function|vm.Module} callbackReferrer\n */\n\n/**\n * @typedef {{\n *   callbackReferrer: ModuleWrap|ContextifyScript|Function|vm.Module\n *   initializeImportMeta? : InitializeImportMetaCallback\x2C\n *   importModuleDynamically? : ImportModuleDynamicallyCallback\n * }} ModuleRegistry\n */\n\n/**\n * @type {WeakMap<symbol\x2C ModuleRegistry>}\n */\nconst moduleRegistries = new SafeWeakMap();\n\n/**\n * @typedef {ContextifyScript|Function|ModuleWrap|ContextifiedObject} Referrer\n * A referrer can be a Script Record\x2C a Cyclic Module Record\x2C or a Realm Record\n * as defined in https://tc39.es/ecma262/#sec-HostLoadImportedModule.\n *\n * In Node.js\x2C a referrer is represented by a wrapper object of these records.\n * A referrer object has a field |host_defined_option_symbol| initialized with\n * a symbol.\n */\n\n/**\n * V8 would make sure that as long as import() can still be initiated from\n * the referrer\x2C the symbol referenced by |host_defined_option_symbol| should\n * be alive\x2C which in term would keep the settings object alive through the\n * WeakMap\x2C and in turn that keeps the referrer object alive\x2C which would be\n * passed into the callbacks.\n * The reference goes like this:\n * [v8::internal::Script] (via host defined options) ----1--> [idSymbol]\n * [callbackReferrer] (via host_defined_option_symbol) ------2------^  |\n *                                 ^----------3---- (via WeakMap)------\n * 1+3 makes sure that as long as import() can still be initiated\x2C the\n * referrer wrap is still around and can be passed into the callbacks.\n * 2 is only there so that we can get the id symbol to configure the\n * weak map.\n * @param {Referrer} referrer The referrer to\n *   get the id symbol from. This is different from callbackReferrer which\n *   could be set by the caller.\n * @param {ModuleRegistry} registry\n */\nfunction registerModule(referrer\x2C registry) {\n  const idSymbol = referrer[host_defined_option_symbol];\n  if (idSymbol === default_host_defined_options ||\n      idSymbol === vm_dynamic_import_missing_flag) {\n    // The referrer is compiled without custom callbacks\x2C so there is\n    // no registry to hold on to. We'll throw\n    // ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING when a callback is\n    // needed.\n    return;\n  }\n  // To prevent it from being GC'ed.\n  registry.callbackReferrer ??= referrer;\n  moduleRegistries.set(idSymbol\x2C registry);\n}\n\n/**\n * Registers the ModuleRegistry for dynamic import() calls with a realm\n * as the referrer. Similar to {@link registerModule}\x2C but this function\n * generates a new id symbol instead of using the one from the referrer\n * object.\n * @param {globalThis} globalThis The globalThis object of the realm.\n * @param {ModuleRegistry} registry\n */\nfunction registerRealm(globalThis\x2C registry) {\n  let idSymbol = globalThis[host_defined_option_symbol];\n  // If the per-realm host-defined options is already registered\x2C do nothing.\n  if (idSymbol) {\n    return;\n  }\n  // Otherwise\x2C register the per-realm host-defined options.\n  idSymbol = Symbol('Realm globalThis');\n  globalThis[host_defined_option_symbol] = idSymbol;\n  moduleRegistries.set(idSymbol\x2C registry);\n}\n\n/**\n * Defines the `import.meta` object for a given module.\n * @param {symbol} symbol - Reference to the module.\n * @param {Record<string\x2C string | Function>} meta - The import.meta object to initialize.\n */\nfunction initializeImportMetaObject(symbol\x2C meta) {\n  if (moduleRegistries.has(symbol)) {\n    const { initializeImportMeta\x2C callbackReferrer } = moduleRegistries.get(symbol);\n    if (initializeImportMeta !== undefined) {\n      meta = initializeImportMeta(meta\x2C callbackReferrer);\n    }\n  }\n}\n\n/**\n * Asynchronously imports a module dynamically using a callback function. The native callback.\n * @param {symbol} referrerSymbol - Referrer symbol of the registered script\x2C function\x2C module\x2C or contextified object.\n * @param {string} specifier - The module specifier string.\n * @param {Record<string\x2C string>} attributes - The import attributes object.\n * @returns {Promise<import('internal/modules/esm/loader.js').ModuleExports>} - The imported module object.\n * @throws {ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING} - If the callback function is missing.\n */\nasync function importModuleDynamicallyCallback(referrerSymbol\x2C specifier\x2C attributes) {\n  if (moduleRegistries.has(referrerSymbol)) {\n    const { importModuleDynamically\x2C callbackReferrer } = moduleRegistries.get(referrerSymbol);\n    if (importModuleDynamically !== undefined) {\n      return importModuleDynamically(specifier\x2C callbackReferrer\x2C attributes);\n    }\n  }\n  if (referrerSymbol === vm_dynamic_import_missing_flag) {\n    throw new ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING_FLAG();\n  }\n  throw new ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING();\n}\n\nlet _forceDefaultLoader = false;\n/**\n * Initializes handling of ES modules.\n * This is configured during pre-execution. Specifically it's set to true for\n * the loader worker in internal/main/worker_thread.js.\n * @param {boolean} [forceDefaultLoader=false] - A boolean indicating disabling custom loaders.\n */\nfunction initializeESM(forceDefaultLoader = false) {\n  _forceDefaultLoader = forceDefaultLoader;\n  initializeDefaultConditions();\n  // Setup per-realm callbacks that locate data or callbacks that we keep\n  // track of for different ESM modules.\n  setInitializeImportMetaObjectCallback(initializeImportMetaObject);\n  setImportModuleDynamicallyCallback(importModuleDynamicallyCallback);\n}\n\n/**\n * Determine whether custom loaders are disabled and it is forced to use the\n * default loader.\n * @returns {boolean}\n */\nfunction forceDefaultLoader() {\n  return _forceDefaultLoader;\n}\n\n/**\n * Register module customization hooks.\n */\nasync function initializeHooks() {\n  const customLoaderURLs = getOptionValue('--experimental-loader');\n\n  const { Hooks } = require('internal/modules/esm/hooks');\n  const esmLoader = require('internal/process/esm_loader').esmLoader;\n\n  const hooks = new Hooks();\n  esmLoader.setCustomizations(hooks);\n\n  // We need the loader customizations to be set _before_ we start invoking\n  // `--require`\x2C otherwise loops can happen because a `--require` script\n  // might call `register(...)` before we've installed ourselves. These\n  // global values are magically set in `setupUserModules` just for us and\n  // we call them in the correct order.\n  // N.B.  This block appears here specifically in order to ensure that\n  // `--require` calls occur before `--loader` ones do.\n  loadPreloadModules();\n  initializeFrozenIntrinsics();\n\n  const parentURL = getCWDURL().href;\n  for (let i = 0; i < customLoaderURLs.length; i++) {\n    await hooks.register(\n      customLoaderURLs[i]\x2C\n      parentURL\x2C\n    );\n  }\n\n  const preloadScripts = hooks.initializeGlobalPreload();\n\n  return { __proto__: null\x2C hooks\x2C preloadScripts };\n}\n\nmodule.exports = {\n  registerModule\x2C\n  registerRealm\x2C\n  initializeESM\x2C\n  initializeHooks\x2C\n  getDefaultConditions\x2C\n  getConditionsSet\x2C\n  loaderWorkerId: 'internal/modules/esm/worker'\x2C\n  forceDefaultLoader\x2C\n};\n
code-source-info,0x31e6f6b5d926,66,7638,8002,C10O7671C12O7691C18O7715C21O7715C24O7863C32O7863C36O7932C44O7932C49O8001,,
code-creation,JS,10,53926,0x31e6f6b5e416,181,initializeDefaultConditions node:internal/modules/esm/utils:61:37,0x31e647c78a68,~
code-source-info,0x31e6f6b5e416,66,1473,1819,C0O1503C8O1503C13O1554C21O1554C26O1611C37O1647C50O1715C95O1739C140O1667C147O1665C153O1763C160O1798C165O1786C173O1784C180O1818,,
code-creation,JS,10,53980,0x31e6f6b5e60e,5,get hasLoadedAnyUserCJSModule node:internal/modules/cjs/loader:72:32,0x31e647c74e68,~
code-source-info,0x31e6f6b5e60e,63,2217,2257,C0O2222C4O2255,,
code-creation,JS,10,54018,0x31e6f6b5e716,53,loadPreloadModules node:internal/process/pre_execution:743:28,0x31e647c79fa8,~
code-source-info,0x31e6f6b5e716,67,23330,23651,C0O23417C8O23417C13O23448C15O23485C21O23492C26O23569C32O23569C37O23525C42O23535C47O23613C52O23650,,
code-creation,JS,10,54076,0x31e6f6b5e916,165,Module._preloadModules node:internal/modules/cjs/loader:1564:34,0x31e647c77768,~
code-source-info,0x31e6f6b5e916,63,50792,51381,C0O50807C5O50812C11O50838C12O50845C13O50851C17O50864C23O51059C33O51059C42O51109C45O51131C53O51156C58O51156C63O51131C68O51122C85O51184C88O51190C95O51195C100O51217C106O51230C114O51245C116O51245C119O51279C121O51295C125O51284C130O51314C135O51346C139O51314C144O51304C149O51266C153O51358C157O51371C164O51380,,
code-creation,JS,10,54152,0x31e6f6b5ebf6,218,Module node:internal/modules/cjs/loader:252:16,0x31e647c76668,~
code-source-info,0x31e6f6b5ebf6,63,7243,7985,C14O7265C16O7273C20O7281C22O7293C25O7298C30O7298C35O7291C39O7313C52O7313C57O7352C62O7370C67O7370C73O7391C84O7391C89O7430C90O7444C94O7454C95O7466C99O7477C101O7491C105O7503C107O7533C112O7533C118O7541C126O7555C128O7593C133O7593C138O7637C143O7637C149O7733C159O7765C162O7765C171O7733C176O7849C181O7869C191O7891C194O7891C200O7849C205O7936C207O7941C212O7965C217O7984,,
code-creation,JS,10,54231,0x31e6f6b5efde,163,dirname node:path:1278:10,0x31e647c5b860,~
code-source-info,0x31e6f6b5efde,34,38877,39546,C0O38890C8O38890C13O38933C19O38940C24O38953C26O38964C27O38985C34O38985C42O39024C44O39020C48O39058C51O39085C53O39113C57O39120C61O39127C63O39127C68O39146C73O39150C81O39189C83O39185C88O39219C92O39250C97O39269C101O39356C103O39135C108O39095C112O39397C114O39405C119O39419C129O39446C130O39451C136O39470C141O39483C143O39495C144O39500C157O39507C162O39542,,
tick,0x7ff809251532,54315,0,0x0,3,0x10c9f09d0,0x31e6f6b5ec14,0x31e6f6b5e937,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,54338,0x31e6f6b5f276,28,setOwnProperty node:internal/util:723:24,0x31e647c43e08,~
code-source-info,0x31e6f6b5f276,16,19569,19736,C0O19591C5O19624C12O19702C22O19598C27O19734,,
code-creation,JS,10,54414,0x31e6f6b5f3fe,45,updateChildren node:internal/modules/cjs/loader:217:24,0x31e647c76578,~
code-source-info,0x31e6f6b5f3fe,63,6182,6361,C0O6225C7O6231C15O6245C19O6263C23O6271C26O6271C33O6319C38O6319C44O6360,,
code-creation,JS,10,54456,0x31e6f6b5f5f6,40, node:internal/util:794:18,0x31e647c44160,~
code-source-info,0x31e6f6b5f5f6,16,21846,21966,C0O21855C10O21890C13O21898C19O21896C25O21919C29O21931C35O21949C39O21962,,
code-creation,JS,10,54487,0x31e6f6b5f70e,28, node:internal/modules/cjs/loader:117:3,0x31e647c76348,~
code-source-info,0x31e6f6b5f70e,63,3473,3564,C0O3480C8O3480C20O3522C27O3564,,
code-creation,JS,10,54529,0x31e6f6b5f866,40,wrappedCwd node:internal/bootstrap/switches/does_own_process_state:136:20,0x31e647c7cde8,~
script-source,73,node:internal/bootstrap/switches/does_own_process_state,'use strict';\n\nconst credentials = internalBinding('credentials');\nconst rawMethods = internalBinding('process_methods');\nconst {\n  namespace: {\n    addSerializeCallback\x2C\n    isBuildingSnapshot\x2C\n  }\x2C\n} = require('internal/v8/startup_snapshot');\n\nprocess.abort = rawMethods.abort;\nprocess.umask = wrappedUmask;\nprocess.chdir = wrappedChdir;\nprocess.cwd = wrappedCwd;\n\nif (credentials.implementsPosixCredentials) {\n  const wrapped = wrapPosixCredentialSetters(credentials);\n\n  process.initgroups = wrapped.initgroups;\n  process.setgroups = wrapped.setgroups;\n  process.setegid = wrapped.setegid;\n  process.seteuid = wrapped.seteuid;\n  process.setgid = wrapped.setgid;\n  process.setuid = wrapped.setuid;\n}\n\n// ---- keep the attachment of the wrappers above so that it's easier to ----\n// ----              compare the setups side-by-side                    -----\n\nconst {\n  parseFileMode\x2C\n  validateArray\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nfunction wrapPosixCredentialSetters(credentials) {\n  const {\n    codes: {\n      ERR_INVALID_ARG_TYPE\x2C\n      ERR_UNKNOWN_CREDENTIAL\x2C\n    }\x2C\n  } = require('internal/errors');\n  const {\n    validateUint32\x2C\n  } = require('internal/validators');\n\n  const {\n    initgroups: _initgroups\x2C\n    setgroups: _setgroups\x2C\n    setegid: _setegid\x2C\n    seteuid: _seteuid\x2C\n    setgid: _setgid\x2C\n    setuid: _setuid\x2C\n  } = credentials;\n\n  function initgroups(user\x2C extraGroup) {\n    validateId(user\x2C 'user');\n    validateId(extraGroup\x2C 'extraGroup');\n    // Result is 0 on success\x2C 1 if user is unknown\x2C 2 if group is unknown.\n    const result = _initgroups(user\x2C extraGroup);\n    if (result === 1) {\n      throw new ERR_UNKNOWN_CREDENTIAL('User'\x2C user);\n    } else if (result === 2) {\n      throw new ERR_UNKNOWN_CREDENTIAL('Group'\x2C extraGroup);\n    }\n  }\n\n  function setgroups(groups) {\n    validateArray(groups\x2C 'groups');\n    for (let i = 0; i < groups.length; i++) {\n      validateId(groups[i]\x2C `groups[${i}]`);\n    }\n    // Result is 0 on success. A positive integer indicates that the\n    // corresponding group was not found.\n    const result = _setgroups(groups);\n    if (result > 0) {\n      throw new ERR_UNKNOWN_CREDENTIAL('Group'\x2C groups[result - 1]);\n    }\n  }\n\n  function wrapIdSetter(type\x2C method) {\n    return function(id) {\n      validateId(id\x2C 'id');\n      if (typeof id === 'number') id >>>= 0;\n      // Result is 0 on success\x2C 1 if credential is unknown.\n      const result = method(id);\n      if (result === 1) {\n        throw new ERR_UNKNOWN_CREDENTIAL(type\x2C id);\n      }\n    };\n  }\n\n  function validateId(id\x2C name) {\n    if (typeof id === 'number') {\n      validateUint32(id\x2C name);\n    } else if (typeof id !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C ['number'\x2C 'string']\x2C id);\n    }\n  }\n\n  return {\n    initgroups\x2C\n    setgroups\x2C\n    setegid: wrapIdSetter('Group'\x2C _setegid)\x2C\n    seteuid: wrapIdSetter('User'\x2C _seteuid)\x2C\n    setgid: wrapIdSetter('Group'\x2C _setgid)\x2C\n    setuid: wrapIdSetter('User'\x2C _setuid)\x2C\n  };\n}\n\n// Cache the working directory to prevent lots of lookups. If the working\n// directory is changed by `chdir`\x2C it'll be updated.\nlet cachedCwd = '';\n\nif (isBuildingSnapshot()) {\n  addSerializeCallback(() => {\n    cachedCwd = '';\n  });\n}\n\nfunction wrappedChdir(directory) {\n  validateString(directory\x2C 'directory');\n  rawMethods.chdir(directory);\n  // Mark cache that it requires an update.\n  cachedCwd = '';\n}\n\nfunction wrappedUmask(mask) {\n  if (mask !== undefined) {\n    mask = parseFileMode(mask\x2C 'mask');\n  }\n  return rawMethods.umask(mask);\n}\n\nfunction wrappedCwd() {\n  if (cachedCwd === '')\n    cachedCwd = rawMethods.cwd();\n  return cachedCwd;\n}\n
code-source-info,0x31e6f6b5f866,73,3560,3644,C0O3567C7O3581C12O3593C17O3616C22O3616C29O3603C35O3625C39O3642,,
code-creation,JS,10,54941,0x31e6f6b5fea6,184,Module._nodeModulePaths node:internal/modules/cjs/loader:793:37,0x31e647c76dd8,~
code-source-info,0x31e6f6b5fea6,63,24237,25417,C0O24292C5O24304C10O24304C17O24483C19O24492C24O24509C28O24534C29O24783C32O24809C36O24816C40O24825C42O24840C47O24850C48O24850C53O24882C58O24882C64O24924C66O24937C68O24933C73O24967C75O24977C77O24973C82O24996C89O25047C100O25047C108O25083C112O24996C117O25133C120O25151C124O25171C126O25177C131O25195C138O25206C144O25210C149O25232C156O25264C159O24858C164O24791C168O25351C176O25351C181O25400C183O25413,,
code-creation,JS,10,55050,0x31e6f6b60296,127,internalRequire node:internal/modules/cjs/loader:167:25,0x31e647c76438,~
code-source-info,0x31e6f6b60296,63,4815,5116,C0O4832C8O4832C13O4860C15O4867C20O4881C36O4887C41O4881C42O4996C51O5008C60O5024C63O5038C76O5038C93O5095C102O5107C126O5115,,
code-creation,JS,10,55175,0x31e6f6b6067e,679,Module._load node:internal/modules/cjs/loader:950:24,0x31e647c77038,~
code-source-info,0x31e6f6b6067e,63,29613,32758,C0O29647C2O29676C6O29694C14O29754C23O29694C28O29984C42O29995C47O30027C54O30047C58O30080C61O30080C65O30119C69O30176C72O30183C79O30189C83O30207C85O30249C97O30249C102O30319C108O30339C111O30346C115O30389C116O30428C120O30436C121O30451C128O30479C130O30520C138O30524C145O30614C153O30614C159O30653C164O30672C169O30672C176O30706C183O30712C188O30706C189O30779C194O30779C200O30829C204O30837C205O30862C208O30869C222O30869C228O30935C231O30942C238O30948C242O30962C244O31000C256O31000C261O31066C267O31108C272O31122C277O31122C283O31147C285O31191C291O31209C294O31216C298O31259C299O31274C300O31299C306O31346C310O31354C311O31368C316O31386C321O31386C328O31442C333O31442C339O31495C343O31503C344O31593C359O31609C365O31642C369O31660C383O31660C388O31711C393O31733C405O31758C411O31711C416O31775C418O31785C422O31799C425O31799C429O31837C432O31844C439O31861C443O31873C447O31905C454O31953C458O31984C463O32009C469O32009C474O32029C486O32035C487O32062C492O32081C496O32095C504O32102C506O32119C510O32155C518O32183C520O32236C527O32242C535O32262C541O32266C547O32316C553O32316C559O32367C561O32377C566O32399C582O32399C589O32493C597O32520C601O32535C607O32520C615O32562C619O32590C625O32562C633O32620C635O32599C640O32666C646O32694C654O32703C658O32666C674O32748C678O32756,,
code-creation,JS,10,55264,0x31e6f6b60b6e,89,logger node:internal/util/debuglog:100:18,0x31e647c4aa30,~
code-source-info,0x31e6f6b60b6e,22,2965,3160,C0O2965C3O2997C24O3021C30O3038C34O3028C38O3043C39O3058C45O3075C51O3084C55O3065C60O3089C61O3105C65O3112C72O3125C77O3121C83O3112C88O3150,,
code-creation,JS,10,55307,0x31e6f6b60dc6,3, node:internal/per_context/primordials:338:21,0x31e6931b4190,~
code-source-info,0x31e6f6b60dc6,6,9645,9674,C0O9656C2O9668,,
code-creation,JS,10,55350,0x31e6f6b60e9e,140,debug node:internal/util/debuglog:81:15,0x31e647c4a990,~
code-source-info,0x31e6f6b60e9e,22,2453,2847,C0O2453C3O2472C6O2472C9O2580C16O2601C22O2588C30O2586C36O2620C42O2656C47O2659C50O2656C54O2684C75O2708C81O2725C85O2715C89O2730C90O2745C96O2762C102O2771C106O2752C111O2776C112O2792C116O2799C123O2812C128O2808C134O2799C139O2837,,
code-creation,JS,10,55392,0x31e6f6b6104e,41,init node:internal/util/debuglog:77:16,0x31e647c4a940,~
code-source-info,0x31e6f6b6104e,22,2355,2438,C0O2364C10O2370C14O2368C16O2407C26O2417C33O2415C40O2437,,
code-creation,JS,10,55423,0x31e6f6b6113e,2,testEnabled node:internal/util/debuglog:31:19,0x31e6f6b51910,~
code-source-info,0x31e6f6b6113e,22,958,969,C0O964C1O969,,
code-creation,JS,10,55461,0x31e6f6b612b6,116,debuglogImpl node:internal/util/debuglog:54:22,0x31e647c4a6f8,~
code-source-info,0x31e6f6b612b6,22,1554,2091,C0O1554C9O1573C18O1587C23O1614C34O1647C39O1655C43O1647C45O1666C55O1666C59O1698C71O1709C75O1714C83O2030C97O2048C99O2046C103O2066C112O2083C115O2089,,
code-creation,JS,10,55499,0x31e6f6b6146e,10, node:internal/modules/cjs/loader:357:66,0x31e647c769d8,~
code-source-info,0x31e6f6b6146e,63,9947,9972,C0O9959C2O9965C9O9971,,
code-creation,JS,10,55523,0x31e6f6b6151e,2,noop node:internal/util/debuglog:46:14,0x31e647c4a658,~
code-source-info,0x31e6f6b6151e,22,1404,1412,C1O1411,,
tick,0x10c3ecfb2,55570,0,0x0,2,0x10c9f09d0,0x31e6f6b606bb,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,55592,0x31e6f6b616ee,58,reportModuleToWatchMode node:internal/modules/cjs/loader:228:33,0x31e647c765c8,~
code-source-info,0x31e6f6b616ee,63,6510,6634,C0O6525C5O6529C13O6570C19O6582C22O6590C32O6614C41O6615C51O6590C57O6633,,
code-creation,JS,10,55629,0x31e6f6b6183e,13, node:internal/modules/cjs/loader:119:45,0x31e647c76398,~
code-source-info,0x31e6f6b6183e,63,3613,3656,C0O3631C3O3627C8O3631C12O3656,,
code-creation,JS,10,55797,0x31e6f6b61d7e,881,Module._resolveFilename node:internal/modules/cjs/loader:1058:35,0x31e647c770a8,~
code-source-info,0x31e6f6b61d7e,63,33228,36356,C0O33267C6O33285C12O33285C19O33323C21O33338C22O33350C24O33360C34O33419C40O33444C46O33423C52O33479C62O33479C71O33533C79O33533C88O33590C94O33603C102O33603C111O33659C119O33659C125O33711C127O33753C134O33802C147O33802C153O33833C156O33867C158O33882C164O33888C168O33872C173O33934C181O33939C185O33954C189O33980C195O33980C200O33971C204O34034C208O34041C214O34041C222O34107C225O34126C229O34112C234O34153C242O34199C247O34158C254O34221C262O34258C267O34221C272O34135C278O34094C282O33897C287O33854C293O34331C299O34360C303O34375C309O34375C318O34432C328O34489C336O34438C341O34432C344O34518C348O34533C354O34533C361O34578C362O34589C369O34593C381O34611C397O34631C408O34636C413O34676C420O34682C435O34704C441O34704C449O34712C453O34717C457O34710C461O34738C467O34756C473O34756C485O34821C493O34825C506O34900C514O34900C520O34874C525O34949C531O35020C535O35020C543O35079C547O35079C555O34989C562O35126C571O34956C576O35132C590O35161C594O35167C602O35172C607O35212C613O35218C617O35212C618O35267C620O35267C621O35354C625O35354C630O35404C634O35404C640O35436C642O35477C644O35485C649O35512C657O35519C663O35532C670O35538C678O35538C683O35494C687O35578C691O35585C699O35606C703O35626C705O35646C706O35732C710O35739C725O35739C731O35776C733O35792C735O35808C736O35834C739O35858C744O35870C748O35928C754O35968C763O35987C769O35928C774O35889C780O35909C786O35909C792O35840C796O36012C802O36035C814O36066C821O36073C826O36084C828O36102C835O36143C843O36143C848O36127C852O36254C860O36254C866O36276C868O36285C872O36309C874O36326C878O36344C880O36344,,
code-creation,JS,10,55901,0x31e6f6b623ce,77,normalizeRequirableId node:internal/bootstrap/realm:301:31,0x31e6931b6cc0,~
code-source-info,0x31e6f6b623ce,9,9606,9930,C0O9617C10O9621C17O9690C27O9690C33O9725C38O9743C43O9743C50O9789C52O9809C55O9829C60O9847C65O9847C72O9887C74O9897C75O9909C76O9926,,
code-creation,JS,10,55936,0x31e6f6b62516,18,canBeRequiredWithoutScheme node:internal/bootstrap/realm:297:36,0x31e6931b6c70,~
code-source-info,0x31e6f6b62516,9,9506,9574,C0O9517C7O9562C12O9562C17O9570,,
code-creation,JS,10,56004,0x31e6f6b627fe,345,Module._resolveLookupPaths node:internal/modules/cjs/loader:839:38,0x31e647c76e68,~
code-source-info,0x31e6f6b627fe,63,25560,26839,C0O25582C5O25600C10O25600C17O25638C25O25638C30O25682C31O25694C32O25737C39O25741C47O25775C52O25801C59O25808C66O25821C72O25821C80O25855C87O25872C93O25872C101O25906C108O25925C114O25938C120O25938C128O25972C133O26023C135O26034C142O26044C149O26051C158O26069C165O26097C168O26077C173O26117C178O26158C183O26117C190O26185C195O26217C209O26217C214O26281C220O26288C230O26307C231O26354C235O26377C241O26391C247O26562C252O26574C266O26574C271O26629C273O26646C274O26654C282O26721C290O26654C295O26747C304O26748C307O26753C312O26768C317O26753C329O26782C337O26782C342O26820C344O26837,,
code-creation,JS,10,56070,0x31e6f6b62b1e,76,trySelfParentPath node:internal/modules/cjs/loader:520:27,0x31e647c76c58,~
code-source-info,0x31e6f6b62b1e,63,15194,15461,C0O15207C4O15222C5O15235C6O15252C12O15282C16O15291C17O15312C24O15315C29O15338C36O15341C44O15383C47O15398C52O15398C59O15406C62O15411C66O15404C69O15415C72O15436C73O15449C75O15460,,
code-creation,JS,10,56138,0x31e6f6b62dd6,249,trySelf node:internal/modules/cjs/loader:539:17,0x31e647c76ca8,~
code-source-info,0x31e6f6b62dd6,63,15685,16597,C0O15711C4O15730C5O15743C6O15786C11O15804C16O15804C22O15763C27O15774C32O15836C36O15852C43O15875C49O15901C50O15914C51O15926C53O15959C57O15951C62O15971C67O15997C72O16043C84O16001C91O16059C96O16077C99O16111C104O16116C109O16077C114O16075C120O16140C121O16153C125O16205C131O16205C136O16179C141O16250C146O16308C151O16330C155O16308C162O16372C165O16372C172O16399C175O16399C185O16279C197O16257C202O16441C214O16462C217O16468C224O16473C229O16509C236O16553C240O16515C245O16509C246O16583C248O16583,,
code-creation,JS,10,56221,0x31e6f6b631ae,184,readPackageScope node:internal/modules/package_json_reader:149:26,0x31e647c78548,~
script-source,65,node:internal/modules/package_json_reader,'use strict';\n\nconst {\n  JSONParse\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  SafeMap\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeSlice\x2C\n} = primordials;\nconst {\n  ERR_INVALID_PACKAGE_CONFIG\x2C\n} = require('internal/errors').codes;\nconst { internalModuleReadJSON } = internalBinding('fs');\nconst { resolve\x2C sep\x2C toNamespacedPath } = require('path');\nconst permission = require('internal/process/permission');\nconst { kEmptyObject } = require('internal/util');\n\nconst { fileURLToPath\x2C pathToFileURL } = require('internal/url');\n\nconst cache = new SafeMap();\nconst isAIX = process.platform === 'aix';\n\nlet manifest;\n\n/**\n * @typedef {{\n *   exists: boolean\x2C\n *   pjsonPath: string\x2C\n *   exports?: string | string[] | Record<string\x2C unknown>\x2C\n *   imports?: string | string[] | Record<string\x2C unknown>\x2C\n *   name?: string\x2C\n *   main?: string\x2C\n *   type: 'commonjs' | 'module' | 'none'\x2C\n * }} PackageConfig\n */\n\n/**\n * @param {string} jsonPath\n * @param {{\n *   base?: string\x2C\n *   specifier: string\x2C\n *   isESM: boolean\x2C\n * }} options\n * @returns {PackageConfig}\n */\nfunction read(jsonPath\x2C { base\x2C specifier\x2C isESM } = kEmptyObject) {\n  if (cache.has(jsonPath)) {\n    return cache.get(jsonPath);\n  }\n\n  const {\n    0: string\x2C\n    1: containsKeys\x2C\n  } = internalModuleReadJSON(\n    toNamespacedPath(jsonPath)\x2C\n  );\n  const result = {\n    __proto__: null\x2C\n    exists: false\x2C\n    pjsonPath: jsonPath\x2C\n    main: undefined\x2C\n    name: undefined\x2C\n    type: 'none'\x2C // Ignore unknown types for forwards compatibility\n    exports: undefined\x2C\n    imports: undefined\x2C\n  };\n\n  // Folder read operation succeeds in AIX.\n  // For libuv change\x2C see https://github.com/libuv/libuv/pull/2025.\n  // https://github.com/nodejs/node/pull/48477#issuecomment-1604586650\n  // TODO(anonrig): Follow-up on this change and remove it since it is a\n  // semver-major change.\n  const isResultValid = isAIX && !isESM ? containsKeys : string !== undefined;\n\n  if (isResultValid) {\n    let parsed;\n    try {\n      parsed = JSONParse(string);\n    } catch (error) {\n      if (isESM) {\n        throw new ERR_INVALID_PACKAGE_CONFIG(\n          jsonPath\x2C\n          (base ? `"${specifier}" from ` : '') + fileURLToPath(base || specifier)\x2C\n          error.message\x2C\n        );\n      } else {\n        // For backward compat\x2C we modify the error returned by JSON.parse rather than creating a new one.\n        // TODO(aduh95): make it throw ERR_INVALID_PACKAGE_CONFIG in a semver-major with original error as cause\n        error.message = 'Error parsing ' + jsonPath + ': ' + error.message;\n        error.path = jsonPath;\n        throw error;\n      }\n    }\n\n    result.exists = true;\n\n    // ObjectPrototypeHasOwnProperty is used to avoid prototype pollution.\n    if (ObjectPrototypeHasOwnProperty(parsed\x2C 'name') && typeof parsed.name === 'string') {\n      result.name = parsed.name;\n    }\n\n    if (ObjectPrototypeHasOwnProperty(parsed\x2C 'main') && typeof parsed.main === 'string') {\n      result.main = parsed.main;\n    }\n\n    if (ObjectPrototypeHasOwnProperty(parsed\x2C 'exports')) {\n      result.exports = parsed.exports;\n    }\n\n    if (ObjectPrototypeHasOwnProperty(parsed\x2C 'imports')) {\n      result.imports = parsed.imports;\n    }\n\n    // Ignore unknown types for forwards compatibility\n    if (ObjectPrototypeHasOwnProperty(parsed\x2C 'type') && (parsed.type === 'commonjs' || parsed.type === 'module')) {\n      result.type = parsed.type;\n    }\n\n    if (manifest === undefined) {\n      const { getOptionValue } = require('internal/options');\n      manifest = getOptionValue('--experimental-policy') ?\n        require('internal/process/policy').manifest :\n        null;\n    }\n    if (manifest !== null) {\n      const jsonURL = pathToFileURL(jsonPath);\n      manifest.assertIntegrity(jsonURL\x2C string);\n    }\n  }\n  cache.set(jsonPath\x2C result);\n  return result;\n}\n\n/**\n * @param {string} requestPath\n * @return {PackageConfig}\n */\nfunction readPackage(requestPath) {\n  return read(resolve(requestPath\x2C 'package.json'));\n}\n\n/**\n * Get the nearest parent package.json file from a given path.\n * Return the package.json data and the path to the package.json file\x2C or false.\n * @param {string} checkPath The path to start searching from.\n */\nfunction readPackageScope(checkPath) {\n  const rootSeparatorIndex = StringPrototypeIndexOf(checkPath\x2C sep);\n  let separatorIndex;\n  const enabledPermission = permission.isEnabled();\n  do {\n    separatorIndex = StringPrototypeLastIndexOf(checkPath\x2C sep);\n    checkPath = StringPrototypeSlice(checkPath\x2C 0\x2C separatorIndex);\n    // Stop the search when the process doesn't have permissions\n    // to walk upwards\n    if (enabledPermission && !permission.has('fs.read'\x2C checkPath + sep)) {\n      return false;\n    }\n    if (StringPrototypeEndsWith(checkPath\x2C sep + 'node_modules')) {\n      return false;\n    }\n    const pjson = readPackage(checkPath + sep);\n    if (pjson.exists) {\n      return {\n        data: pjson\x2C\n        path: checkPath\x2C\n      };\n    }\n  } while (separatorIndex > rootSeparatorIndex);\n  return false;\n}\n\nmodule.exports = {\n  read\x2C\n  readPackage\x2C\n  readPackageScope\x2C\n};\n
code-source-info,0x31e6f6b631ae,65,4262,5057,C0O4305C7O4339C10O4305C16O4351C18O4395C23O4406C28O4406C33O4430C40O4485C43O4447C49O4495C62O4507C69O4651C75O4677C78O4688C88O4715C90O4713C94O4688C102O4729C103O4742C104O4753C111O4792C116O4796C120O4757C127O4823C128O4836C129O4861C134O4885C136O4883C140O4861C145O4905C151O4921C158O4944C164O4965C170O4984C171O5017C173O5017C178O4421C182O5042C183O5055,,
code-creation,JS,10,56570,0x31e6f6b6396e,43,isEnabled node:internal/process/permission:16:12,0x31e647c64388,~
script-source,46,node:internal/process/permission,'use strict';\n\nconst {\n  ObjectFreeze\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\n\nconst permission = internalBinding('permission');\nconst { validateString } = require('internal/validators');\nconst { resolve } = require('path');\n\nlet experimentalPermission;\n\nmodule.exports = ObjectFreeze({\n  __proto__: null\x2C\n  isEnabled() {\n    if (experimentalPermission === undefined) {\n      const { getOptionValue } = require('internal/options');\n      experimentalPermission = getOptionValue('--experimental-permission');\n    }\n    return experimentalPermission;\n  }\x2C\n  has(scope\x2C reference) {\n    validateString(scope\x2C 'scope');\n    if (reference != null) {\n      // TODO: add support for WHATWG URLs and Uint8Arrays.\n      validateString(reference\x2C 'reference');\n      if (StringPrototypeStartsWith(scope\x2C 'fs')) {\n        reference = resolve(reference);\n      }\n    }\n\n    return permission.has(scope\x2C reference);\n  }\x2C\n});\n
code-source-info,0x31e6f6b6396e,46,324,559,C0O333C6O410C12O410C17O391C22O445C25O470C32O468C38O525C42O555,,
tick,0x7ff809303aef,56687,0,0x0,3,0x10c9f09d0,0x31e6f6b631ca,0x31e6f6b62de6,0x31e6f6b61ff8,0x31e6f6b6075c,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,56710,0x31e6f6b63bf6,22,readPackage node:internal/modules/package_json_reader:140:21,0x31e647c784f8,~
code-source-info,0x31e6f6b63bf6,65,3950,4020,C0O3968C5O3980C11O3980C17O3975C21O4018,,
code-creation,JS,10,56842,0x31e6f6b6406e,573,read node:internal/modules/package_json_reader:48:14,0x31e647c78310,~
code-source-info,0x31e6f6b6406e,65,1125,3862,C9O1165C16O1138C21O1144C26O1155C31O1183C36O1193C41O1193C48O1214C53O1227C58O1227C63O1241C64O1299C71O1327C74O1327C79O1299C86O1264C93O1279C97O1377C104O1434C109O1454C114O1475C119O1568C124O1592C131O1916C139O1926C148O1956C150O1974C152O2003C157O2027C162O2036C170O2034C180O2083C184O2104C196O2173C203O2184C222O2211C228O2225C234O2211C238O2209C246O2261C254O2110C259O2104C260O2524C268O2557C274O2568C281O2583C285O2575C288O2538C292O2600C297O2611C301O2631C303O2631C304O2663C305O2677C309O2765C317O2769C324O2832C332O2880C336O2871C340O2897C348O2901C355O2964C363O3012C367O3003C371O3029C379O3033C386O3115C390O3106C394O3135C402O3139C409O3221C413O3212C417O3296C425O3300C432O3357C439O3362C444O3387C451O3392C456O3436C460O3427C464O3453C470O3516C476O3516C481O3497C486O3551C489O3562C501O3612C506O3646C516O3560C522O3682C528O3729C533O3729C538O3760C543O3769C548O3769C554O3815C559O3821C564O3821C570O3846C572O3860,,
code-creation,JS,10,56926,0x31e6f6b6448e,3,toNamespacedPath node:path:1269:19,0x31e647c5b810,~
code-source-info,0x31e6f6b6448e,34,38744,38804,C0O38788C2O38800,,
code-creation,JS,10,57133,0x31e6f6b6493e,889,Module._findPath node:internal/modules/cjs/loader:610:28,0x31e647c76d48,~
code-source-info,0x31e6f6b6493e,63,18064,22152,C0O18117C6O18122C11O18122C17O18145C19O18172C27O18195C31O18215C37O18222C42O18235C43O18248C44O18273C46O18281C52O18292C60O18292C65O18290C69O18343C72O18350C79O18360C83O18374C85O18391C87O18404C88O18416C90O18454C96O18461C103O18473C106O18516C110O18523C115O18473C123O18532C125O18528C132O18562C135O18605C139O18612C144O18562C152O18621C154O18617C159O18657C166O18664C173O18681C176O18724C180O18731C185O18681C193O18740C195O18736C202O18771C205O18814C209O18821C214O18771C222O18830C224O18826C229O18862C236O18869C243O18888C246O18931C250O18938C255O18888C263O18947C265O18943C269O19015C277O19015C285O19057C287O19053C292O19089C299O19096C306O19111C313O19111C321O19153C323O19149C330O19182C336O19195C343O19195C351O19237C353O19233C360O19268C367O19268C375O19310C377O19306C382O19341C389O19348C396O19365C403O19365C411O19407C413O19403C420O19439C426O19452C433O19452C441O19494C443O19490C447O19543C449O19551C453O19599C459O19604C464O19604C470O19628C479O19632C486O19692C488O19757C490O19770C494O19762C499O19895C501O19900C505O19909C511O19927C515O19946C519O19957C524O19957C532O19973C536O19984C545O19984C555O20012C558O20012C565O20027C570O20046C572O20067C576O20121C579O20121C585O20161C587O20192C589O20215C590O20252C596O20257C601O20257C608O20292C610O20318C615O20318C620O20339C624O20367C625O20374C630O20401C634O20426C643O20430C649O20483C655O20499C660O20499C668O20549C673O20560C680O20609C689O20613C695O21253C701O21269C706O21269C714O21315C719O21326C724O21373C728O21444C732O21480C741O21505C747O21487C752O21537C764O21548C770O21606C776O21626C781O21711C785O21745C794O21770C800O21752C805O21798C820O21809C826O21865C830O21887C833O21894C840O21915C844O21933C846O21949C847O21980C852O21990C856O22022C861O22022C866O22075C869O22075C874O19779C879O19744C887O22137C888O22150,,
code-creation,JS,10,57241,0x31e6f6b64f8e,45,isAbsolute node:path:1159:13,0x31e647c5b720,~
code-source-info,0x31e6f6b64f8e,34,35583,35729,C0O35596C8O35596C13O35642C19O35649C26O35667C31O35667C39O35706C41O35702C44O35725,,
code-creation,JS,10,57303,0x31e6f6b6513e,85,stat node:internal/modules/cjs/loader:185:14,0x31e647c76488,~
code-source-info,0x31e6f6b6513e,63,5267,5668,C0O5282C5O5298C10O5298C17O5328C23O5373C28O5383C33O5383C39O5402C41O5430C43O5444C44O5468C49O5468C54O5500C61O5533C66O5613C71O5623C76O5623C82O5652C84O5666,,
code-creation,JS,10,57363,0x31e6f6b652be,42,toRealPath node:internal/modules/helpers:54:20,0x31e647c77df8,~
code-source-info,0x31e6f6b652be,64,1545,1658,C0O1563C5O1573C10O1586C17O1606C20O1617C28O1636C35O1573C41O1656,,
code-creation,JS,10,57689,0x31e6f6b6568e,963,realpathSync node:fs:2634:22,0x31e647c6d970,~
script-source,55,node:fs,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Maintainers\x2C keep in mind that ES1-style octal literals (`0666`) are not\n// allowed in strict mode. Use ES6-style octal literals instead (`0o666`).\n\n'use strict';\n\nconst {\n  ArrayPrototypePush\x2C\n  BigIntPrototypeToString\x2C\n  Boolean\x2C\n  MathMax\x2C\n  Number\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  Promise\x2C\n  PromiseResolve\x2C\n  ReflectApply\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeSlice\x2C\n} = primordials;\n\nconst { fs: constants } = internalBinding('constants');\nconst {\n  S_IFIFO\x2C\n  S_IFLNK\x2C\n  S_IFMT\x2C\n  S_IFREG\x2C\n  S_IFSOCK\x2C\n  F_OK\x2C\n  R_OK\x2C\n  W_OK\x2C\n  X_OK\x2C\n  O_WRONLY\x2C\n  O_SYMLINK\x2C\n} = constants;\n\nconst pathModule = require('path');\nconst { isAbsolute } = pathModule;\nconst { isArrayBufferView } = require('internal/util/types');\n\nconst binding = internalBinding('fs');\n\nconst { createBlobFromFilePath } = require('internal/blob');\n\nconst { Buffer } = require('buffer');\nconst {\n  aggregateTwoErrors\x2C\n  codes: {\n    ERR_ACCESS_DENIED\x2C\n    ERR_FS_FILE_TOO_LARGE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n  }\x2C\n  AbortError\x2C\n} = require('internal/errors');\n\nconst {\n  FSReqCallback\x2C\n  statValues\x2C\n} = binding;\nconst { toPathIfFileURL } = require('internal/url');\nconst {\n  customPromisifyArgs: kCustomPromisifyArgsSymbol\x2C\n  kEmptyObject\x2C\n  promisify: {\n    custom: kCustomPromisifiedSymbol\x2C\n  }\x2C\n  SideEffectFreeRegExpPrototypeExec\x2C\n  defineLazyProperties\x2C\n} = require('internal/util');\nconst {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n  }\x2C\n  copyObject\x2C\n  Dirent\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirent\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getValidatedFd\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  handleErrorFromBinding\x2C\n  possiblyTransformPath\x2C\n  preprocessSymlinkDestination\x2C\n  Stats\x2C\n  getStatFsFromBinding\x2C\n  getStatsFromBinding\x2C\n  realpathCacheKey\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateCpOptions\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validatePath\x2C\n  validatePosition\x2C\n  validateRmOptions\x2C\n  validateRmOptionsSync\x2C\n  validateRmdirOptions\x2C\n  validateStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\x2C\n} = require('internal/fs/utils');\nconst {\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_BACKWARD_SLASH\x2C\n} = require('internal/constants');\nconst {\n  isInt32\x2C\n  parseFileMode\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateEncoding\x2C\n  validateFunction\x2C\n  validateInteger\x2C\n  validateObject\x2C\n  validateString\x2C\n  kValidateObjectAllowNullable\x2C\n} = require('internal/validators');\n\nconst permission = require('internal/process/permission');\n\nlet truncateWarn = true;\nlet fs;\n\n// Lazy loaded\nlet cpFn;\nlet cpSyncFn;\nlet promises = null;\nlet ReadStream;\nlet WriteStream;\nlet rimraf;\nlet rimrafSync;\nlet kResistStopPropagation;\n\n// These have to be separate because of how graceful-fs happens to do it's\n// monkeypatching.\nlet FileReadStream;\nlet FileWriteStream;\n\nconst isWindows = process.platform === 'win32';\nconst isOSX = process.platform === 'darwin';\n\nfunction showTruncateDeprecation() {\n  if (truncateWarn) {\n    process.emitWarning(\n      'Using fs.truncate with a file descriptor is deprecated. Please use ' +\n      'fs.ftruncate with a file descriptor instead.'\x2C\n      'DeprecationWarning'\x2C 'DEP0081');\n    truncateWarn = false;\n  }\n}\n\nfunction maybeCallback(cb) {\n  validateFunction(cb\x2C 'cb');\n\n  return cb;\n}\n\n// Ensure that callbacks run in the global context. Only use this function\n// for callbacks that are passed to the binding layer\x2C callbacks that are\n// invoked from JS already run in the proper scope.\nfunction makeCallback(cb) {\n  validateFunction(cb\x2C 'cb');\n\n  return (...args) => ReflectApply(cb\x2C this\x2C args);\n}\n\n// Special case of `makeCallback()` that is specific to async `*stat()` calls as\n// an optimization\x2C since the data passed back to the callback needs to be\n// transformed anyway.\nfunction makeStatsCallback(cb) {\n  validateFunction(cb\x2C 'cb');\n\n  return (err\x2C stats) => {\n    if (err) return cb(err);\n    cb(err\x2C getStatsFromBinding(stats));\n  };\n}\n\nconst isFd = isInt32;\n\nfunction isFileType(stats\x2C fileType) {\n  // Use stats array directly to avoid creating an fs.Stats instance just for\n  // our internal use.\n  let mode = stats[1];\n  if (typeof mode === 'bigint')\n    mode = Number(mode);\n  return (mode & S_IFMT) === fileType;\n}\n\n/**\n * Tests a user's permissions for the file or directory\n * specified by `path`.\n * @param {string | Buffer | URL} path\n * @param {number} [mode]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction access(path\x2C mode\x2C callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = F_OK;\n  }\n\n  path = getValidatedPath(path);\n  mode = getValidMode(mode\x2C 'access');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C req);\n}\n\n/**\n * Synchronously tests a user's permissions for the file or\n * directory specified by `path`.\n * @param {string | Buffer | URL} path\n * @param {number} [mode]\n * @returns {void}\n */\nfunction accessSync(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = getValidMode(mode\x2C 'access');\n\n  binding.access(pathModule.toNamespacedPath(path)\x2C mode);\n}\n\n/**\n * Tests whether or not the given path exists.\n * @param {string | Buffer | URL} path\n * @param {(exists?: boolean) => any} callback\n * @returns {void}\n */\nfunction exists(path\x2C callback) {\n  maybeCallback(callback);\n\n  function suppressedCallback(err) {\n    callback(err ? false : true);\n  }\n\n  try {\n    fs.access(path\x2C F_OK\x2C suppressedCallback);\n  } catch {\n    return callback(false);\n  }\n}\n\nObjectDefineProperty(exists\x2C kCustomPromisifiedSymbol\x2C {\n  __proto__: null\x2C\n  value: function exists(path) { // eslint-disable-line func-name-matching\n    return new Promise((resolve) => fs.exists(path\x2C resolve));\n  }\x2C\n});\n\n// fs.existsSync never throws\x2C it only returns true or false.\n// Since fs.existsSync never throws\x2C users have established\n// the expectation that passing invalid arguments to it\x2C even like\n// fs.existsSync()\x2C would only get a false in return\x2C so we cannot signal\n// validation errors to users properly out of compatibility concerns.\n// TODO(joyeecheung): deprecate the never-throw-on-invalid-arguments behavior\n/**\n * Synchronously tests whether or not the given path exists.\n * @param {string | Buffer | URL} path\n * @returns {boolean}\n */\nfunction existsSync(path) {\n  try {\n    path = getValidatedPath(path);\n  } catch {\n    return false;\n  }\n\n  return binding.existsSync(pathModule.toNamespacedPath(path));\n}\n\nfunction readFileAfterOpen(err\x2C fd) {\n  const context = this.context;\n\n  if (err) {\n    context.callback(err);\n    return;\n  }\n\n  context.fd = fd;\n\n  const req = new FSReqCallback();\n  req.oncomplete = readFileAfterStat;\n  req.context = context;\n  binding.fstat(fd\x2C false\x2C req);\n}\n\nfunction readFileAfterStat(err\x2C stats) {\n  const context = this.context;\n\n  if (err)\n    return context.close(err);\n\n  // TODO(BridgeAR): Check if allocating a smaller chunk is better performance\n  // wise\x2C similar to the promise based version (less peak memory and chunked\n  // stringify operations vs multiple C++/JS boundary crossings).\n  const size = context.size = isFileType(stats\x2C S_IFREG) ? stats[8] : 0;\n\n  if (size > kIoMaxLength) {\n    err = new ERR_FS_FILE_TOO_LARGE(size);\n    return context.close(err);\n  }\n\n  try {\n    if (size === 0) {\n      // TODO(BridgeAR): If an encoding is set\x2C use the StringDecoder to concat\n      // the result and reuse the buffer instead of allocating a new one.\n      context.buffers = [];\n    } else {\n      context.buffer = Buffer.allocUnsafeSlow(size);\n    }\n  } catch (err) {\n    return context.close(err);\n  }\n  context.read();\n}\n\nfunction checkAborted(signal\x2C callback) {\n  if (signal?.aborted) {\n    callback(new AbortError(undefined\x2C { cause: signal?.reason }));\n    return true;\n  }\n  return false;\n}\n\n/**\n * Asynchronously reads the entire contents of a file.\n * @param {string | Buffer | URL | number} path\n * @param {{\n *   encoding?: string | null;\n *   flag?: string;\n *   signal?: AbortSignal;\n *   } | string} [options]\n * @param {(\n *   err?: Error\x2C\n *   data?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction readFile(path\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C { flag: 'r' });\n  const ReadFileContext = require('internal/fs/read/context');\n  const context = new ReadFileContext(callback\x2C options.encoding);\n  context.isUserFd = isFd(path); // File descriptor ownership\n\n  if (options.signal) {\n    context.signal = options.signal;\n  }\n  if (context.isUserFd) {\n    process.nextTick(function tick(context) {\n      ReflectApply(readFileAfterOpen\x2C { context }\x2C [null\x2C path]);\n    }\x2C context);\n    return;\n  }\n\n  if (checkAborted(options.signal\x2C callback))\n    return;\n\n  const flagsNumber = stringToFlags(options.flag\x2C 'options.flag');\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.context = context;\n  req.oncomplete = readFileAfterOpen;\n  binding.open(pathModule.toNamespacedPath(path)\x2C\n               flagsNumber\x2C\n               0o666\x2C\n               req);\n}\n\nfunction tryStatSync(fd\x2C isUserFd) {\n  const stats = binding.fstat(fd\x2C false\x2C undefined\x2C true /* shouldNotThrow */);\n  if (stats === undefined && !isUserFd) {\n    fs.closeSync(fd);\n  }\n  return stats;\n}\n\nfunction tryCreateBuffer(size\x2C fd\x2C isUserFd) {\n  let threw = true;\n  let buffer;\n  try {\n    if (size > kIoMaxLength) {\n      throw new ERR_FS_FILE_TOO_LARGE(size);\n    }\n    buffer = Buffer.allocUnsafe(size);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return buffer;\n}\n\nfunction tryReadSync(fd\x2C isUserFd\x2C buffer\x2C pos\x2C len) {\n  let threw = true;\n  let bytesRead;\n  try {\n    bytesRead = fs.readSync(fd\x2C buffer\x2C pos\x2C len);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return bytesRead;\n}\n\n/**\n * Synchronously reads the entire contents of a file.\n * @param {string | Buffer | URL | number} path\n * @param {{\n *   encoding?: string | null;\n *   flag?: string;\n *   }} [options]\n * @returns {string | Buffer}\n */\nfunction readFileSync(path\x2C options) {\n  options = getOptions(options\x2C { flag: 'r' });\n\n  if (options.encoding === 'utf8' || options.encoding === 'utf-8') {\n    if (!isInt32(path)) {\n      path = pathModule.toNamespacedPath(getValidatedPath(path));\n    }\n    return binding.readFileUtf8(path\x2C stringToFlags(options.flag));\n  }\n\n  const isUserFd = isFd(path); // File descriptor ownership\n  const fd = isUserFd ? path : fs.openSync(path\x2C options.flag\x2C 0o666);\n\n  const stats = tryStatSync(fd\x2C isUserFd);\n  const size = isFileType(stats\x2C S_IFREG) ? stats[8] : 0;\n  let pos = 0;\n  let buffer; // Single buffer with file data\n  let buffers; // List for when size is unknown\n\n  if (size === 0) {\n    buffers = [];\n  } else {\n    buffer = tryCreateBuffer(size\x2C fd\x2C isUserFd);\n  }\n\n  let bytesRead;\n\n  if (size !== 0) {\n    do {\n      bytesRead = tryReadSync(fd\x2C isUserFd\x2C buffer\x2C pos\x2C size - pos);\n      pos += bytesRead;\n    } while (bytesRead !== 0 && pos < size);\n  } else {\n    do {\n      // The kernel lies about many files.\n      // Go ahead and try to read some bytes.\n      buffer = Buffer.allocUnsafe(8192);\n      bytesRead = tryReadSync(fd\x2C isUserFd\x2C buffer\x2C 0\x2C 8192);\n      if (bytesRead !== 0) {\n        ArrayPrototypePush(buffers\x2C buffer.slice(0\x2C bytesRead));\n      }\n      pos += bytesRead;\n    } while (bytesRead !== 0);\n  }\n\n  if (!isUserFd)\n    fs.closeSync(fd);\n\n  if (size === 0) {\n    // Data was collected into the buffers list.\n    buffer = Buffer.concat(buffers\x2C pos);\n  } else if (pos < size) {\n    buffer = buffer.slice(0\x2C pos);\n  }\n\n  if (options.encoding) buffer = buffer.toString(options.encoding);\n  return buffer;\n}\n\nfunction defaultCloseCallback(err) {\n  if (err != null) throw err;\n}\n\n/**\n * Closes the file descriptor.\n * @param {number} fd\n * @param {(err?: Error) => any} [callback]\n * @returns {void}\n */\nfunction close(fd\x2C callback = defaultCloseCallback) {\n  fd = getValidatedFd(fd);\n  if (callback !== defaultCloseCallback)\n    callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.close(fd\x2C req);\n}\n\n/**\n * Synchronously closes the file descriptor.\n * @param {number} fd\n * @returns {void}\n */\nfunction closeSync(fd) {\n  fd = getValidatedFd(fd);\n\n  binding.close(fd);\n}\n\n/**\n * Asynchronously opens a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} [flags]\n * @param {string | number} [mode]\n * @param {(\n *   err?: Error\x2C\n *   fd?: number\n *   ) => any} callback\n * @returns {void}\n */\nfunction open(path\x2C flags\x2C mode\x2C callback) {\n  path = getValidatedPath(path);\n  if (arguments.length < 3) {\n    callback = flags;\n    flags = 'r';\n    mode = 0o666;\n  } else if (typeof mode === 'function') {\n    callback = mode;\n    mode = 0o666;\n  } else {\n    mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\n  }\n  const flagsNumber = stringToFlags(flags);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n\n  binding.open(pathModule.toNamespacedPath(path)\x2C\n               flagsNumber\x2C\n               mode\x2C\n               req);\n}\n\n/**\n * Synchronously opens a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} [flags]\n * @param {string | number} [mode]\n * @returns {number}\n */\nfunction openSync(path\x2C flags\x2C mode) {\n  path = getValidatedPath(path);\n\n  return binding.open(\n    pathModule.toNamespacedPath(path)\x2C\n    stringToFlags(flags)\x2C\n    parseFileMode(mode\x2C 'mode'\x2C 0o666)\x2C\n  );\n}\n\n/**\n * @param {string | Buffer | URL } path\n * @param {{\n *   type?: string;\n *   }} [options]\n * @returns {Promise<Blob>}\n */\nfunction openAsBlob(path\x2C options = kEmptyObject) {\n  validateObject(options\x2C 'options');\n  const type = options.type || '';\n  validateString(type\x2C 'options.type');\n  // The underlying implementation here returns the Blob synchronously for now.\n  // To give ourselves flexibility to maybe return the Blob asynchronously\x2C\n  // this API returns a Promise.\n  path = getValidatedPath(path);\n  return PromiseResolve(createBlobFromFilePath(pathModule.toNamespacedPath(path)\x2C { type }));\n}\n\n/**\n * Reads file from the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView} buffer\n * @param {number} offsetOrOptions\n * @param {number} length\n * @param {number | bigint | null} position\n * @param {(\n *   err?: Error\x2C\n *   bytesRead?: number\x2C\n *   buffer?: Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction read(fd\x2C buffer\x2C offsetOrOptions\x2C length\x2C position\x2C callback) {\n  fd = getValidatedFd(fd);\n\n  let offset = offsetOrOptions;\n  let params = null;\n  if (arguments.length <= 4) {\n    if (arguments.length === 4) {\n      // This is fs.read(fd\x2C buffer\x2C options\x2C callback)\n      validateObject(offsetOrOptions\x2C 'options'\x2C kValidateObjectAllowNullable);\n      callback = length;\n      params = offsetOrOptions;\n    } else if (arguments.length === 3) {\n      // This is fs.read(fd\x2C bufferOrParams\x2C callback)\n      if (!isArrayBufferView(buffer)) {\n        // This is fs.read(fd\x2C params\x2C callback)\n        params = buffer;\n        ({ buffer = Buffer.alloc(16384) } = params ?? kEmptyObject);\n      }\n      callback = offsetOrOptions;\n    } else {\n      // This is fs.read(fd\x2C callback)\n      callback = buffer;\n      buffer = Buffer.alloc(16384);\n    }\n\n    if (params !== undefined) {\n      validateObject(params\x2C 'options'\x2C kValidateObjectAllowNullable);\n    }\n    ({\n      offset = 0\x2C\n      length = buffer?.byteLength - offset\x2C\n      position = null\x2C\n    } = params ?? kEmptyObject);\n  }\n\n  validateBuffer(buffer);\n  callback = maybeCallback(callback);\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0) {\n    return process.nextTick(function tick() {\n      callback(null\x2C 0\x2C buffer);\n    });\n  }\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (position == null)\n    position = -1;\n\n  validatePosition(position\x2C 'position');\n\n  function wrapper(err\x2C bytesRead) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err\x2C bytesRead || 0\x2C buffer);\n  }\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  binding.read(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C req);\n}\n\nObjectDefineProperty(read\x2C kCustomPromisifyArgsSymbol\x2C\n                     { __proto__: null\x2C value: ['bytesRead'\x2C 'buffer']\x2C enumerable: false });\n\n/**\n * Synchronously reads the file from the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView} buffer\n * @param {{\n *   offset?: number;\n *   length?: number;\n *   position?: number | bigint | null;\n *   }} [offsetOrOptions]\n * @returns {number}\n */\nfunction readSync(fd\x2C buffer\x2C offsetOrOptions\x2C length\x2C position) {\n  fd = getValidatedFd(fd);\n\n  validateBuffer(buffer);\n\n  let offset = offsetOrOptions;\n  if (arguments.length <= 3 || typeof offsetOrOptions === 'object') {\n    if (offsetOrOptions !== undefined) {\n      validateObject(offsetOrOptions\x2C 'options'\x2C kValidateObjectAllowNullable);\n    }\n\n    ({\n      offset = 0\x2C\n      length = buffer.byteLength - offset\x2C\n      position = null\x2C\n    } = offsetOrOptions ?? kEmptyObject);\n  }\n\n  if (offset === undefined) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0) {\n    return 0;\n  }\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (position == null)\n    position = -1;\n\n  validatePosition(position\x2C 'position');\n\n  return binding.read(fd\x2C buffer\x2C offset\x2C length\x2C position);\n}\n\n/**\n * Reads file from the specified `fd` (file descriptor)\n * and writes to an array of `ArrayBufferView`s.\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number | null} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesRead?: number\x2C\n *   buffers?: ArrayBufferView[];\n *   ) => any} callback\n * @returns {void}\n */\nfunction readv(fd\x2C buffers\x2C position\x2C callback) {\n  function wrapper(err\x2C read) {\n    callback(err\x2C read || 0\x2C buffers);\n  }\n\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n  callback = maybeCallback(callback || position);\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  if (typeof position !== 'number')\n    position = null;\n\n  binding.readBuffers(fd\x2C buffers\x2C position\x2C req);\n}\n\nObjectDefineProperty(readv\x2C kCustomPromisifyArgsSymbol\x2C\n                     { __proto__: null\x2C value: ['bytesRead'\x2C 'buffers']\x2C enumerable: false });\n\n/**\n * Synchronously reads file from the\n * specified `fd` (file descriptor) and writes to an array\n * of `ArrayBufferView`s.\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number | null} [position]\n * @returns {number}\n */\nfunction readvSync(fd\x2C buffers\x2C position) {\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n\n  const ctx = {};\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const result = binding.readBuffers(fd\x2C buffers\x2C position\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Writes `buffer` to the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView | string} buffer\n * @param {number | object} [offsetOrOptions]\n * @param {number} [length]\n * @param {number | null} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesWritten?: number;\n *   buffer?: Buffer | TypedArray | DataView\n *   ) => any} callback\n * @returns {void}\n */\nfunction write(fd\x2C buffer\x2C offsetOrOptions\x2C length\x2C position\x2C callback) {\n  function wrapper(err\x2C written) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err\x2C written || 0\x2C buffer);\n  }\n\n  fd = getValidatedFd(fd);\n\n  let offset = offsetOrOptions;\n  if (isArrayBufferView(buffer)) {\n    callback = maybeCallback(callback || position || length || offset);\n\n    if (typeof offset === 'object') {\n      ({\n        offset = 0\x2C\n        length = buffer.byteLength - offset\x2C\n        position = null\x2C\n      } = offsetOrOptions ?? kEmptyObject);\n    }\n\n    if (offset == null || typeof offset === 'function') {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    if (typeof position !== 'number')\n      position = null;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n\n    const req = new FSReqCallback();\n    req.oncomplete = wrapper;\n    binding.writeBuffer(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C req);\n    return;\n  }\n\n  validateStringAfterArrayBufferView(buffer\x2C 'buffer');\n\n  if (typeof position !== 'function') {\n    if (typeof offset === 'function') {\n      position = offset;\n      offset = null;\n    } else {\n      position = length;\n    }\n    length = 'utf8';\n  }\n\n  const str = buffer;\n  validateEncoding(str\x2C length);\n  callback = maybeCallback(position);\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n  binding.writeString(fd\x2C str\x2C offset\x2C length\x2C req);\n}\n\nObjectDefineProperty(write\x2C kCustomPromisifyArgsSymbol\x2C\n                     { __proto__: null\x2C value: ['bytesWritten'\x2C 'buffer']\x2C enumerable: false });\n\n/**\n * Synchronously writes `buffer` to the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView | string} buffer\n * @param {{\n *   offset?: number;\n *   length?: number;\n *   position?: number | null;\n *   }} [offsetOrOptions]\n * @returns {number}\n */\nfunction writeSync(fd\x2C buffer\x2C offsetOrOptions\x2C length\x2C position) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  let result;\n\n  let offset = offsetOrOptions;\n  if (isArrayBufferView(buffer)) {\n    if (typeof offset === 'object') {\n      ({\n        offset = 0\x2C\n        length = buffer.byteLength - offset\x2C\n        position = null\x2C\n      } = offsetOrOptions ?? kEmptyObject);\n    }\n    if (position === undefined)\n      position = null;\n    if (offset == null) {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n    result = binding.writeBuffer(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C\n                                 undefined\x2C ctx);\n  } else {\n    validateStringAfterArrayBufferView(buffer\x2C 'buffer');\n    validateEncoding(buffer\x2C length);\n\n    if (offset === undefined)\n      offset = null;\n    result = binding.writeString(fd\x2C buffer\x2C offset\x2C length\x2C\n                                 undefined\x2C ctx);\n  }\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Writes an array of `ArrayBufferView`s to the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number | null} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesWritten?: number\x2C\n *   buffers?: ArrayBufferView[]\n *   ) => any} callback\n * @returns {void}\n */\nfunction writev(fd\x2C buffers\x2C position\x2C callback) {\n  function wrapper(err\x2C written) {\n    callback(err\x2C written || 0\x2C buffers);\n  }\n\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n  callback = maybeCallback(callback || position);\n\n  if (buffers.length === 0) {\n    process.nextTick(callback\x2C null\x2C 0\x2C buffers);\n    return;\n  }\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  if (typeof position !== 'number')\n    position = null;\n\n  binding.writeBuffers(fd\x2C buffers\x2C position\x2C req);\n}\n\nObjectDefineProperty(writev\x2C kCustomPromisifyArgsSymbol\x2C {\n  __proto__: null\x2C\n  value: ['bytesWritten'\x2C 'buffer']\x2C\n  enumerable: false\x2C\n});\n\n/**\n * Synchronously writes an array of `ArrayBufferView`s\n * to the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number | null} [position]\n * @returns {number}\n */\nfunction writevSync(fd\x2C buffers\x2C position) {\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n\n  if (buffers.length === 0) {\n    return 0;\n  }\n\n  if (typeof position !== 'number')\n    position = null;\n\n  return binding.writeBuffers(fd\x2C buffers\x2C position);\n}\n\n/**\n * Asynchronously renames file at `oldPath` to\n * the pathname provided as `newPath`.\n * @param {string | Buffer | URL} oldPath\n * @param {string | Buffer | URL} newPath\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rename(oldPath\x2C newPath\x2C callback) {\n  callback = makeCallback(callback);\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\n                 pathModule.toNamespacedPath(newPath)\x2C\n                 req);\n}\n\n\n/**\n * Synchronously renames file at `oldPath` to\n * the pathname provided as `newPath`.\n * @param {string | Buffer | URL} oldPath\n * @param {string | Buffer | URL} newPath\n * @returns {void}\n */\nfunction renameSync(oldPath\x2C newPath) {\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  binding.rename(\n    pathModule.toNamespacedPath(oldPath)\x2C\n    pathModule.toNamespacedPath(newPath)\x2C\n  );\n}\n\n/**\n * Truncates the file.\n * @param {string | Buffer | URL} path\n * @param {number} [len]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction truncate(path\x2C len\x2C callback) {\n  if (typeof path === 'number') {\n    showTruncateDeprecation();\n    return fs.ftruncate(path\x2C len\x2C callback);\n  }\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  } else if (len === undefined) {\n    len = 0;\n  }\n\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  callback = maybeCallback(callback);\n  fs.open(path\x2C 'r+'\x2C (er\x2C fd) => {\n    if (er) return callback(er);\n    const req = new FSReqCallback();\n    req.oncomplete = function oncomplete(er) {\n      fs.close(fd\x2C (er2) => {\n        callback(aggregateTwoErrors(er2\x2C er));\n      });\n    };\n    binding.ftruncate(fd\x2C len\x2C req);\n  });\n}\n\n/**\n * Synchronously truncates the file.\n * @param {string | Buffer | URL} path\n * @param {number} [len]\n * @returns {void}\n */\nfunction truncateSync(path\x2C len) {\n  if (typeof path === 'number') {\n    // legacy\n    showTruncateDeprecation();\n    return fs.ftruncateSync(path\x2C len);\n  }\n  if (len === undefined) {\n    len = 0;\n  }\n  // Allow error to be thrown\x2C but still close fd.\n  const fd = fs.openSync(path\x2C 'r+');\n  let ret;\n\n  try {\n    ret = fs.ftruncateSync(fd\x2C len);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n}\n\n/**\n * Truncates the file descriptor.\n * @param {number} fd\n * @param {number} [len]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction ftruncate(fd\x2C len = 0\x2C callback) {\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  }\n  fd = getValidatedFd(fd);\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.ftruncate(fd\x2C len\x2C req);\n}\n\n/**\n * Synchronously truncates the file descriptor.\n * @param {number} fd\n * @param {number} [len]\n * @returns {void}\n */\nfunction ftruncateSync(fd\x2C len = 0) {\n  fd = getValidatedFd(fd);\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  binding.ftruncate(fd\x2C len);\n}\n\nfunction lazyLoadCp() {\n  if (cpFn === undefined) {\n    ({ cpFn } = require('internal/fs/cp/cp'));\n    cpFn = require('util').callbackify(cpFn);\n    ({ cpSyncFn } = require('internal/fs/cp/cp-sync'));\n  }\n}\n\nfunction lazyLoadRimraf() {\n  if (rimraf === undefined)\n    ({ rimraf\x2C rimrafSync } = require('internal/fs/rimraf'));\n}\n\n/**\n * Asynchronously removes a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rmdir(path\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  callback = makeCallback(callback);\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n\n  if (options?.recursive) {\n    emitRecursiveRmdirWarning();\n    validateRmOptions(\n      path\x2C\n      { ...options\x2C force: false }\x2C\n      true\x2C\n      (err\x2C options) => {\n        if (err === false) {\n          const req = new FSReqCallback();\n          req.oncomplete = callback;\n          binding.rmdir(path\x2C req);\n          return;\n        }\n        if (err) {\n          return callback(err);\n        }\n\n        lazyLoadRimraf();\n        rimraf(path\x2C options\x2C callback);\n      });\n  } else {\n    validateRmdirOptions(options);\n    const req = new FSReqCallback();\n    req.oncomplete = callback;\n    binding.rmdir(path\x2C req);\n  }\n}\n\n/**\n * Synchronously removes a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @returns {void}\n */\nfunction rmdirSync(path\x2C options) {\n  path = getValidatedPath(path);\n\n  if (options?.recursive) {\n    emitRecursiveRmdirWarning();\n    options = validateRmOptionsSync(path\x2C { ...options\x2C force: false }\x2C true);\n    if (options !== false) {\n      lazyLoadRimraf();\n      return rimrafSync(pathModule.toNamespacedPath(path)\x2C options);\n    }\n  } else {\n    validateRmdirOptions(options);\n  }\n\n  binding.rmdir(pathModule.toNamespacedPath(path));\n}\n\n/**\n * Asynchronously removes files and\n * directories (modeled on the standard POSIX `rm` utility).\n * @param {string | Buffer | URL} path\n * @param {{\n *   force?: boolean;\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rm(path\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  path = getValidatedPath(path);\n\n  validateRmOptions(path\x2C options\x2C false\x2C (err\x2C options) => {\n    if (err) {\n      return callback(err);\n    }\n    lazyLoadRimraf();\n    return rimraf(pathModule.toNamespacedPath(path)\x2C options\x2C callback);\n  });\n}\n\n/**\n * Synchronously removes files and\n * directories (modeled on the standard POSIX `rm` utility).\n * @param {string | Buffer | URL} path\n * @param {{\n *   force?: boolean;\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @returns {void}\n */\nfunction rmSync(path\x2C options) {\n  path = getValidatedPath(path);\n  options = validateRmOptionsSync(path\x2C options\x2C false);\n\n  lazyLoadRimraf();\n  return rimrafSync(pathModule.toNamespacedPath(path)\x2C options);\n}\n\n/**\n * Forces all currently queued I/O operations associated\n * with the file to the operating system's synchronized\n * I/O completion state.\n * @param {number} fd\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fdatasync(fd\x2C callback) {\n  fd = getValidatedFd(fd);\n  const req = new FSReqCallback();\n  req.oncomplete = makeCallback(callback);\n  binding.fdatasync(fd\x2C req);\n}\n\n/**\n * Synchronously forces all currently queued I/O operations\n * associated with the file to the operating\n * system's synchronized I/O completion state.\n * @param {number} fd\n * @returns {void}\n */\nfunction fdatasyncSync(fd) {\n  fd = getValidatedFd(fd);\n  binding.fdatasync(fd);\n}\n\n/**\n * Requests for all data for the open file descriptor\n * to be flushed to the storage device.\n * @param {number} fd\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fsync(fd\x2C callback) {\n  fd = getValidatedFd(fd);\n  const req = new FSReqCallback();\n  req.oncomplete = makeCallback(callback);\n  binding.fsync(fd\x2C req);\n}\n\n/**\n * Synchronously requests for all data for the open\n * file descriptor to be flushed to the storage device.\n * @param {number} fd\n * @returns {void}\n */\nfunction fsyncSync(fd) {\n  fd = getValidatedFd(fd);\n  binding.fsync(fd);\n}\n\n/**\n * Asynchronously creates a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   recursive?: boolean;\n *   mode?: string | number;\n *   } | number} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction mkdir(path\x2C options\x2C callback) {\n  let mode = 0o777;\n  let recursive = false;\n  if (typeof options === 'function') {\n    callback = options;\n  } else if (typeof options === 'number' || typeof options === 'string') {\n    mode = options;\n  } else if (options) {\n    if (options.recursive !== undefined)\n      recursive = options.recursive;\n    if (options.mode !== undefined)\n      mode = options.mode;\n  }\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.mkdir(pathModule.toNamespacedPath(path)\x2C\n                parseFileMode(mode\x2C 'mode')\x2C recursive\x2C req);\n}\n\n/**\n * Synchronously creates a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   recursive?: boolean;\n *   mode?: string | number;\n *   } | number} [options]\n * @returns {string | void}\n */\nfunction mkdirSync(path\x2C options) {\n  let mode = 0o777;\n  let recursive = false;\n  if (typeof options === 'number' || typeof options === 'string') {\n    mode = options;\n  } else if (options) {\n    if (options.recursive !== undefined)\n      recursive = options.recursive;\n    if (options.mode !== undefined)\n      mode = options.mode;\n  }\n  path = getValidatedPath(path);\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  const result = binding.mkdir(\n    pathModule.toNamespacedPath(path)\x2C\n    parseFileMode(mode\x2C 'mode')\x2C\n    recursive\x2C\n  );\n\n  if (recursive) {\n    return result;\n  }\n}\n\n/**\n * An iterative algorithm for reading the entire contents of the `basePath` directory.\n * This function does not validate `basePath` as a directory. It is passed directly to\n * `binding.readdir`.\n * @param {string} basePath\n * @param {{ encoding: string\x2C withFileTypes: boolean }} options\n * @returns {string[] | Dirent[]}\n */\nfunction readdirSyncRecursive(basePath\x2C options) {\n  const withFileTypes = Boolean(options.withFileTypes);\n  const encoding = options.encoding;\n\n  const readdirResults = [];\n  const pathsQueue = [basePath];\n\n  function read(path) {\n    const readdirResult = binding.readdir(\n      pathModule.toNamespacedPath(path)\x2C\n      encoding\x2C\n      withFileTypes\x2C\n    );\n\n    if (readdirResult === undefined) {\n      return;\n    }\n\n    if (withFileTypes) {\n      // Calling `readdir` with `withFileTypes=true`\x2C the result is an array of arrays.\n      // The first array is the names\x2C and the second array is the types.\n      // They are guaranteed to be the same length; hence\x2C setting `length` to the length\n      // of the first array within the result.\n      const length = readdirResult[0].length;\n      for (let i = 0; i < length; i++) {\n        const dirent = getDirent(path\x2C readdirResult[0][i]\x2C readdirResult[1][i]);\n        ArrayPrototypePush(readdirResults\x2C dirent);\n        if (dirent.isDirectory()) {\n          ArrayPrototypePush(pathsQueue\x2C pathModule.join(dirent.path\x2C dirent.name));\n        }\n      }\n    } else {\n      for (let i = 0; i < readdirResult.length; i++) {\n        const resultPath = pathModule.join(path\x2C readdirResult[i]);\n        const relativeResultPath = pathModule.relative(basePath\x2C resultPath);\n        const stat = binding.internalModuleStat(resultPath);\n        ArrayPrototypePush(readdirResults\x2C relativeResultPath);\n        // 1 indicates directory\n        if (stat === 1) {\n          ArrayPrototypePush(pathsQueue\x2C resultPath);\n        }\n      }\n    }\n  }\n\n  for (let i = 0; i < pathsQueue.length; i++) {\n    read(pathsQueue[i]);\n  }\n\n  return readdirResults;\n}\n\n/**\n * Reads the contents of a directory.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   encoding?: string;\n *   withFileTypes?: boolean;\n *   recursive?: boolean;\n *   }} [options]\n * @param {(\n *   err?: Error\x2C\n *   files?: string[] | Buffer[] | Dirent[];\n *   ) => any} callback\n * @returns {void}\n */\nfunction readdir(path\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options);\n  path = getValidatedPath(path);\n  if (options.recursive != null) {\n    validateBoolean(options.recursive\x2C 'options.recursive');\n  }\n\n  if (options.recursive) {\n    callback(null\x2C readdirSyncRecursive(path\x2C options));\n    return;\n  }\n\n  const req = new FSReqCallback();\n  if (!options.withFileTypes) {\n    req.oncomplete = callback;\n  } else {\n    req.oncomplete = (err\x2C result) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      getDirents(path\x2C result\x2C callback);\n    };\n  }\n  binding.readdir(pathModule.toNamespacedPath(path)\x2C options.encoding\x2C\n                  !!options.withFileTypes\x2C req);\n}\n\n/**\n * Synchronously reads the contents of a directory.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   encoding?: string;\n *   withFileTypes?: boolean;\n *   recursive?: boolean;\n *   }} [options]\n * @returns {string | Buffer[] | Dirent[]}\n */\nfunction readdirSync(path\x2C options) {\n  options = getOptions(options);\n  path = getValidatedPath(path);\n  if (options.recursive != null) {\n    validateBoolean(options.recursive\x2C 'options.recursive');\n  }\n\n  if (options.recursive) {\n    return readdirSyncRecursive(path\x2C options);\n  }\n\n  const result = binding.readdir(\n    pathModule.toNamespacedPath(path)\x2C\n    options.encoding\x2C\n    !!options.withFileTypes\x2C\n  );\n\n  return result !== undefined && options.withFileTypes ? getDirents(path\x2C result) : result;\n}\n\n/**\n * Invokes the callback with the `fs.Stats`\n * for the file descriptor.\n * @param {number} fd\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction fstat(fd\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = kEmptyObject;\n  }\n  fd = getValidatedFd(fd);\n  callback = makeStatsCallback(callback);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.fstat(fd\x2C options.bigint\x2C req);\n}\n\n/**\n * Retrieves the `fs.Stats` for the symbolic link\n * referred to by the `path`.\n * @param {string | Buffer | URL} path\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction lstat(path\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = kEmptyObject;\n  }\n  callback = makeStatsCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.lstat(pathModule.toNamespacedPath(path)\x2C options.bigint\x2C req);\n}\n\n/**\n * Asynchronously gets the stats of a file.\n * @param {string | Buffer | URL} path\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction stat(path\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = kEmptyObject;\n  }\n  callback = makeStatsCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.stat(pathModule.toNamespacedPath(path)\x2C options.bigint\x2C req);\n}\n\nfunction statfs(path\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = kEmptyObject;\n  }\n  callback = maybeCallback(callback);\n  path = getValidatedPath(path);\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = (err\x2C stats) => {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(err\x2C getStatFsFromBinding(stats));\n  };\n  binding.statfs(pathModule.toNamespacedPath(path)\x2C options.bigint\x2C req);\n}\n\n/**\n * Synchronously retrieves the `fs.Stats` for\n * the file descriptor.\n * @param {number} fd\n * @param {{\n *   bigint?: boolean;\n *   }} [options]\n * @returns {Stats | undefined}\n */\nfunction fstatSync(fd\x2C options = { bigint: false }) {\n  fd = getValidatedFd(fd);\n  const stats = binding.fstat(fd\x2C options.bigint\x2C undefined\x2C false);\n  if (stats === undefined) {\n    return;\n  }\n  return getStatsFromBinding(stats);\n}\n\n/**\n * Synchronously retrieves the `fs.Stats` for\n * the symbolic link referred to by the `path`.\n * @param {string | Buffer | URL} path\n * @param {{\n *   bigint?: boolean;\n *   throwIfNoEntry?: boolean;\n *   }} [options]\n * @returns {Stats | undefined}\n */\nfunction lstatSync(path\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\n  path = getValidatedPath(path);\n  const stats = binding.lstat(\n    pathModule.toNamespacedPath(path)\x2C\n    options.bigint\x2C\n    undefined\x2C\n    options.throwIfNoEntry\x2C\n  );\n\n  if (stats === undefined) {\n    return;\n  }\n  return getStatsFromBinding(stats);\n}\n\n/**\n * Synchronously retrieves the `fs.Stats`\n * for the `path`.\n * @param {string | Buffer | URL} path\n * @param {{\n *   bigint?: boolean;\n *   throwIfNoEntry?: boolean;\n *   }} [options]\n * @returns {Stats}\n */\nfunction statSync(path\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\n  path = getValidatedPath(path);\n  const stats = binding.stat(\n    pathModule.toNamespacedPath(path)\x2C\n    options.bigint\x2C\n    undefined\x2C\n    options.throwIfNoEntry\x2C\n  );\n  if (stats === undefined) {\n    return undefined;\n  }\n  return getStatsFromBinding(stats);\n}\n\nfunction statfsSync(path\x2C options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const stats = binding.statfs(pathModule.toNamespacedPath(path)\x2C options.bigint);\n  return getStatFsFromBinding(stats);\n}\n\n/**\n * Reads the contents of a symbolic link\n * referred to by `path`.\n * @param {string | Buffer | URL} path\n * @param {{ encoding?: string; } | string} [options]\n * @param {(\n *   err?: Error\x2C\n *   linkString?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction readlink(path\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options);\n  path = getValidatedPath(path\x2C 'oldPath');\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.readlink(pathModule.toNamespacedPath(path)\x2C options.encoding\x2C req);\n}\n\n/**\n * Synchronously reads the contents of a symbolic link\n * referred to by `path`.\n * @param {string | Buffer | URL} path\n * @param {{ encoding?: string; } | string} [options]\n * @returns {string | Buffer}\n */\nfunction readlinkSync(path\x2C options) {\n  options = getOptions(options);\n  path = getValidatedPath(path\x2C 'oldPath');\n  return binding.readlink(\n    pathModule.toNamespacedPath(path)\x2C\n    options.encoding\x2C\n  );\n}\n\n/**\n * Creates the link called `path` pointing to `target`.\n * @param {string | Buffer | URL} target\n * @param {string | Buffer | URL} path\n * @param {string | null} [type_]\n * @param {(err?: Error) => any} callback_\n * @returns {void}\n */\nfunction symlink(target\x2C path\x2C type_\x2C callback_) {\n  const type = (typeof type_ === 'string' ? type_ : null);\n  const callback = makeCallback(arguments[arguments.length - 1]);\n\n  if (permission.isEnabled()) {\n    // The permission model's security guarantees fall apart in the presence of\n    // relative symbolic links. Thus\x2C we have to prevent their creation.\n    if (typeof target !== 'string' || !isAbsolute(toPathIfFileURL(target))) {\n      callback(new ERR_ACCESS_DENIED('relative symbolic link target'));\n      return;\n    }\n  }\n\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n\n  if (isWindows && type === null) {\n    let absoluteTarget;\n    try {\n      // Symlinks targets can be relative to the newly created path.\n      // Calculate absolute file name of the symlink target\x2C and check\n      // if it is a directory. Ignore resolve error to keep symlink\n      // errors consistent between platforms if invalid path is\n      // provided.\n      absoluteTarget = pathModule.resolve(path\x2C '..'\x2C target);\n    } catch {\n      // Continue regardless of error.\n    }\n    if (absoluteTarget !== undefined) {\n      stat(absoluteTarget\x2C (err\x2C stat) => {\n        const resolvedType = !err && stat.isDirectory() ? 'dir' : 'file';\n        const resolvedFlags = stringToSymlinkType(resolvedType);\n        const destination = preprocessSymlinkDestination(target\x2C\n                                                         resolvedType\x2C\n                                                         path);\n\n        const req = new FSReqCallback();\n        req.oncomplete = callback;\n        binding.symlink(destination\x2C\n                        pathModule.toNamespacedPath(path)\x2C resolvedFlags\x2C req);\n      });\n      return;\n    }\n  }\n\n  const destination = preprocessSymlinkDestination(target\x2C type\x2C path);\n\n  const flags = stringToSymlinkType(type);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.symlink(destination\x2C pathModule.toNamespacedPath(path)\x2C flags\x2C req);\n}\n\n/**\n * Synchronously creates the link called `path`\n * pointing to `target`.\n * @param {string | Buffer | URL} target\n * @param {string | Buffer | URL} path\n * @param {string | null} [type]\n * @returns {void}\n */\nfunction symlinkSync(target\x2C path\x2C type) {\n  type = (typeof type === 'string' ? type : null);\n  if (isWindows && type === null) {\n    const absoluteTarget = pathModule.resolve(`${path}`\x2C '..'\x2C `${target}`);\n    if (statSync(absoluteTarget\x2C { throwIfNoEntry: false })?.isDirectory()) {\n      type = 'dir';\n    }\n  }\n\n  if (permission.isEnabled()) {\n    // The permission model's security guarantees fall apart in the presence of\n    // relative symbolic links. Thus\x2C we have to prevent their creation.\n    if (typeof target !== 'string' || !isAbsolute(toPathIfFileURL(target))) {\n      throw new ERR_ACCESS_DENIED('relative symbolic link target');\n    }\n  }\n\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n\n  binding.symlink(\n    preprocessSymlinkDestination(target\x2C type\x2C path)\x2C\n    pathModule.toNamespacedPath(path)\x2C\n    stringToSymlinkType(type)\x2C\n  );\n}\n\n/**\n * Creates a new link from the `existingPath`\n * to the `newPath`.\n * @param {string | Buffer | URL} existingPath\n * @param {string | Buffer | URL} newPath\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction link(existingPath\x2C newPath\x2C callback) {\n  callback = makeCallback(callback);\n\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n\n  binding.link(pathModule.toNamespacedPath(existingPath)\x2C\n               pathModule.toNamespacedPath(newPath)\x2C\n               req);\n}\n\n/**\n * Synchronously creates a new link from the `existingPath`\n * to the `newPath`.\n * @param {string | Buffer | URL} existingPath\n * @param {string | Buffer | URL} newPath\n * @returns {void}\n */\nfunction linkSync(existingPath\x2C newPath) {\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n\n  binding.link(\n    pathModule.toNamespacedPath(existingPath)\x2C\n    pathModule.toNamespacedPath(newPath)\x2C\n  );\n}\n\n/**\n * Asynchronously removes a file or symbolic link.\n * @param {string | Buffer | URL} path\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction unlink(path\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.unlink(pathModule.toNamespacedPath(path)\x2C req);\n}\n\n/**\n * Synchronously removes a file or symbolic link.\n * @param {string | Buffer | URL} path\n * @returns {void}\n */\nfunction unlinkSync(path) {\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n  binding.unlink(path);\n}\n\n/**\n * Sets the permissions on the file.\n * @param {number} fd\n * @param {string | number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fchmod(fd\x2C mode\x2C callback) {\n  fd = getValidatedFd(fd);\n  mode = parseFileMode(mode\x2C 'mode');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.fchmod(fd\x2C mode\x2C req);\n}\n\n/**\n * Synchronously sets the permissions on the file.\n * @param {number} fd\n * @param {string | number} mode\n * @returns {void}\n */\nfunction fchmodSync(fd\x2C mode) {\n  binding.fchmod(\n    getValidatedFd(fd)\x2C\n    parseFileMode(mode\x2C 'mode')\x2C\n  );\n}\n\n/**\n * Changes the permissions on a symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lchmod(path\x2C mode\x2C callback) {\n  callback = maybeCallback(callback);\n  mode = parseFileMode(mode\x2C 'mode');\n  fs.open(path\x2C O_WRONLY | O_SYMLINK\x2C (err\x2C fd) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    // Prefer to return the chmod error\x2C if one occurs\x2C\n    // but still try to close\x2C and report closing errors if they occur.\n    fs.fchmod(fd\x2C mode\x2C (err) => {\n      fs.close(fd\x2C (err2) => {\n        callback(aggregateTwoErrors(err2\x2C err));\n      });\n    });\n  });\n}\n\n/**\n * Synchronously changes the permissions on a symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} mode\n * @returns {void}\n */\nfunction lchmodSync(path\x2C mode) {\n  const fd = fs.openSync(path\x2C O_WRONLY | O_SYMLINK);\n\n  // Prefer to return the chmod error\x2C if one occurs\x2C\n  // but still try to close\x2C and report closing errors if they occur.\n  let ret;\n  try {\n    ret = fs.fchmodSync(fd\x2C mode);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n}\n\n/**\n * Asynchronously changes the permissions of a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction chmod(path\x2C mode\x2C callback) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C req);\n}\n\n/**\n * Synchronously changes the permissions of a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} mode\n * @returns {void}\n */\nfunction chmodSync(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n\n  binding.chmod(\n    pathModule.toNamespacedPath(path)\x2C\n    mode\x2C\n  );\n}\n\n/**\n * Sets the owner of the symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lchown(path\x2C uid\x2C gid\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.lchown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously sets the owner of the symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction lchownSync(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  binding.lchown(\n    pathModule.toNamespacedPath(path)\x2C\n    uid\x2C\n    gid\x2C\n  );\n}\n\n/**\n * Sets the owner of the file.\n * @param {number} fd\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fchown(fd\x2C uid\x2C gid\x2C callback) {\n  fd = getValidatedFd(fd);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.fchown(fd\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously sets the owner of the file.\n * @param {number} fd\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction fchownSync(fd\x2C uid\x2C gid) {\n  fd = getValidatedFd(fd);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n\n  const ctx = {};\n  binding.fchown(fd\x2C uid\x2C gid\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously changes the owner and group\n * of a file.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction chown(path\x2C uid\x2C gid\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.chown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously changes the owner and group\n * of a file.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction chownSync(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  binding.chown(\n    pathModule.toNamespacedPath(path)\x2C\n    uid\x2C\n    gid\x2C\n  );\n}\n\n/**\n * Changes the file system timestamps of the object\n * referenced by `path`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction utimes(path\x2C atime\x2C mtime\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.utimes(pathModule.toNamespacedPath(path)\x2C\n                 toUnixTimestamp(atime)\x2C\n                 toUnixTimestamp(mtime)\x2C\n                 req);\n}\n\n/**\n * Synchronously changes the file system timestamps\n * of the object referenced by `path`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction utimesSync(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  binding.utimes(\n    pathModule.toNamespacedPath(path)\x2C\n    toUnixTimestamp(atime)\x2C\n    toUnixTimestamp(mtime)\x2C\n  );\n}\n\n/**\n * Changes the file system timestamps of the object\n * referenced by the supplied `fd` (file descriptor).\n * @param {number} fd\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction futimes(fd\x2C atime\x2C mtime\x2C callback) {\n  fd = getValidatedFd(fd);\n  atime = toUnixTimestamp(atime\x2C 'atime');\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.futimes(fd\x2C atime\x2C mtime\x2C req);\n}\n\n/**\n * Synchronously changes the file system timestamps\n * of the object referenced by the\n * supplied `fd` (file descriptor).\n * @param {number} fd\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction futimesSync(fd\x2C atime\x2C mtime) {\n  binding.futimes(\n    getValidatedFd(fd)\x2C\n    toUnixTimestamp(atime\x2C 'atime')\x2C\n    toUnixTimestamp(mtime\x2C 'mtime')\x2C\n  );\n}\n\n/**\n * Changes the access and modification times of\n * a file in the same way as `fs.utimes()`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lutimes(path\x2C atime\x2C mtime\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.lutimes(pathModule.toNamespacedPath(path)\x2C\n                  toUnixTimestamp(atime)\x2C\n                  toUnixTimestamp(mtime)\x2C\n                  req);\n}\n\n/**\n * Synchronously changes the access and modification\n * times of a file in the same way as `fs.utimesSync()`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction lutimesSync(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  binding.lutimes(\n    pathModule.toNamespacedPath(path)\x2C\n    toUnixTimestamp(atime)\x2C\n    toUnixTimestamp(mtime)\x2C\n  );\n}\n\nfunction writeAll(fd\x2C isUserFd\x2C buffer\x2C offset\x2C length\x2C signal\x2C flush\x2C callback) {\n  if (signal?.aborted) {\n    const abortError = new AbortError(undefined\x2C { cause: signal?.reason });\n    if (isUserFd) {\n      callback(abortError);\n    } else {\n      fs.close(fd\x2C (err) => {\n        callback(aggregateTwoErrors(err\x2C abortError));\n      });\n    }\n    return;\n  }\n  // write(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C callback)\n  fs.write(fd\x2C buffer\x2C offset\x2C length\x2C null\x2C (writeErr\x2C written) => {\n    if (writeErr) {\n      if (isUserFd) {\n        callback(writeErr);\n      } else {\n        fs.close(fd\x2C (err) => {\n          callback(aggregateTwoErrors(err\x2C writeErr));\n        });\n      }\n    } else if (written === length) {\n      if (!flush) {\n        if (isUserFd) {\n          callback(null);\n        } else {\n          fs.close(fd\x2C callback);\n        }\n      } else {\n        fs.fsync(fd\x2C (syncErr) => {\n          if (syncErr) {\n            if (isUserFd) {\n              callback(syncErr);\n            } else {\n              fs.close(fd\x2C (err) => {\n                callback(aggregateTwoErrors(err\x2C syncErr));\n              });\n            }\n          } else if (isUserFd) {\n            callback(null);\n          } else {\n            fs.close(fd\x2C callback);\n          }\n        });\n      }\n    } else {\n      offset += written;\n      length -= written;\n      writeAll(fd\x2C isUserFd\x2C buffer\x2C offset\x2C length\x2C signal\x2C flush\x2C callback);\n    }\n  });\n}\n\n/**\n * Asynchronously writes data to the file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer | TypedArray | DataView} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   signal?: AbortSignal;\n *   flush?: boolean;\n *   } | string} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction writeFile(path\x2C data\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C {\n    encoding: 'utf8'\x2C\n    mode: 0o666\x2C\n    flag: 'w'\x2C\n    flush: false\x2C\n  });\n  const flag = options.flag || 'w';\n  const flush = options.flush ?? false;\n\n  validateBoolean(flush\x2C 'options.flush');\n\n  if (!isArrayBufferView(data)) {\n    validateStringAfterArrayBufferView(data\x2C 'data');\n    data = Buffer.from(data\x2C options.encoding || 'utf8');\n  }\n\n  if (isFd(path)) {\n    const isUserFd = true;\n    const signal = options.signal;\n    writeAll(path\x2C isUserFd\x2C data\x2C 0\x2C data.byteLength\x2C signal\x2C flush\x2C callback);\n    return;\n  }\n\n  if (checkAborted(options.signal\x2C callback))\n    return;\n\n  fs.open(path\x2C flag\x2C options.mode\x2C (openErr\x2C fd) => {\n    if (openErr) {\n      callback(openErr);\n    } else {\n      const isUserFd = false;\n      const signal = options.signal;\n      writeAll(fd\x2C isUserFd\x2C data\x2C 0\x2C data.byteLength\x2C signal\x2C flush\x2C callback);\n    }\n  });\n}\n\n/**\n * Synchronously writes data to the file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer | TypedArray | DataView} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   flush?: boolean;\n *   } | string} [options]\n * @returns {void}\n */\nfunction writeFileSync(path\x2C data\x2C options) {\n  options = getOptions(options\x2C {\n    encoding: 'utf8'\x2C\n    mode: 0o666\x2C\n    flag: 'w'\x2C\n    flush: false\x2C\n  });\n\n  const flush = options.flush ?? false;\n\n  validateBoolean(flush\x2C 'options.flush');\n\n  const flag = options.flag || 'w';\n\n  // C++ fast path for string data and UTF8 encoding\n  if (typeof data === 'string' && (options.encoding === 'utf8' || options.encoding === 'utf-8')) {\n    if (!isInt32(path)) {\n      path = pathModule.toNamespacedPath(getValidatedPath(path));\n    }\n\n    return binding.writeFileUtf8(\n      path\x2C data\x2C\n      stringToFlags(flag)\x2C\n      parseFileMode(options.mode\x2C 'mode'\x2C 0o666)\x2C\n    );\n  }\n\n  if (!isArrayBufferView(data)) {\n    validateStringAfterArrayBufferView(data\x2C 'data');\n    data = Buffer.from(data\x2C options.encoding || 'utf8');\n  }\n\n  const isUserFd = isFd(path); // File descriptor ownership\n  const fd = isUserFd ? path : fs.openSync(path\x2C flag\x2C options.mode);\n\n  let offset = 0;\n  let length = data.byteLength;\n  try {\n    while (length > 0) {\n      const written = fs.writeSync(fd\x2C data\x2C offset\x2C length);\n      offset += written;\n      length -= written;\n    }\n\n    if (flush) {\n      fs.fsyncSync(fd);\n    }\n  } finally {\n    if (!isUserFd) fs.closeSync(fd);\n  }\n}\n\n/**\n * Asynchronously appends data to a file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   } | string} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction appendFile(path\x2C data\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  // Force append behavior when using a supplied file descriptor\n  if (!options.flag || isFd(path))\n    options.flag = 'a';\n\n  fs.writeFile(path\x2C data\x2C options\x2C callback);\n}\n\n/**\n * Synchronously appends data to a file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   } | string} [options]\n * @returns {void}\n */\nfunction appendFileSync(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  // Force append behavior when using a supplied file descriptor\n  if (!options.flag || isFd(path))\n    options.flag = 'a';\n\n  fs.writeFileSync(path\x2C data\x2C options);\n}\n\n/**\n * Watches for the changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {string | {\n *   persistent?: boolean;\n *   recursive?: boolean;\n *   encoding?: string;\n *   signal?: AbortSignal;\n *   }} [options]\n * @param {(\n *   eventType?: string\x2C\n *   filename?: string | Buffer\n *   ) => any} [listener]\n * @returns {watchers.FSWatcher}\n */\nfunction watch(filename\x2C options\x2C listener) {\n  if (typeof options === 'function') {\n    listener = options;\n  }\n  options = getOptions(options);\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  if (options.persistent === undefined) options.persistent = true;\n  if (options.recursive === undefined) options.recursive = false;\n\n  let watcher;\n  const watchers = require('internal/fs/watchers');\n  const path = possiblyTransformPath(filename);\n  // TODO(anonrig): Remove non-native watcher when/if libuv supports recursive.\n  // As of November 2022\x2C libuv does not support recursive file watch on all platforms\x2C\n  // e.g. Linux due to the limitations of inotify.\n  if (options.recursive && !isOSX && !isWindows) {\n    const nonNativeWatcher = require('internal/fs/recursive_watch');\n    watcher = new nonNativeWatcher.FSWatcher(options);\n    watcher[watchers.kFSWatchStart](path);\n  } else {\n    watcher = new watchers.FSWatcher();\n    watcher[watchers.kFSWatchStart](path\x2C\n                                    options.persistent\x2C\n                                    options.recursive\x2C\n                                    options.encoding);\n  }\n\n  if (listener) {\n    watcher.addListener('change'\x2C listener);\n  }\n  if (options.signal) {\n    if (options.signal.aborted) {\n      process.nextTick(() => watcher.close());\n    } else {\n      const listener = () => watcher.close();\n      kResistStopPropagation ??= require('internal/event_target').kResistStopPropagation;\n      options.signal.addEventListener('abort'\x2C listener\x2C { __proto__: null\x2C [kResistStopPropagation]: true });\n      watcher.once('close'\x2C () => {\n        options.signal.removeEventListener('abort'\x2C listener);\n      });\n    }\n  }\n\n  return watcher;\n}\n\n\nconst statWatchers = new SafeMap();\n\n/**\n * Watches for changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {{\n *   bigint?: boolean;\n *   persistent?: boolean;\n *   interval?: number;\n *   }} [options]\n * @param {(\n *   current?: Stats\x2C\n *   previous?: Stats\n *   ) => any} listener\n * @returns {watchers.StatWatcher}\n */\nfunction watchFile(filename\x2C options\x2C listener) {\n  filename = getValidatedPath(filename);\n  filename = pathModule.resolve(filename);\n  let stat;\n\n  if (options === null || typeof options !== 'object') {\n    listener = options;\n    options = null;\n  }\n\n  options = {\n    // Poll interval in milliseconds. 5007 is what libev used to use. It's\n    // a little on the slow side but let's stick with it for now to keep\n    // behavioral changes to a minimum.\n    interval: 5007\x2C\n    persistent: true\x2C\n    ...options\x2C\n  };\n\n  validateFunction(listener\x2C 'listener');\n\n  stat = statWatchers.get(filename);\n  const watchers = require('internal/fs/watchers');\n  if (stat === undefined) {\n    stat = new watchers.StatWatcher(options.bigint);\n    stat[watchers.kFSStatWatcherStart](filename\x2C\n                                       options.persistent\x2C options.interval);\n    statWatchers.set(filename\x2C stat);\n  } else {\n    stat[watchers.kFSStatWatcherAddOrCleanRef]('add');\n  }\n\n  stat.addListener('change'\x2C listener);\n  return stat;\n}\n\n/**\n * Stops watching for changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {() => any} [listener]\n * @returns {void}\n */\nfunction unwatchFile(filename\x2C listener) {\n  filename = getValidatedPath(filename);\n  filename = pathModule.resolve(filename);\n  const stat = statWatchers.get(filename);\n\n  if (stat === undefined) return;\n  const watchers = require('internal/fs/watchers');\n  if (typeof listener === 'function') {\n    const beforeListenerCount = stat.listenerCount('change');\n    stat.removeListener('change'\x2C listener);\n    if (stat.listenerCount('change') < beforeListenerCount)\n      stat[watchers.kFSStatWatcherAddOrCleanRef]('clean');\n  } else {\n    stat.removeAllListeners('change');\n    stat[watchers.kFSStatWatcherAddOrCleanRef]('cleanAll');\n  }\n\n  if (stat.listenerCount('change') === 0) {\n    stat.stop();\n    statWatchers.delete(filename);\n  }\n}\n\n\nlet splitRoot;\nif (isWindows) {\n  // Regex to find the device root on Windows (e.g. 'c:\\\\')\x2C including trailing\n  // slash.\n  const splitRootRe = /^(?:[a-zA-Z]:|[\\\\/]{2}[^\\\\/]+[\\\\/][^\\\\/]+)?[\\\\/]*/;\n  splitRoot = function splitRoot(str) {\n    return SideEffectFreeRegExpPrototypeExec(splitRootRe\x2C str)[0];\n  };\n} else {\n  splitRoot = function splitRoot(str) {\n    for (let i = 0; i < str.length; ++i) {\n      if (StringPrototypeCharCodeAt(str\x2C i) !== CHAR_FORWARD_SLASH)\n        return StringPrototypeSlice(str\x2C 0\x2C i);\n    }\n    return str;\n  };\n}\n\nfunction encodeRealpathResult(result\x2C options) {\n  if (!options || !options.encoding || options.encoding === 'utf8')\n    return result;\n  const asBuffer = Buffer.from(result);\n  if (options.encoding === 'buffer') {\n    return asBuffer;\n  }\n  return asBuffer.toString(options.encoding);\n}\n\n// Finds the next portion of a (partial) path\x2C up to the next path delimiter\nlet nextPart;\nif (isWindows) {\n  nextPart = function nextPart(p\x2C i) {\n    for (; i < p.length; ++i) {\n      const ch = StringPrototypeCharCodeAt(p\x2C i);\n\n      // Check for a separator character\n      if (ch === CHAR_BACKWARD_SLASH || ch === CHAR_FORWARD_SLASH)\n        return i;\n    }\n    return -1;\n  };\n} else {\n  nextPart = function nextPart(p\x2C i) {\n    return StringPrototypeIndexOf(p\x2C '/'\x2C i);\n  };\n}\n\n/**\n * Returns the resolved pathname.\n * @param {string | Buffer | URL} p\n * @param {string | { encoding?: string | null; }} [options]\n * @returns {string | Buffer}\n */\nfunction realpathSync(p\x2C options) {\n  options = getOptions(options);\n  p = toPathIfFileURL(p);\n  if (typeof p !== 'string') {\n    p += '';\n  }\n  validatePath(p);\n  p = pathModule.resolve(p);\n\n  const cache = options[realpathCacheKey];\n  const maybeCachedResult = cache?.get(p);\n  if (maybeCachedResult) {\n    return maybeCachedResult;\n  }\n\n  const seenLinks = new SafeMap();\n  const knownHard = new SafeSet();\n  const original = p;\n\n  // Current character position in p\n  let pos;\n  // The partial path so far\x2C including a trailing slash if any\n  let current;\n  // The partial path without a trailing slash (except when pointing at a root)\n  let base;\n  // The partial path scanned in the previous round\x2C with slash\n  let previous;\n\n  // Skip over roots\n  current = base = splitRoot(p);\n  pos = current.length;\n\n  // On windows\x2C check that the root exists. On unix there is no need.\n  if (isWindows) {\n    const out = binding.lstat(pathModule.toNamespacedPath(base)\x2C false\x2C undefined\x2C true /* throwIfNoEntry */);\n    if (out === undefined) {\n      return;\n    }\n    knownHard.add(base);\n  }\n\n  // Walk down the path\x2C swapping out linked path parts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    const result = nextPart(p\x2C pos);\n    previous = current;\n    if (result === -1) {\n      const last = StringPrototypeSlice(p\x2C pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += StringPrototypeSlice(p\x2C pos\x2C result + 1);\n      base = previous + StringPrototypeSlice(p\x2C pos\x2C result);\n      pos = result + 1;\n    }\n\n    // Continue if not a symlink\x2C break if a pipe/socket\n    if (knownHard.has(base) || cache?.get(base) === base) {\n      if (isFileType(statValues\x2C S_IFIFO) ||\n          isFileType(statValues\x2C S_IFSOCK)) {\n        break;\n      }\n      continue;\n    }\n\n    let resolvedLink;\n    const maybeCachedResolved = cache?.get(base);\n    if (maybeCachedResolved) {\n      resolvedLink = maybeCachedResolved;\n    } else {\n      // Use stats array directly to avoid creating an fs.Stats instance just\n      // for our internal use.\n\n      const baseLong = pathModule.toNamespacedPath(base);\n      const stats = binding.lstat(baseLong\x2C true\x2C undefined\x2C true /* throwIfNoEntry */);\n      if (stats === undefined) {\n        return;\n      }\n\n      if (!isFileType(stats\x2C S_IFLNK)) {\n        knownHard.add(base);\n        cache?.set(base\x2C base);\n        continue;\n      }\n\n      // Read the link if it wasn't read before\n      // dev/ino always return 0 on windows\x2C so skip the check.\n      let linkTarget = null;\n      let id;\n      if (!isWindows) {\n        const dev = BigIntPrototypeToString(stats[0]\x2C 32);\n        const ino = BigIntPrototypeToString(stats[7]\x2C 32);\n        id = `${dev}:${ino}`;\n        if (seenLinks.has(id)) {\n          linkTarget = seenLinks.get(id);\n        }\n      }\n      if (linkTarget === null) {\n        binding.stat(baseLong\x2C false\x2C undefined\x2C true);\n        linkTarget = binding.readlink(baseLong\x2C undefined);\n      }\n      resolvedLink = pathModule.resolve(previous\x2C linkTarget);\n\n      cache?.set(base\x2C resolvedLink);\n      if (!isWindows) seenLinks.set(id\x2C linkTarget);\n    }\n\n    // Resolve the link\x2C then start over\n    p = pathModule.resolve(resolvedLink\x2C StringPrototypeSlice(p\x2C pos));\n\n    // Skip over roots\n    current = base = splitRoot(p);\n    pos = current.length;\n\n    // On windows\x2C check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard.has(base)) {\n      const out = binding.lstat(pathModule.toNamespacedPath(base)\x2C false\x2C undefined\x2C true /* throwIfNoEntry */);\n      if (out === undefined) {\n        return;\n      }\n      knownHard.add(base);\n    }\n  }\n\n  cache?.set(original\x2C p);\n  return encodeRealpathResult(p\x2C options);\n}\n\n/**\n * Returns the resolved pathname.\n * @param {string | Buffer | URL} path\n * @param {string | { encoding?: string; }} [options]\n * @returns {string | Buffer}\n */\nrealpathSync.native = (path\x2C options) => {\n  options = getOptions(options);\n  path = getValidatedPath(path);\n  return binding.realpath(\n    pathModule.toNamespacedPath(path)\x2C\n    options.encoding\x2C\n  );\n};\n\n/**\n * Asynchronously computes the canonical pathname by\n * resolving `.`\x2C `..` and symbolic links.\n * @param {string | Buffer | URL} p\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   resolvedPath?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction realpath(p\x2C options\x2C callback) {\n  callback = typeof options === 'function' ? options : maybeCallback(callback);\n  options = getOptions(options);\n  p = toPathIfFileURL(p);\n\n  if (typeof p !== 'string') {\n    p += '';\n  }\n  validatePath(p);\n  p = pathModule.resolve(p);\n\n  const seenLinks = new SafeMap();\n  const knownHard = new SafeSet();\n\n  // Current character position in p\n  let pos;\n  // The partial path so far\x2C including a trailing slash if any\n  let current;\n  // The partial path without a trailing slash (except when pointing at a root)\n  let base;\n  // The partial path scanned in the previous round\x2C with slash\n  let previous;\n\n  current = base = splitRoot(p);\n  pos = current.length;\n\n  // On windows\x2C check that the root exists. On unix there is no need.\n  if (isWindows && !knownHard.has(base)) {\n    fs.lstat(base\x2C (err\x2C stats) => {\n      if (err) return callback(err);\n      knownHard.add(base);\n      LOOP();\n    });\n  } else {\n    process.nextTick(LOOP);\n  }\n\n  // Walk down the path\x2C swapping out linked path parts for their real\n  // values\n  function LOOP() {\n    // Stop if scanned past end of path\n    if (pos >= p.length) {\n      return callback(null\x2C encodeRealpathResult(p\x2C options));\n    }\n\n    // find the next part\n    const result = nextPart(p\x2C pos);\n    previous = current;\n    if (result === -1) {\n      const last = StringPrototypeSlice(p\x2C pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += StringPrototypeSlice(p\x2C pos\x2C result + 1);\n      base = previous + StringPrototypeSlice(p\x2C pos\x2C result);\n      pos = result + 1;\n    }\n\n    // Continue if not a symlink\x2C break if a pipe/socket\n    if (knownHard.has(base)) {\n      if (isFileType(statValues\x2C S_IFIFO) ||\n          isFileType(statValues\x2C S_IFSOCK)) {\n        return callback(null\x2C encodeRealpathResult(p\x2C options));\n      }\n      return process.nextTick(LOOP);\n    }\n\n    return fs.lstat(base\x2C { bigint: true }\x2C gotStat);\n  }\n\n  function gotStat(err\x2C stats) {\n    if (err) return callback(err);\n\n    // If not a symlink\x2C skip to the next path part\n    if (!stats.isSymbolicLink()) {\n      knownHard.add(base);\n      return process.nextTick(LOOP);\n    }\n\n    // Stat & read the link if not read before.\n    // Call `gotTarget()` as soon as the link target is known.\n    // `dev`/`ino` always return 0 on windows\x2C so skip the check.\n    let id;\n    if (!isWindows) {\n      const dev = BigIntPrototypeToString(stats.dev\x2C 32);\n      const ino = BigIntPrototypeToString(stats.ino\x2C 32);\n      id = `${dev}:${ino}`;\n      if (seenLinks.has(id)) {\n        return gotTarget(null\x2C seenLinks.get(id));\n      }\n    }\n    fs.stat(base\x2C (err) => {\n      if (err) return callback(err);\n\n      fs.readlink(base\x2C (err\x2C target) => {\n        if (!isWindows) seenLinks.set(id\x2C target);\n        gotTarget(err\x2C target);\n      });\n    });\n  }\n\n  function gotTarget(err\x2C target) {\n    if (err) return callback(err);\n\n    gotResolvedLink(pathModule.resolve(previous\x2C target));\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // Resolve the link\x2C then start over\n    p = pathModule.resolve(resolvedLink\x2C StringPrototypeSlice(p\x2C pos));\n    current = base = splitRoot(p);\n    pos = current.length;\n\n    // On windows\x2C check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard.has(base)) {\n      fs.lstat(base\x2C (err) => {\n        if (err) return callback(err);\n        knownHard.add(base);\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n}\n\n/**\n * Asynchronously computes the canonical pathname by\n * resolving `.`\x2C `..` and symbolic links.\n * @param {string | Buffer | URL} path\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   resolvedPath?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nrealpath.native = (path\x2C options\x2C callback) => {\n  callback = makeCallback(callback || options);\n  options = getOptions(options);\n  path = getValidatedPath(path);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.realpath(pathModule.toNamespacedPath(path)\x2C options.encoding\x2C req);\n};\n\n/**\n * Creates a unique temporary directory.\n * @param {string | Buffer | URL} prefix\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   directory?: string\n *   ) => any} callback\n * @returns {void}\n */\nfunction mkdtemp(prefix\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options);\n\n  prefix = getValidatedPath(prefix\x2C 'prefix');\n  warnOnNonPortableTemplate(prefix);\n\n  let path;\n  if (typeof prefix === 'string') {\n    path = `${prefix}XXXXXX`;\n  } else {\n    path = Buffer.concat([prefix\x2C Buffer.from('XXXXXX')]);\n  }\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.mkdtemp(path\x2C options.encoding\x2C req);\n}\n\n/**\n * Synchronously creates a unique temporary directory.\n * @param {string | Buffer | URL} prefix\n * @param {string | { encoding?: string; }} [options]\n * @returns {string}\n */\nfunction mkdtempSync(prefix\x2C options) {\n  options = getOptions(options);\n\n  prefix = getValidatedPath(prefix\x2C 'prefix');\n  warnOnNonPortableTemplate(prefix);\n\n  let path;\n  if (typeof prefix === 'string') {\n    path = `${prefix}XXXXXX`;\n  } else {\n    path = Buffer.concat([prefix\x2C Buffer.from('XXXXXX')]);\n  }\n\n  return binding.mkdtemp(path\x2C options.encoding);\n}\n\n/**\n * Asynchronously copies `src` to `dest`. By\n * default\x2C `dest` is overwritten if it already exists.\n * @param {string | Buffer | URL} src\n * @param {string | Buffer | URL} dest\n * @param {number} [mode]\n * @param {() => any} callback\n * @returns {void}\n */\nfunction copyFile(src\x2C dest\x2C mode\x2C callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = 0;\n  }\n\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n\n  src = pathModule.toNamespacedPath(src);\n  dest = pathModule.toNamespacedPath(dest);\n  mode = getValidMode(mode\x2C 'copyFile');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.copyFile(src\x2C dest\x2C mode\x2C req);\n}\n\n/**\n * Synchronously copies `src` to `dest`. By\n * default\x2C `dest` is overwritten if it already exists.\n * @param {string | Buffer | URL} src\n * @param {string | Buffer | URL} dest\n * @param {number} [mode]\n * @returns {void}\n */\nfunction copyFileSync(src\x2C dest\x2C mode) {\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n\n  binding.copyFile(\n    pathModule.toNamespacedPath(src)\x2C\n    pathModule.toNamespacedPath(dest)\x2C\n    getValidMode(mode\x2C 'copyFile')\x2C\n  );\n}\n\n/**\n * Asynchronously copies `src` to `dest`. `src` can be a file\x2C directory\x2C or\n * symlink. The contents of directories will be copied recursively.\n * @param {string | URL} src\n * @param {string | URL} dest\n * @param {object} [options]\n * @param {() => any} callback\n * @returns {void}\n */\nfunction cp(src\x2C dest\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  callback = makeCallback(callback);\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\n  lazyLoadCp();\n  cpFn(src\x2C dest\x2C options\x2C callback);\n}\n\n/**\n * Synchronously copies `src` to `dest`. `src` can be a file\x2C directory\x2C or\n * symlink. The contents of directories will be copied recursively.\n * @param {string | URL} src\n * @param {string | URL} dest\n * @param {object} [options]\n * @returns {void}\n */\nfunction cpSync(src\x2C dest\x2C options) {\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\n  lazyLoadCp();\n  cpSyncFn(src\x2C dest\x2C options);\n}\n\nfunction lazyLoadStreams() {\n  if (!ReadStream) {\n    ({ ReadStream\x2C WriteStream } = require('internal/fs/streams'));\n    FileReadStream = ReadStream;\n    FileWriteStream = WriteStream;\n  }\n}\n\n/**\n * Creates a readable stream with a default `highWaterMark`\n * of 64 KiB.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   flags?: string;\n *   encoding?: string;\n *   fd?: number | FileHandle;\n *   mode?: number;\n *   autoClose?: boolean;\n *   emitClose?: boolean;\n *   start: number;\n *   end?: number;\n *   highWaterMark?: number;\n *   fs?: object | null;\n *   }} [options]\n * @returns {ReadStream}\n */\nfunction createReadStream(path\x2C options) {\n  lazyLoadStreams();\n  return new ReadStream(path\x2C options);\n}\n\n/**\n * Creates a write stream.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   flags?: string;\n *   encoding?: string;\n *   fd?: number | FileHandle;\n *   mode?: number;\n *   autoClose?: boolean;\n *   emitClose?: boolean;\n *   start: number;\n *   fs?: object | null;\n *   flush?: boolean;\n *   }} [options]\n * @returns {WriteStream}\n */\nfunction createWriteStream(path\x2C options) {\n  lazyLoadStreams();\n  return new WriteStream(path\x2C options);\n}\n\nmodule.exports = fs = {\n  appendFile\x2C\n  appendFileSync\x2C\n  access\x2C\n  accessSync\x2C\n  chown\x2C\n  chownSync\x2C\n  chmod\x2C\n  chmodSync\x2C\n  close\x2C\n  closeSync\x2C\n  copyFile\x2C\n  copyFileSync\x2C\n  cp\x2C\n  cpSync\x2C\n  createReadStream\x2C\n  createWriteStream\x2C\n  exists\x2C\n  existsSync\x2C\n  fchown\x2C\n  fchownSync\x2C\n  fchmod\x2C\n  fchmodSync\x2C\n  fdatasync\x2C\n  fdatasyncSync\x2C\n  fstat\x2C\n  fstatSync\x2C\n  fsync\x2C\n  fsyncSync\x2C\n  ftruncate\x2C\n  ftruncateSync\x2C\n  futimes\x2C\n  futimesSync\x2C\n  lchown\x2C\n  lchownSync\x2C\n  lchmod: constants.O_SYMLINK !== undefined ? lchmod : undefined\x2C\n  lchmodSync: constants.O_SYMLINK !== undefined ? lchmodSync : undefined\x2C\n  link\x2C\n  linkSync\x2C\n  lstat\x2C\n  lstatSync\x2C\n  lutimes\x2C\n  lutimesSync\x2C\n  mkdir\x2C\n  mkdirSync\x2C\n  mkdtemp\x2C\n  mkdtempSync\x2C\n  open\x2C\n  openSync\x2C\n  openAsBlob\x2C\n  readdir\x2C\n  readdirSync\x2C\n  read\x2C\n  readSync\x2C\n  readv\x2C\n  readvSync\x2C\n  readFile\x2C\n  readFileSync\x2C\n  readlink\x2C\n  readlinkSync\x2C\n  realpath\x2C\n  realpathSync\x2C\n  rename\x2C\n  renameSync\x2C\n  rm\x2C\n  rmSync\x2C\n  rmdir\x2C\n  rmdirSync\x2C\n  stat\x2C\n  statfs\x2C\n  statSync\x2C\n  statfsSync\x2C\n  symlink\x2C\n  symlinkSync\x2C\n  truncate\x2C\n  truncateSync\x2C\n  unwatchFile\x2C\n  unlink\x2C\n  unlinkSync\x2C\n  utimes\x2C\n  utimesSync\x2C\n  watch\x2C\n  watchFile\x2C\n  writeFile\x2C\n  writeFileSync\x2C\n  write\x2C\n  writeSync\x2C\n  writev\x2C\n  writevSync\x2C\n  Dirent\x2C\n  Stats\x2C\n\n  get ReadStream() {\n    lazyLoadStreams();\n    return ReadStream;\n  }\x2C\n\n  set ReadStream(val) {\n    ReadStream = val;\n  }\x2C\n\n  get WriteStream() {\n    lazyLoadStreams();\n    return WriteStream;\n  }\x2C\n\n  set WriteStream(val) {\n    WriteStream = val;\n  }\x2C\n\n  // Legacy names... these have to be separate because of how graceful-fs\n  // (and possibly other) modules monkey patch the values.\n  get FileReadStream() {\n    lazyLoadStreams();\n    return FileReadStream;\n  }\x2C\n\n  set FileReadStream(val) {\n    FileReadStream = val;\n  }\x2C\n\n  get FileWriteStream() {\n    lazyLoadStreams();\n    return FileWriteStream;\n  }\x2C\n\n  set FileWriteStream(val) {\n    FileWriteStream = val;\n  }\x2C\n\n  // For tests\n  _toUnixTimestamp: toUnixTimestamp\x2C\n};\n\ndefineLazyProperties(\n  fs\x2C\n  'internal/fs/dir'\x2C\n  ['Dir'\x2C 'opendir'\x2C 'opendirSync']\x2C\n);\n\nObjectDefineProperties(fs\x2C {\n  F_OK: { __proto__: null\x2C enumerable: true\x2C value: F_OK || 0 }\x2C\n  R_OK: { __proto__: null\x2C enumerable: true\x2C value: R_OK || 0 }\x2C\n  W_OK: { __proto__: null\x2C enumerable: true\x2C value: W_OK || 0 }\x2C\n  X_OK: { __proto__: null\x2C enumerable: true\x2C value: X_OK || 0 }\x2C\n  constants: {\n    __proto__: null\x2C\n    configurable: false\x2C\n    enumerable: true\x2C\n    value: constants\x2C\n  }\x2C\n  promises: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() {\n      promises ??= require('internal/fs/promises').exports;\n      return promises;\n    }\x2C\n  }\x2C\n});\n
code-source-info,0x31e6f6b6568e,55,69586,73384,C0O69603C6O69613C12O69636C18O69640C24O69662C28O69695C38O69710C44O69710C48O69729C54O69744C60O69744C67O69773C69O69781C71O69780C75O69828C79O69833C85O69835C94O69845C96O69874C98O69899C99O69925C105O69925C111O69960C117O69960C123O69994C126O70041C128O70116C130O70211C132O70287C134O70321C140O70338C146O70368C151O70450C157O70483C163O70491C171O70497C175O70508C181O70508C197O70491C204O70582C206O70613C207O70620C208O70641C214O70641C219O70784C223O70780C228O70839C234O70839C240O70861C243O70885C245O70896C250O70925C256O70925C263O70961C265O70972C272O70984C274O71000C278O71022C285O71049C287O71060C293O71096C304O71060C316O71108C318O71126C331O71126C336O71124C340O71170C342O71183C346O71270C352O71270C366O71288C372O71290C384O71300C389O71318C395O71333C401O71345C405O71322C418O71378C424O71390C428O71367C435O71411C437O71432C439O71457C441O71503C448O71508C454O71510C463O71525C465O71558C472O71740C478O71751C484O71751C490O71795C496O71803C514O71803C520O71870C522O71905C523O71912C524O71928C530O71951C534O71933C541O71981C547O71981C552O72000C559O72005C565O72007C574O72032C576O72186C578O72202C581O72212C587O72250C594O72279C603O72250C610O72309C618O72338C627O72309C634O72356C648O72371C654O72400C660O72400C667O72444C673O72444C679O72477C683O72512C689O72520C707O72520C712O72568C718O72589C727O72589C734O72634C740O72660C746O72660C753O72698C760O72703C766O72705C775O72736C781O72762C787O72762C793O72835C799O72850C807O72872C811O72872C818O72850C826O72931C832O72948C838O72980C843O73066C849O73094C855O73094C862O73125C868O73133C876O73139C880O73150C886O73150C902O73133C908O73226C910O73259C911O73266C912O73291C918O73291C923O70769C931O73315C938O73320C944O73322C953O73342C957O73349C962O73382,,
tick,0x7ff8091ad6c7,62543,0,0x0,3,0x10c9f09d0,0x31e6f6b652e1,0x31e6f6b64bdf,0x31e6f6b62053,0x31e6f6b6075c,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
tick,0x7ff809303b02,62560,0,0x0,3,0x10c9f09d0,0x31e6f6b652e1,0x31e6f6b64bdf,0x31e6f6b62053,0x31e6f6b6075c,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
tick,0x7ff809251043,62569,0,0x0,3,0x10c9f09d0,0x31e6f6b652e1,0x31e6f6b64bdf,0x31e6f6b62053,0x31e6f6b6075c,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
tick,0x7ff8091ca4f7,62577,0,0x0,3,0x10c9f09d0,0x31e6f6b652e1,0x31e6f6b64bdf,0x31e6f6b62053,0x31e6f6b6075c,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,62605,0x31e6f6b6c44e,135,getOptions node:internal/fs/utils:323:20,0x31e647c730e8,~
script-source,60,node:internal/fs/utils,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  BigInt\x2C\n  Date\x2C\n  DateNow\x2C\n  DatePrototypeGetTime\x2C\n  ErrorCaptureStackTrace\x2C\n  FunctionPrototypeCall\x2C\n  Number\x2C\n  NumberIsFinite\x2C\n  MathMin\x2C\n  MathRound\x2C\n  ObjectIs\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n  ReflectOwnKeys\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIncludes\x2C\n  Symbol\x2C\n  TypedArrayPrototypeAt\x2C\n  TypedArrayPrototypeIncludes\x2C\n  uncurryThis\x2C\n} = primordials;\n\nconst permission = require('internal/process/permission');\n\nconst { Buffer } = require('buffer');\nconst {\n  codes: {\n    ERR_FS_EISDIR\x2C\n    ERR_FS_INVALID_SYMLINK_TYPE\x2C\n    ERR_INCOMPATIBLE_OPTION_PAIR\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\x2C\n  }\x2C\n  hideStackFrames\x2C\n  uvException\x2C\n} = require('internal/errors');\nconst {\n  isArrayBufferView\x2C\n  isBigInt64Array\x2C\n  isDate\x2C\n  isUint8Array\x2C\n} = require('internal/util/types');\nconst {\n  kEmptyObject\x2C\n  once\x2C\n} = require('internal/util');\nconst { toPathIfFileURL } = require('internal/url');\nconst {\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateInteger\x2C\n  validateObject\x2C\n  validateUint32\x2C\n} = require('internal/validators');\nconst pathModule = require('path');\nconst kType = Symbol('type');\nconst kStats = Symbol('stats');\nconst assert = require('internal/assert');\n\nconst {\n  fs: {\n    F_OK = 0\x2C\n    W_OK = 0\x2C\n    R_OK = 0\x2C\n    X_OK = 0\x2C\n    COPYFILE_EXCL\x2C\n    COPYFILE_FICLONE\x2C\n    COPYFILE_FICLONE_FORCE\x2C\n    O_APPEND\x2C\n    O_CREAT\x2C\n    O_EXCL\x2C\n    O_RDONLY\x2C\n    O_RDWR\x2C\n    O_SYNC\x2C\n    O_TRUNC\x2C\n    O_WRONLY\x2C\n    S_IFBLK\x2C\n    S_IFCHR\x2C\n    S_IFDIR\x2C\n    S_IFIFO\x2C\n    S_IFLNK\x2C\n    S_IFMT\x2C\n    S_IFREG\x2C\n    S_IFSOCK\x2C\n    UV_FS_SYMLINK_DIR\x2C\n    UV_FS_SYMLINK_JUNCTION\x2C\n    UV_DIRENT_UNKNOWN\x2C\n    UV_DIRENT_FILE\x2C\n    UV_DIRENT_DIR\x2C\n    UV_DIRENT_LINK\x2C\n    UV_DIRENT_FIFO\x2C\n    UV_DIRENT_SOCKET\x2C\n    UV_DIRENT_CHAR\x2C\n    UV_DIRENT_BLOCK\x2C\n  }\x2C\n  os: {\n    errno: {\n      EISDIR\x2C\n    }\x2C\n  }\x2C\n} = internalBinding('constants');\n\n// The access modes can be any of F_OK\x2C R_OK\x2C W_OK or X_OK. Some might not be\n// available on specific systems. They can be used in combination as well\n// (F_OK | R_OK | W_OK | X_OK).\nconst kMinimumAccessMode = MathMin(F_OK\x2C W_OK\x2C R_OK\x2C X_OK);\nconst kMaximumAccessMode = F_OK | W_OK | R_OK | X_OK;\n\nconst kDefaultCopyMode = 0;\n// The copy modes can be any of COPYFILE_EXCL\x2C COPYFILE_FICLONE or\n// COPYFILE_FICLONE_FORCE. They can be used in combination as well\n// (COPYFILE_EXCL | COPYFILE_FICLONE | COPYFILE_FICLONE_FORCE).\nconst kMinimumCopyMode = MathMin(\n  kDefaultCopyMode\x2C\n  COPYFILE_EXCL\x2C\n  COPYFILE_FICLONE\x2C\n  COPYFILE_FICLONE_FORCE\x2C\n);\nconst kMaximumCopyMode = COPYFILE_EXCL |\n                         COPYFILE_FICLONE |\n                         COPYFILE_FICLONE_FORCE;\n\n// Most platforms don't allow reads or writes >= 2 GiB.\n// See https://github.com/libuv/libuv/pull/1501.\nconst kIoMaxLength = 2 ** 31 - 1;\n\n// Use 64kb in case the file type is not a regular file and thus do not know the\n// actual file size. Increasing the value further results in more frequent over\n// allocation for small files and consumes CPU time and memory that should be\n// used else wise.\n// Use up to 512kb per read otherwise to partition reading big files to prevent\n// blocking other threads in case the available threads are all in use.\nconst kReadFileUnknownBufferLength = 64 * 1024;\nconst kReadFileBufferLength = 512 * 1024;\n\nconst kWriteFileMaxChunkSize = 512 * 1024;\n\nconst kMaxUserId = 2 ** 32 - 1;\n\nconst isWindows = process.platform === 'win32';\n\nlet fs;\nfunction lazyLoadFs() {\n  if (!fs) {\n    fs = require('fs');\n  }\n  return fs;\n}\n\nfunction assertEncoding(encoding) {\n  if (encoding && !Buffer.isEncoding(encoding)) {\n    const reason = 'is invalid encoding';\n    throw new ERR_INVALID_ARG_VALUE(encoding\x2C 'encoding'\x2C reason);\n  }\n}\n\nclass Dirent {\n  constructor(name\x2C type\x2C path) {\n    this.name = name;\n    this.path = path;\n    this[kType] = type;\n  }\n\n  isDirectory() {\n    return this[kType] === UV_DIRENT_DIR;\n  }\n\n  isFile() {\n    return this[kType] === UV_DIRENT_FILE;\n  }\n\n  isBlockDevice() {\n    return this[kType] === UV_DIRENT_BLOCK;\n  }\n\n  isCharacterDevice() {\n    return this[kType] === UV_DIRENT_CHAR;\n  }\n\n  isSymbolicLink() {\n    return this[kType] === UV_DIRENT_LINK;\n  }\n\n  isFIFO() {\n    return this[kType] === UV_DIRENT_FIFO;\n  }\n\n  isSocket() {\n    return this[kType] === UV_DIRENT_SOCKET;\n  }\n}\n\nclass DirentFromStats extends Dirent {\n  constructor(name\x2C stats\x2C path) {\n    super(name\x2C null\x2C path);\n    this[kStats] = stats;\n  }\n}\n\nfor (const name of ReflectOwnKeys(Dirent.prototype)) {\n  if (name === 'constructor') {\n    continue;\n  }\n  DirentFromStats.prototype[name] = function() {\n    return this[kStats][name]();\n  };\n}\n\nfunction copyObject(source) {\n  const target = {};\n  for (const key in source)\n    target[key] = source[key];\n  return target;\n}\n\nconst bufferSep = Buffer.from(pathModule.sep);\n\nfunction join(path\x2C name) {\n  if ((typeof path === 'string' || isUint8Array(path)) &&\n      name === undefined) {\n    return path;\n  }\n\n  if (typeof path === 'string' && isUint8Array(name)) {\n    const pathBuffer = Buffer.from(pathModule.join(path\x2C pathModule.sep));\n    return Buffer.concat([pathBuffer\x2C name]);\n  }\n\n  if (typeof path === 'string' && typeof name === 'string') {\n    return pathModule.join(path\x2C name);\n  }\n\n  if (isUint8Array(path) && isUint8Array(name)) {\n    return Buffer.concat([path\x2C bufferSep\x2C name]);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'path'\x2C ['string'\x2C 'Buffer']\x2C path);\n}\n\nfunction getDirents(path\x2C { 0: names\x2C 1: types }\x2C callback) {\n  let i;\n  if (typeof callback === 'function') {\n    const len = names.length;\n    let toFinish = 0;\n    callback = once(callback);\n    for (i = 0; i < len; i++) {\n      const type = types[i];\n      if (type === UV_DIRENT_UNKNOWN) {\n        const name = names[i];\n        const idx = i;\n        toFinish++;\n        let filepath;\n        try {\n          filepath = join(path\x2C name);\n        } catch (err) {\n          callback(err);\n          return;\n        }\n        lazyLoadFs().lstat(filepath\x2C (err\x2C stats) => {\n          if (err) {\n            callback(err);\n            return;\n          }\n          names[idx] = new DirentFromStats(name\x2C stats\x2C path);\n          if (--toFinish === 0) {\n            callback(null\x2C names);\n          }\n        });\n      } else {\n        names[i] = new Dirent(names[i]\x2C types[i]\x2C path);\n      }\n    }\n    if (toFinish === 0) {\n      callback(null\x2C names);\n    }\n  } else {\n    const len = names.length;\n    for (i = 0; i < len; i++) {\n      names[i] = getDirent(path\x2C names[i]\x2C types[i]);\n    }\n    return names;\n  }\n}\n\nfunction getDirent(path\x2C name\x2C type\x2C callback) {\n  if (typeof callback === 'function') {\n    if (type === UV_DIRENT_UNKNOWN) {\n      let filepath;\n      try {\n        filepath = join(path\x2C name);\n      } catch (err) {\n        callback(err);\n        return;\n      }\n      lazyLoadFs().lstat(filepath\x2C (err\x2C stats) => {\n        if (err) {\n          callback(err);\n          return;\n        }\n        callback(null\x2C new DirentFromStats(name\x2C stats\x2C filepath));\n      });\n    } else {\n      callback(null\x2C new Dirent(name\x2C type\x2C path));\n    }\n  } else if (type === UV_DIRENT_UNKNOWN) {\n    const filepath = join(path\x2C name);\n    const stats = lazyLoadFs().lstatSync(filepath);\n    return new DirentFromStats(name\x2C stats\x2C path);\n  } else {\n    return new Dirent(name\x2C type\x2C path);\n  }\n}\n\nfunction getOptions(options\x2C defaultOptions = kEmptyObject) {\n  if (options == null || typeof options === 'function') {\n    return defaultOptions;\n  }\n\n  if (typeof options === 'string') {\n    defaultOptions = { ...defaultOptions };\n    defaultOptions.encoding = options;\n    options = defaultOptions;\n  } else if (typeof options !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE('options'\x2C ['string'\x2C 'Object']\x2C options);\n  }\n\n  if (options.encoding !== 'buffer')\n    assertEncoding(options.encoding);\n\n  if (options.signal !== undefined) {\n    validateAbortSignal(options.signal\x2C 'options.signal');\n  }\n\n  return options;\n}\n\n/**\n * @param {InternalFSBinding.FSSyncContext} ctx\n */\nfunction handleErrorFromBinding(ctx) {\n  if (ctx.errno !== undefined) {  // libuv error numbers\n    const err = uvException(ctx);\n    ErrorCaptureStackTrace(err\x2C handleErrorFromBinding);\n    throw err;\n  }\n  if (ctx.error !== undefined) {  // Errors created in C++ land.\n    // TODO(joyeecheung): currently\x2C ctx.error are encoding errors\n    // usually caused by memory problems. We need to figure out proper error\n    // code(s) for this.\n    ErrorCaptureStackTrace(ctx.error\x2C handleErrorFromBinding);\n    throw ctx.error;\n  }\n}\n\n// Check if the path contains null types if it is a string nor Uint8Array\x2C\n// otherwise return silently.\nconst nullCheck = hideStackFrames((path\x2C propName\x2C throwError = true) => {\n  const pathIsString = typeof path === 'string';\n  const pathIsUint8Array = isUint8Array(path);\n\n  // We can only perform meaningful checks on strings and Uint8Arrays.\n  if ((!pathIsString && !pathIsUint8Array) ||\n      (pathIsString && !StringPrototypeIncludes(path\x2C '\\u0000')) ||\n      (pathIsUint8Array && !TypedArrayPrototypeIncludes(path\x2C 0))) {\n    return;\n  }\n\n  const err = new ERR_INVALID_ARG_VALUE(\n    propName\x2C\n    path\x2C\n    'must be a string\x2C Uint8Array\x2C or URL without null bytes'\x2C\n  );\n  if (throwError) {\n    throw err;\n  }\n  return err;\n});\n\nfunction preprocessSymlinkDestination(path\x2C type\x2C linkPath) {\n  if (!isWindows) {\n    // No preprocessing is needed on Unix.\n    return path;\n  }\n  path = '' + path;\n  if (type === 'junction') {\n    // Junctions paths need to be absolute and \\\\?\\-prefixed.\n    // A relative target is relative to the link's parent directory.\n    path = pathModule.resolve(linkPath\x2C '..'\x2C path);\n    return pathModule.toNamespacedPath(path);\n  }\n  if (pathModule.isAbsolute(path)) {\n    // If the path is absolute\x2C use the \\\\?\\-prefix to enable long filenames\n    return pathModule.toNamespacedPath(path);\n  }\n  // Windows symlinks don't tolerate forward slashes.\n  return RegExpPrototypeSymbolReplace(/\\//g\x2C path\x2C '\\\\');\n}\n\n// Constructor for file stats.\nfunction StatsBase(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                   ino\x2C size\x2C blocks) {\n  this.dev = dev;\n  this.mode = mode;\n  this.nlink = nlink;\n  this.uid = uid;\n  this.gid = gid;\n  this.rdev = rdev;\n  this.blksize = blksize;\n  this.ino = ino;\n  this.size = size;\n  this.blocks = blocks;\n}\n\nStatsBase.prototype.isDirectory = function() {\n  return this._checkModeProperty(S_IFDIR);\n};\n\nStatsBase.prototype.isFile = function() {\n  return this._checkModeProperty(S_IFREG);\n};\n\nStatsBase.prototype.isBlockDevice = function() {\n  return this._checkModeProperty(S_IFBLK);\n};\n\nStatsBase.prototype.isCharacterDevice = function() {\n  return this._checkModeProperty(S_IFCHR);\n};\n\nStatsBase.prototype.isSymbolicLink = function() {\n  return this._checkModeProperty(S_IFLNK);\n};\n\nStatsBase.prototype.isFIFO = function() {\n  return this._checkModeProperty(S_IFIFO);\n};\n\nStatsBase.prototype.isSocket = function() {\n  return this._checkModeProperty(S_IFSOCK);\n};\n\nconst kNsPerMsBigInt = 10n ** 6n;\nconst kNsPerSecBigInt = 10n ** 9n;\nconst kMsPerSec = 10 ** 3;\nconst kNsPerMs = 10 ** 6;\nfunction msFromTimeSpec(sec\x2C nsec) {\n  return sec * kMsPerSec + nsec / kNsPerMs;\n}\n\nfunction nsFromTimeSpecBigInt(sec\x2C nsec) {\n  return sec * kNsPerSecBigInt + nsec;\n}\n\n// The Date constructor performs Math.floor() on the absolute value\n// of the timestamp: https://tc39.es/ecma262/#sec-timeclip\n// Since there may be a precision loss when the timestamp is\n// converted to a floating point number\x2C we manually round\n// the timestamp here before passing it to Date().\n// Refs: https://github.com/nodejs/node/pull/12607\n// Refs: https://github.com/nodejs/node/pull/43714\nfunction dateFromMs(ms) {\n  // Coercing to number\x2C ms can be bigint\n  return new Date(MathRound(Number(ms)));\n}\n\nfunction BigIntStats(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                     ino\x2C size\x2C blocks\x2C\n                     atimeNs\x2C mtimeNs\x2C ctimeNs\x2C birthtimeNs) {\n  ReflectApply(StatsBase\x2C this\x2C [dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                                 ino\x2C size\x2C blocks]);\n\n  this.atimeMs = atimeNs / kNsPerMsBigInt;\n  this.mtimeMs = mtimeNs / kNsPerMsBigInt;\n  this.ctimeMs = ctimeNs / kNsPerMsBigInt;\n  this.birthtimeMs = birthtimeNs / kNsPerMsBigInt;\n  this.atimeNs = atimeNs;\n  this.mtimeNs = mtimeNs;\n  this.ctimeNs = ctimeNs;\n  this.birthtimeNs = birthtimeNs;\n  this.atime = dateFromMs(this.atimeMs);\n  this.mtime = dateFromMs(this.mtimeMs);\n  this.ctime = dateFromMs(this.ctimeMs);\n  this.birthtime = dateFromMs(this.birthtimeMs);\n}\n\nObjectSetPrototypeOf(BigIntStats.prototype\x2C StatsBase.prototype);\nObjectSetPrototypeOf(BigIntStats\x2C StatsBase);\n\nBigIntStats.prototype._checkModeProperty = function(property) {\n  if (isWindows && (property === S_IFIFO || property === S_IFBLK ||\n    property === S_IFSOCK)) {\n    return false;  // Some types are not available on Windows\n  }\n  return (this.mode & BigInt(S_IFMT)) === BigInt(property);\n};\n\nfunction Stats(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n               ino\x2C size\x2C blocks\x2C\n               atimeMs\x2C mtimeMs\x2C ctimeMs\x2C birthtimeMs) {\n  FunctionPrototypeCall(StatsBase\x2C this\x2C dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C\n                        blksize\x2C ino\x2C size\x2C blocks);\n  this.atimeMs = atimeMs;\n  this.mtimeMs = mtimeMs;\n  this.ctimeMs = ctimeMs;\n  this.birthtimeMs = birthtimeMs;\n  this.atime = dateFromMs(atimeMs);\n  this.mtime = dateFromMs(mtimeMs);\n  this.ctime = dateFromMs(ctimeMs);\n  this.birthtime = dateFromMs(birthtimeMs);\n}\n\nObjectSetPrototypeOf(Stats.prototype\x2C StatsBase.prototype);\nObjectSetPrototypeOf(Stats\x2C StatsBase);\n\n// HACK: Workaround for https://github.com/standard-things/esm/issues/821.\n// TODO(ronag): Remove this as soon as `esm` publishes a fixed version.\nStats.prototype.isFile = StatsBase.prototype.isFile;\n\nStats.prototype._checkModeProperty = function(property) {\n  if (isWindows && (property === S_IFIFO || property === S_IFBLK ||\n    property === S_IFSOCK)) {\n    return false;  // Some types are not available on Windows\n  }\n  return (this.mode & S_IFMT) === property;\n};\n\n/**\n * @param {Float64Array | BigInt64Array} stats\n * @param {number} offset\n * @returns {BigIntStats | Stats}\n */\nfunction getStatsFromBinding(stats\x2C offset = 0) {\n  if (isBigInt64Array(stats)) {\n    return new BigIntStats(\n      stats[0 + offset]\x2C stats[1 + offset]\x2C stats[2 + offset]\x2C\n      stats[3 + offset]\x2C stats[4 + offset]\x2C stats[5 + offset]\x2C\n      stats[6 + offset]\x2C stats[7 + offset]\x2C stats[8 + offset]\x2C\n      stats[9 + offset]\x2C\n      nsFromTimeSpecBigInt(stats[10 + offset]\x2C stats[11 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[12 + offset]\x2C stats[13 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[14 + offset]\x2C stats[15 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[16 + offset]\x2C stats[17 + offset])\x2C\n    );\n  }\n  return new Stats(\n    stats[0 + offset]\x2C stats[1 + offset]\x2C stats[2 + offset]\x2C\n    stats[3 + offset]\x2C stats[4 + offset]\x2C stats[5 + offset]\x2C\n    stats[6 + offset]\x2C stats[7 + offset]\x2C stats[8 + offset]\x2C\n    stats[9 + offset]\x2C\n    msFromTimeSpec(stats[10 + offset]\x2C stats[11 + offset])\x2C\n    msFromTimeSpec(stats[12 + offset]\x2C stats[13 + offset])\x2C\n    msFromTimeSpec(stats[14 + offset]\x2C stats[15 + offset])\x2C\n    msFromTimeSpec(stats[16 + offset]\x2C stats[17 + offset])\x2C\n  );\n}\n\nclass StatFs {\n  constructor(type\x2C bsize\x2C blocks\x2C bfree\x2C bavail\x2C files\x2C ffree) {\n    this.type = type;\n    this.bsize = bsize;\n    this.blocks = blocks;\n    this.bfree = bfree;\n    this.bavail = bavail;\n    this.files = files;\n    this.ffree = ffree;\n  }\n}\n\nfunction getStatFsFromBinding(stats) {\n  return new StatFs(\n    stats[0]\x2C stats[1]\x2C stats[2]\x2C stats[3]\x2C stats[4]\x2C stats[5]\x2C stats[6]\x2C\n  );\n}\n\nfunction stringToFlags(flags\x2C name = 'flags') {\n  if (typeof flags === 'number') {\n    validateInt32(flags\x2C name);\n    return flags;\n  }\n\n  if (flags == null) {\n    return O_RDONLY;\n  }\n\n  switch (flags) {\n    case 'r' : return O_RDONLY;\n    case 'rs' : // Fall through.\n    case 'sr' : return O_RDONLY | O_SYNC;\n    case 'r+' : return O_RDWR;\n    case 'rs+' : // Fall through.\n    case 'sr+' : return O_RDWR | O_SYNC;\n\n    case 'w' : return O_TRUNC | O_CREAT | O_WRONLY;\n    case 'wx' : // Fall through.\n    case 'xw' : return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;\n\n    case 'w+' : return O_TRUNC | O_CREAT | O_RDWR;\n    case 'wx+': // Fall through.\n    case 'xw+': return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;\n\n    case 'a' : return O_APPEND | O_CREAT | O_WRONLY;\n    case 'ax' : // Fall through.\n    case 'xa' : return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;\n    case 'as' : // Fall through.\n    case 'sa' : return O_APPEND | O_CREAT | O_WRONLY | O_SYNC;\n\n    case 'a+' : return O_APPEND | O_CREAT | O_RDWR;\n    case 'ax+': // Fall through.\n    case 'xa+': return O_APPEND | O_CREAT | O_RDWR | O_EXCL;\n    case 'as+': // Fall through.\n    case 'sa+': return O_APPEND | O_CREAT | O_RDWR | O_SYNC;\n  }\n\n  throw new ERR_INVALID_ARG_VALUE('flags'\x2C flags);\n}\n\nconst stringToSymlinkType = hideStackFrames((type) => {\n  let flags = 0;\n  if (typeof type === 'string') {\n    switch (type) {\n      case 'dir':\n        flags |= UV_FS_SYMLINK_DIR;\n        break;\n      case 'junction':\n        flags |= UV_FS_SYMLINK_JUNCTION;\n        break;\n      case 'file':\n        break;\n      default:\n        throw new ERR_FS_INVALID_SYMLINK_TYPE(type);\n    }\n  }\n  return flags;\n});\n\n// converts Date or number to a fractional UNIX timestamp\nfunction toUnixTimestamp(time\x2C name = 'time') {\n  // eslint-disable-next-line eqeqeq\n  if (typeof time === 'string' && +time == time) {\n    return +time;\n  }\n  if (NumberIsFinite(time)) {\n    if (time < 0) {\n      return DateNow() / 1000;\n    }\n    return time;\n  }\n  if (isDate(time)) {\n    // Convert to 123.456 UNIX timestamp\n    return DatePrototypeGetTime(time) / 1000;\n  }\n  throw new ERR_INVALID_ARG_TYPE(name\x2C ['Date'\x2C 'Time in seconds']\x2C time);\n}\n\nconst validateOffsetLengthRead = hideStackFrames(\n  (offset\x2C length\x2C bufferLength) => {\n    if (offset < 0) {\n      throw new ERR_OUT_OF_RANGE('offset'\x2C '>= 0'\x2C offset);\n    }\n    if (length < 0) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C '>= 0'\x2C length);\n    }\n    if (offset + length > bufferLength) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C\n                                 `<= ${bufferLength - offset}`\x2C length);\n    }\n  }\x2C\n);\n\nconst validateOffsetLengthWrite = hideStackFrames(\n  (offset\x2C length\x2C byteLength) => {\n    if (offset > byteLength) {\n      throw new ERR_OUT_OF_RANGE('offset'\x2C `<= ${byteLength}`\x2C offset);\n    }\n\n    if (length > byteLength - offset) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C `<= ${byteLength - offset}`\x2C length);\n    }\n\n    if (length < 0) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C '>= 0'\x2C length);\n    }\n\n    validateInt32(length\x2C 'length'\x2C 0);\n  }\x2C\n);\n\nconst validatePath = hideStackFrames((path\x2C propName = 'path') => {\n  if (typeof path !== 'string' && !isUint8Array(path)) {\n    throw new ERR_INVALID_ARG_TYPE(propName\x2C ['string'\x2C 'Buffer'\x2C 'URL']\x2C path);\n  }\n\n  const err = nullCheck(path\x2C propName\x2C false);\n\n  if (err !== undefined) {\n    throw err;\n  }\n});\n\n// TODO(rafaelgss): implement the path.resolve on C++ side\n// See: https://github.com/nodejs/node/pull/44004#discussion_r930958420\n// The permission model needs the absolute path for the fs_permission\nconst resolvePath = pathModule.resolve;\nconst { isBuffer: BufferIsBuffer\x2C from: BufferFrom } = Buffer;\nconst BufferToString = uncurryThis(Buffer.prototype.toString);\nfunction possiblyTransformPath(path) {\n  if (permission.isEnabled()) {\n    if (typeof path === 'string') {\n      return resolvePath(path);\n    }\n    assert(isUint8Array(path));\n    if (!BufferIsBuffer(path)) path = BufferFrom(path);\n    return BufferFrom(resolvePath(BufferToString(path)));\n  }\n  return path;\n}\n\nconst getValidatedPath = hideStackFrames((fileURLOrPath\x2C propName = 'path') => {\n  const path = toPathIfFileURL(fileURLOrPath);\n  validatePath(path\x2C propName);\n  return possiblyTransformPath(path);\n});\n\nconst getValidatedFd = hideStackFrames((fd\x2C propName = 'fd') => {\n  if (ObjectIs(fd\x2C -0)) {\n    return 0;\n  }\n\n  validateInt32(fd\x2C propName\x2C 0);\n\n  return fd;\n});\n\nconst validateBufferArray = hideStackFrames((buffers\x2C propName = 'buffers') => {\n  if (!ArrayIsArray(buffers))\n    throw new ERR_INVALID_ARG_TYPE(propName\x2C 'ArrayBufferView[]'\x2C buffers);\n\n  for (let i = 0; i < buffers.length; i++) {\n    if (!isArrayBufferView(buffers[i]))\n      throw new ERR_INVALID_ARG_TYPE(propName\x2C 'ArrayBufferView[]'\x2C buffers);\n  }\n\n  return buffers;\n});\n\nlet nonPortableTemplateWarn = true;\n\nfunction warnOnNonPortableTemplate(template) {\n  // Template strings passed to the mkdtemp() family of functions should not\n  // end with 'X' because they are handled inconsistently across platforms.\n  if (nonPortableTemplateWarn &&\n    ((typeof template === 'string' && StringPrototypeEndsWith(template\x2C 'X')) ||\n    (typeof template !== 'string' && TypedArrayPrototypeAt(template\x2C -1) === 0x58))) {\n    process.emitWarning('mkdtemp() templates ending with X are not portable. ' +\n                        'For details see: https://nodejs.org/api/fs.html');\n    nonPortableTemplateWarn = false;\n  }\n}\n\nconst defaultCpOptions = {\n  dereference: false\x2C\n  errorOnExist: false\x2C\n  filter: undefined\x2C\n  force: true\x2C\n  preserveTimestamps: false\x2C\n  recursive: false\x2C\n  verbatimSymlinks: false\x2C\n};\n\nconst defaultRmOptions = {\n  recursive: false\x2C\n  force: false\x2C\n  retryDelay: 100\x2C\n  maxRetries: 0\x2C\n};\n\nconst defaultRmdirOptions = {\n  retryDelay: 100\x2C\n  maxRetries: 0\x2C\n  recursive: false\x2C\n};\n\nconst validateCpOptions = hideStackFrames((options) => {\n  if (options === undefined)\n    return { ...defaultCpOptions };\n  validateObject(options\x2C 'options');\n  options = { ...defaultCpOptions\x2C ...options };\n  validateBoolean(options.dereference\x2C 'options.dereference');\n  validateBoolean(options.errorOnExist\x2C 'options.errorOnExist');\n  validateBoolean(options.force\x2C 'options.force');\n  validateBoolean(options.preserveTimestamps\x2C 'options.preserveTimestamps');\n  validateBoolean(options.recursive\x2C 'options.recursive');\n  validateBoolean(options.verbatimSymlinks\x2C 'options.verbatimSymlinks');\n  options.mode = getValidMode(options.mode\x2C 'copyFile');\n  if (options.dereference === true && options.verbatimSymlinks === true) {\n    throw new ERR_INCOMPATIBLE_OPTION_PAIR('dereference'\x2C 'verbatimSymlinks');\n  }\n  if (options.filter !== undefined) {\n    validateFunction(options.filter\x2C 'options.filter');\n  }\n  return options;\n});\n\nconst validateRmOptions = hideStackFrames((path\x2C options\x2C expectDir\x2C cb) => {\n  options = validateRmdirOptions(options\x2C defaultRmOptions);\n  validateBoolean(options.force\x2C 'options.force');\n\n  lazyLoadFs().lstat(path\x2C (err\x2C stats) => {\n    if (err) {\n      if (options.force && err.code === 'ENOENT') {\n        return cb(null\x2C options);\n      }\n      return cb(err\x2C options);\n    }\n\n    if (expectDir && !stats.isDirectory()) {\n      return cb(false);\n    }\n\n    if (stats.isDirectory() && !options.recursive) {\n      return cb(new ERR_FS_EISDIR({\n        code: 'EISDIR'\x2C\n        message: 'is a directory'\x2C\n        path\x2C\n        syscall: 'rm'\x2C\n        errno: EISDIR\x2C\n      }));\n    }\n    return cb(null\x2C options);\n  });\n});\n\nconst validateRmOptionsSync = hideStackFrames((path\x2C options\x2C expectDir) => {\n  options = validateRmdirOptions(options\x2C defaultRmOptions);\n  validateBoolean(options.force\x2C 'options.force');\n\n  if (!options.force || expectDir || !options.recursive) {\n    const isDirectory = lazyLoadFs()\n      .lstatSync(path\x2C { throwIfNoEntry: !options.force })?.isDirectory();\n\n    if (expectDir && !isDirectory) {\n      return false;\n    }\n\n    if (isDirectory && !options.recursive) {\n      throw new ERR_FS_EISDIR({\n        code: 'EISDIR'\x2C\n        message: 'is a directory'\x2C\n        path\x2C\n        syscall: 'rm'\x2C\n        errno: EISDIR\x2C\n      });\n    }\n  }\n\n  return options;\n});\n\nlet recursiveRmdirWarned = process.noDeprecation;\nfunction emitRecursiveRmdirWarning() {\n  if (!recursiveRmdirWarned) {\n    process.emitWarning(\n      'In future versions of Node.js\x2C fs.rmdir(path\x2C { recursive: true }) ' +\n      'will be removed. Use fs.rm(path\x2C { recursive: true }) instead'\x2C\n      'DeprecationWarning'\x2C\n      'DEP0147'\x2C\n    );\n    recursiveRmdirWarned = true;\n  }\n}\n\nconst validateRmdirOptions = hideStackFrames(\n  (options\x2C defaults = defaultRmdirOptions) => {\n    if (options === undefined)\n      return defaults;\n    validateObject(options\x2C 'options');\n\n    options = { ...defaults\x2C ...options };\n\n    validateBoolean(options.recursive\x2C 'options.recursive');\n    validateInt32(options.retryDelay\x2C 'options.retryDelay'\x2C 0);\n    validateUint32(options.maxRetries\x2C 'options.maxRetries');\n\n    return options;\n  });\n\nconst getValidMode = hideStackFrames((mode\x2C type) => {\n  let min = kMinimumAccessMode;\n  let max = kMaximumAccessMode;\n  let def = F_OK;\n  if (type === 'copyFile') {\n    min = kMinimumCopyMode;\n    max = kMaximumCopyMode;\n    def = mode || kDefaultCopyMode;\n  } else {\n    assert(type === 'access');\n  }\n  if (mode == null) {\n    return def;\n  }\n  validateInteger(mode\x2C 'mode'\x2C min\x2C max);\n  return mode;\n});\n\nconst validateStringAfterArrayBufferView = hideStackFrames((buffer\x2C name) => {\n  if (typeof buffer !== 'string') {\n    throw new ERR_INVALID_ARG_TYPE(\n      name\x2C\n      ['string'\x2C 'Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n      buffer\x2C\n    );\n  }\n});\n\nconst validatePosition = hideStackFrames((position\x2C name) => {\n  if (typeof position === 'number') {\n    validateInteger(position\x2C name);\n  } else if (typeof position === 'bigint') {\n    if (!(position >= -(2n ** 63n) && position <= 2n ** 63n - 1n)) {\n      throw new ERR_OUT_OF_RANGE(name\x2C\n                                 `>= ${-(2n ** 63n)} && <= ${2n ** 63n - 1n}`\x2C\n                                 position);\n    }\n  } else {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C ['integer'\x2C 'bigint']\x2C position);\n  }\n});\n\nmodule.exports = {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n    kReadFileBufferLength\x2C\n    kReadFileUnknownBufferLength\x2C\n    kWriteFileMaxChunkSize\x2C\n  }\x2C\n  assertEncoding\x2C\n  BigIntStats\x2C  // for testing\n  copyObject\x2C\n  Dirent\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirent\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getValidatedFd\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  handleErrorFromBinding\x2C\n  nullCheck\x2C\n  possiblyTransformPath\x2C\n  preprocessSymlinkDestination\x2C\n  realpathCacheKey: Symbol('realpathCacheKey')\x2C\n  getStatFsFromBinding\x2C\n  getStatsFromBinding\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  Stats\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateCpOptions\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validatePath\x2C\n  validatePosition\x2C\n  validateRmOptions\x2C\n  validateRmOptionsSync\x2C\n  validateRmdirOptions\x2C\n  validateStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\x2C\n};\n
code-source-info,0x31e6f6b6c44e,60,7457,8064,C9O7484C16O7502C27O7562C29O7584C30O7592C36O7631C41O7675C43O7699C47O7714C54O7749C60O7788C78O7794C83O7788C84O7881C91O7890C96O7908C99O7931C104O7908C108O7957C114O7985C119O8013C127O7985C132O8047C134O8062,,
tick,0x7ff8091ca4dd,64281,0,0x0,3,0x10c9f09d0,0x31e6f6b65694,0x31e6f6b652e1,0x31e6f6b64bdf,0x31e6f6b62053,0x31e6f6b6075c,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
tick,0x7ff809303aef,64302,0,0x0,3,0x10c9f09d0,0x31e6f6b65694,0x31e6f6b652e1,0x31e6f6b64bdf,0x31e6f6b62053,0x31e6f6b6075c,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,64316,0x31e6f6b6e4de,48,assertEncoding node:internal/fs/utils:158:24,0x31e647c72bc0,~
code-source-info,0x31e6f6b6e4de,60,3655,3832,C0O3670C6O3687C9O3694C14O3694C21O3737C24O3764C40O3770C45O3764C47O3831,,
code-creation,JS,10,64423,0x31e6f6b6e5f6,20,toPathIfFileURL node:internal/url:1479:25,0x31e647c609a0,~
script-source,39,node:internal/url,'use strict';\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeReduce\x2C\n  ArrayPrototypeSlice\x2C\n  Boolean\x2C\n  Int8Array\x2C\n  IteratorPrototype\x2C\n  Number\x2C\n  ObjectDefineProperties\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectGetOwnPropertyDescriptor\x2C\n  ReflectOwnKeys\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeCharAt\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeCodePointAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n  Symbol\x2C\n  SymbolIterator\x2C\n  SymbolToStringTag\x2C\n  decodeURIComponent\x2C\n} = primordials;\n\nconst { inspect } = require('internal/util/inspect');\nconst {\n  encodeStr\x2C\n  hexTable\x2C\n  isHexTable\x2C\n} = require('internal/querystring');\n\nconst {\n  getConstructorOf\x2C\n  removeColors\x2C\n  toUSVString\x2C\n  kEnumerableProperty\x2C\n  SideEffectFreeRegExpPrototypeSymbolReplace\x2C\n} = require('internal/util');\n\nconst {\n  codes: {\n    ERR_ARG_NOT_ITERABLE\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_FILE_URL_HOST\x2C\n    ERR_INVALID_FILE_URL_PATH\x2C\n    ERR_INVALID_THIS\x2C\n    ERR_INVALID_TUPLE\x2C\n    ERR_INVALID_URL\x2C\n    ERR_INVALID_URL_SCHEME\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_NO_CRYPTO\x2C\n  }\x2C\n} = require('internal/errors');\nconst {\n  CHAR_AMPERSAND\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_EQUAL\x2C\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_LOWERCASE_A\x2C\n  CHAR_LOWERCASE_Z\x2C\n  CHAR_PERCENT\x2C\n  CHAR_PLUS\x2C\n} = require('internal/constants');\nconst path = require('path');\n\nconst {\n  validateFunction\x2C\n} = require('internal/validators');\n\nconst querystring = require('querystring');\n\nconst { platform } = process;\nconst isWindows = platform === 'win32';\n\nconst bindingUrl = internalBinding('url');\n\nconst FORWARD_SLASH = /\\//g;\n\nconst contextForInspect = Symbol('context');\n\n// `unsafeProtocol`\x2C `hostlessProtocol` and `slashedProtocol` is\n// deliberately moved to `internal/url` rather than `url`.\n// Workers does not bootstrap URL module. Therefore\x2C `SafeSet`\n// is not initialized on bootstrap. This case breaks the\n// test-require-delete-array-iterator test.\n\n// Protocols that can allow "unsafe" and "unwise" chars.\nconst unsafeProtocol = new SafeSet([\n  'javascript'\x2C\n  'javascript:'\x2C\n]);\n// Protocols that never have a hostname.\nconst hostlessProtocol = new SafeSet([\n  'javascript'\x2C\n  'javascript:'\x2C\n]);\n// Protocols that always contain a // bit.\nconst slashedProtocol = new SafeSet([\n  'http'\x2C\n  'http:'\x2C\n  'https'\x2C\n  'https:'\x2C\n  'ftp'\x2C\n  'ftp:'\x2C\n  'gopher'\x2C\n  'gopher:'\x2C\n  'file'\x2C\n  'file:'\x2C\n  'ws'\x2C\n  'ws:'\x2C\n  'wss'\x2C\n  'wss:'\x2C\n]);\n\nconst updateActions = {\n  kProtocol: 0\x2C\n  kHost: 1\x2C\n  kHostname: 2\x2C\n  kPort: 3\x2C\n  kUsername: 4\x2C\n  kPassword: 5\x2C\n  kPathname: 6\x2C\n  kSearch: 7\x2C\n  kHash: 8\x2C\n  kHref: 9\x2C\n};\nlet blob;\nlet cryptoRandom;\n\nfunction lazyBlob() {\n  blob ??= require('internal/blob');\n  return blob;\n}\n\nfunction lazyCryptoRandom() {\n  try {\n    cryptoRandom ??= require('internal/crypto/random');\n  } catch {\n    // If Node.js built without crypto support\x2C we'll fall\n    // through here and handle it later.\n  }\n  return cryptoRandom;\n}\n\n// This class provides the internal state of a URL object. An instance of this\n// class is stored in every URL object and is accessed internally by setters\n// and getters. It roughly corresponds to the concept of a URL record in the\n// URL Standard\x2C with a few differences. It is also the object transported to\n// the C++ binding.\n// Refs: https://url.spec.whatwg.org/#concept-url\nclass URLContext {\n  // This is the maximum value uint32_t can get.\n  // Ada uses uint32_t(-1) for declaring omitted values.\n  static #omitted = 4294967295;\n\n  href = '';\n  protocol_end = 0;\n  username_end = 0;\n  host_start = 0;\n  host_end = 0;\n  pathname_start = 0;\n  search_start = 0;\n  hash_start = 0;\n  port = 0;\n  /**\n   * Refers to `ada::scheme::type`\n   *\n   * enum type : uint8_t {\n   *   HTTP = 0\x2C\n   *   NOT_SPECIAL = 1\x2C\n   *   HTTPS = 2\x2C\n   *   WS = 3\x2C\n   *   FTP = 4\x2C\n   *   WSS = 5\x2C\n   *   FILE = 6\n   * };\n   * @type {number}\n   */\n  scheme_type = 1;\n\n  get hasPort() {\n    return this.port !== URLContext.#omitted;\n  }\n\n  get hasSearch() {\n    return this.search_start !== URLContext.#omitted;\n  }\n\n  get hasHash() {\n    return this.hash_start !== URLContext.#omitted;\n  }\n}\n\nlet setURLSearchParamsContext;\nlet getURLSearchParamsList;\nlet setURLSearchParams;\n\nclass URLSearchParamsIterator {\n  #target;\n  #kind;\n  #index;\n\n  // https://heycam.github.io/webidl/#dfn-default-iterator-object\n  constructor(target\x2C kind) {\n    this.#target = target;\n    this.#kind = kind;\n    this.#index = 0;\n  }\n\n  next() {\n    if (typeof this !== 'object' || this === null || !(#target in this))\n      throw new ERR_INVALID_THIS('URLSearchParamsIterator');\n\n    const index = this.#index;\n    const values = getURLSearchParamsList(this.#target);\n    const len = values.length;\n    if (index >= len) {\n      return {\n        value: undefined\x2C\n        done: true\x2C\n      };\n    }\n\n    const name = values[index];\n    const value = values[index + 1];\n    this.#index = index + 2;\n\n    let result;\n    if (this.#kind === 'key') {\n      result = name;\n    } else if (this.#kind === 'value') {\n      result = value;\n    } else {\n      result = [name\x2C value];\n    }\n\n    return {\n      value: result\x2C\n      done: false\x2C\n    };\n  }\n\n  [inspect.custom](recurseTimes\x2C ctx) {\n    if (!this || typeof this !== 'object' || !(#target in this))\n      throw new ERR_INVALID_THIS('URLSearchParamsIterator');\n\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\n      return ctx.stylize('[Object]'\x2C 'special');\n\n    const innerOpts = { ...ctx };\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    const index = this.#index;\n    const values = getURLSearchParamsList(this.#target);\n    const output = ArrayPrototypeReduce(\n      ArrayPrototypeSlice(values\x2C index)\x2C\n      (prev\x2C cur\x2C i) => {\n        const key = i % 2 === 0;\n        if (this.#kind === 'key' && key) {\n          ArrayPrototypePush(prev\x2C cur);\n        } else if (this.#kind === 'value' && !key) {\n          ArrayPrototypePush(prev\x2C cur);\n        } else if (this.#kind === 'key+value' && !key) {\n          ArrayPrototypePush(prev\x2C [values[index + i - 1]\x2C cur]);\n        }\n        return prev;\n      }\x2C\n      []\x2C\n    );\n    const breakLn = StringPrototypeIncludes(inspect(output\x2C innerOpts)\x2C '\\n');\n    const outputStrs = ArrayPrototypeMap(output\x2C (p) => inspect(p\x2C innerOpts));\n    let outputStr;\n    if (breakLn) {\n      outputStr = `\\n  ${ArrayPrototypeJoin(outputStrs\x2C '\x2C\\n  ')}`;\n    } else {\n      outputStr = ` ${ArrayPrototypeJoin(outputStrs\x2C '\x2C ')}`;\n    }\n    return `${this[SymbolToStringTag]} {${outputStr} }`;\n  }\n}\n\n// https://heycam.github.io/webidl/#dfn-iterator-prototype-object\ndelete URLSearchParamsIterator.prototype.constructor;\nObjectSetPrototypeOf(URLSearchParamsIterator.prototype\x2C IteratorPrototype);\n\nObjectDefineProperties(URLSearchParamsIterator.prototype\x2C {\n  [SymbolToStringTag]: { __proto__: null\x2C configurable: true\x2C value: 'URLSearchParams Iterator' }\x2C\n  next: kEnumerableProperty\x2C\n});\n\n\nclass URLSearchParams {\n  #searchParams = [];\n\n  // "associated url object"\n  #context;\n\n  static {\n    setURLSearchParamsContext = (obj\x2C ctx) => {\n      obj.#context = ctx;\n    };\n    getURLSearchParamsList = (obj) => obj.#searchParams;\n    setURLSearchParams = (obj\x2C query) => {\n      if (query === undefined) {\n        obj.#searchParams = [];\n      } else {\n        obj.#searchParams = parseParams(query);\n      }\n    };\n  }\n\n  // URL Standard says the default value is ''\x2C but as undefined and '' have\n  // the same result\x2C undefined is used to prevent unnecessary parsing.\n  // Default parameter is necessary to keep URLSearchParams.length === 0 in\n  // accordance with Web IDL spec.\n  constructor(init = undefined) {\n    if (init == null) {\n      // Do nothing\n    } else if (typeof init === 'object' || typeof init === 'function') {\n      const method = init[SymbolIterator];\n      if (method === this[SymbolIterator] && #searchParams in init) {\n        // While the spec does not have this branch\x2C we can use it as a\n        // shortcut to avoid having to go through the costly generic iterator.\n        const childParams = init.#searchParams;\n        this.#searchParams = childParams.slice();\n      } else if (method != null) {\n        // Sequence<sequence<USVString>>\n        if (typeof method !== 'function') {\n          throw new ERR_ARG_NOT_ITERABLE('Query pairs');\n        }\n\n        // The following implementationd differs from the URL specification:\n        // Sequences must first be converted from ECMAScript objects before\n        // and operations are done on them\x2C and the operation of converting\n        // the sequences would first exhaust the iterators. If the iterator\n        // returns something invalid in the middle\x2C whether it would be called\n        // after that would be an observable change to the users.\n        // Exhausting the iterator and later converting them to USVString comes\n        // with a significant cost (~40-80%). In order optimize URLSearchParams\n        // creation duration\x2C Node.js merges the iteration and converting\n        // iterations into a single iteration.\n        for (const pair of init) {\n          if (pair == null) {\n            throw new ERR_INVALID_TUPLE('Each query pair'\x2C '[name\x2C value]');\n          } else if (ArrayIsArray(pair)) {\n            // If innerSequence's size is not 2\x2C then throw a TypeError.\n            if (pair.length !== 2) {\n              throw new ERR_INVALID_TUPLE('Each query pair'\x2C '[name\x2C value]');\n            }\n            // Append (innerSequence[0]\x2C innerSequence[1]) to querys list.\n            ArrayPrototypePush(this.#searchParams\x2C toUSVString(pair[0])\x2C toUSVString(pair[1]));\n          } else {\n            if (((typeof pair !== 'object' && typeof pair !== 'function') ||\n                typeof pair[SymbolIterator] !== 'function')) {\n              throw new ERR_INVALID_TUPLE('Each query pair'\x2C '[name\x2C value]');\n            }\n\n            let length = 0;\n\n            for (const element of pair) {\n              length++;\n              ArrayPrototypePush(this.#searchParams\x2C toUSVString(element));\n            }\n\n            // If innerSequence's size is not 2\x2C then throw a TypeError.\n            if (length !== 2) {\n              throw new ERR_INVALID_TUPLE('Each query pair'\x2C '[name\x2C value]');\n            }\n          }\n        }\n      } else {\n        // Record<USVString\x2C USVString>\n        // Need to use reflection APIs for full spec compliance.\n        const visited = new SafeMap();\n        const keys = ReflectOwnKeys(init);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          const desc = ReflectGetOwnPropertyDescriptor(init\x2C key);\n          if (desc !== undefined && desc.enumerable) {\n            const typedKey = toUSVString(key);\n            const typedValue = toUSVString(init[key]);\n\n            // Two different keys may become the same USVString after normalization.\n            // In that case\x2C we retain the later one. Refer to WPT.\n            const keyIdx = visited.get(typedKey);\n            if (keyIdx !== undefined) {\n              this.#searchParams[keyIdx] = typedValue;\n            } else {\n              visited.set(typedKey\x2C ArrayPrototypePush(this.#searchParams\x2C\n                                                       typedKey\x2C\n                                                       typedValue) - 1);\n            }\n          }\n        }\n      }\n    } else {\n      // https://url.spec.whatwg.org/#dom-urlsearchparams-urlsearchparams\n      init = toUSVString(init);\n      this.#searchParams = init ? parseParams(init) : [];\n    }\n  }\n\n  [inspect.custom](recurseTimes\x2C ctx) {\n    if (typeof this !== 'object' || this === null || !(#searchParams in this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\n      return ctx.stylize('[Object]'\x2C 'special');\n\n    const separator = '\x2C ';\n    const innerOpts = { ...ctx };\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    const innerInspect = (v) => inspect(v\x2C innerOpts);\n\n    const list = this.#searchParams;\n    const output = [];\n    for (let i = 0; i < list.length; i += 2)\n      ArrayPrototypePush(\n        output\x2C\n        `${innerInspect(list[i])} => ${innerInspect(list[i + 1])}`);\n\n    const length = ArrayPrototypeReduce(\n      output\x2C\n      (prev\x2C cur) => prev + removeColors(cur).length + separator.length\x2C\n      -separator.length\x2C\n    );\n    if (length > ctx.breakLength) {\n      return `${this.constructor.name} {\\n` +\n      `  ${ArrayPrototypeJoin(output\x2C '\x2C\\n  ')} }`;\n    } else if (output.length) {\n      return `${this.constructor.name} { ` +\n      `${ArrayPrototypeJoin(output\x2C separator)} }`;\n    }\n    return `${this.constructor.name} {}`;\n  }\n\n  get size() {\n    if (typeof this !== 'object' || this === null || !(#searchParams in this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    return this.#searchParams.length / 2;\n  }\n\n  append(name\x2C value) {\n    if (typeof this !== 'object' || this === null || !(#searchParams in this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 2) {\n      throw new ERR_MISSING_ARGS('name'\x2C 'value');\n    }\n\n    name = toUSVString(name);\n    value = toUSVString(value);\n    ArrayPrototypePush(this.#searchParams\x2C name\x2C value);\n    if (this.#context) {\n      this.#context.search = this.toString();\n    }\n  }\n\n  delete(name\x2C value = undefined) {\n    if (typeof this !== 'object' || this === null || !(#searchParams in this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this.#searchParams;\n    name = toUSVString(name);\n\n    if (value !== undefined) {\n      value = toUSVString(value);\n      for (let i = 0; i < list.length;) {\n        if (list[i] === name && list[i + 1] === value) {\n          list.splice(i\x2C 2);\n        } else {\n          i += 2;\n        }\n      }\n    } else {\n      for (let i = 0; i < list.length;) {\n        if (list[i] === name) {\n          list.splice(i\x2C 2);\n        } else {\n          i += 2;\n        }\n      }\n    }\n    if (this.#context) {\n      this.#context.search = this.toString();\n    }\n  }\n\n  get(name) {\n    if (typeof this !== 'object' || this === null || !(#searchParams in this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this.#searchParams;\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        return list[i + 1];\n      }\n    }\n    return null;\n  }\n\n  getAll(name) {\n    if (typeof this !== 'object' || this === null || !(#searchParams in this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this.#searchParams;\n    const values = [];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        values.push(list[i + 1]);\n      }\n    }\n    return values;\n  }\n\n  has(name\x2C value = undefined) {\n    if (typeof this !== 'object' || this === null || !(#searchParams in this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this.#searchParams;\n    name = toUSVString(name);\n\n    if (value !== undefined) {\n      value = toUSVString(value);\n    }\n\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        if (value === undefined || list[i + 1] === value) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  set(name\x2C value) {\n    if (typeof this !== 'object' || this === null || !(#searchParams in this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 2) {\n      throw new ERR_MISSING_ARGS('name'\x2C 'value');\n    }\n\n    const list = this.#searchParams;\n    name = toUSVString(name);\n    value = toUSVString(value);\n\n    // If there are any name-value pairs whose name is `name`\x2C in `list`\x2C set\n    // the value of the first such name-value pair to `value` and remove the\n    // others.\n    let found = false;\n    for (let i = 0; i < list.length;) {\n      const cur = list[i];\n      if (cur === name) {\n        if (!found) {\n          list[i + 1] = value;\n          found = true;\n          i += 2;\n        } else {\n          list.splice(i\x2C 2);\n        }\n      } else {\n        i += 2;\n      }\n    }\n\n    // Otherwise\x2C append a new name-value pair whose name is `name` and value\n    // is `value`\x2C to `list`.\n    if (!found) {\n      ArrayPrototypePush(list\x2C name\x2C value);\n    }\n\n    if (this.#context) {\n      this.#context.search = this.toString();\n    }\n  }\n\n  sort() {\n    if (typeof this !== 'object' || this === null || !(#searchParams in this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    const a = this.#searchParams;\n    const len = a.length;\n\n    if (len <= 2) {\n      // Nothing needs to be done.\n    } else if (len < 100) {\n      // 100 is found through testing.\n      // Simple stable in-place insertion sort\n      // Derived from v8/src/js/array.js\n      for (let i = 2; i < len; i += 2) {\n        const curKey = a[i];\n        const curVal = a[i + 1];\n        let j;\n        for (j = i - 2; j >= 0; j -= 2) {\n          if (a[j] > curKey) {\n            a[j + 2] = a[j];\n            a[j + 3] = a[j + 1];\n          } else {\n            break;\n          }\n        }\n        a[j + 2] = curKey;\n        a[j + 3] = curVal;\n      }\n    } else {\n      // Bottom-up iterative stable merge sort\n      const lBuffer = new Array(len);\n      const rBuffer = new Array(len);\n      for (let step = 2; step < len; step *= 2) {\n        for (let start = 0; start < len - 2; start += 2 * step) {\n          const mid = start + step;\n          let end = mid + step;\n          end = end < len ? end : len;\n          if (mid > end)\n            continue;\n          merge(a\x2C start\x2C mid\x2C end\x2C lBuffer\x2C rBuffer);\n        }\n      }\n    }\n\n    if (this.#context) {\n      this.#context.search = this.toString();\n    }\n  }\n\n  // https://heycam.github.io/webidl/#es-iterators\n  // Define entries here rather than [Symbol.iterator] as the function name\n  // must be set to `entries`.\n  entries() {\n    if (typeof this !== 'object' || this === null || !(#searchParams in this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return new URLSearchParamsIterator(this\x2C 'key+value');\n  }\n\n  forEach(callback\x2C thisArg = undefined) {\n    if (typeof this !== 'object' || this === null || !(#searchParams in this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    validateFunction(callback\x2C 'callback');\n\n    let list = this.#searchParams;\n\n    let i = 0;\n    while (i < list.length) {\n      const key = list[i];\n      const value = list[i + 1];\n      callback.call(thisArg\x2C value\x2C key\x2C this);\n      // In case the URL object's `search` is updated\n      list = this.#searchParams;\n      i += 2;\n    }\n  }\n\n  // https://heycam.github.io/webidl/#es-iterable\n  keys() {\n    if (typeof this !== 'object' || this === null || !(#searchParams in this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return new URLSearchParamsIterator(this\x2C 'key');\n  }\n\n  values() {\n    if (typeof this !== 'object' || this === null || !(#searchParams in this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return new URLSearchParamsIterator(this\x2C 'value');\n  }\n\n  // https://heycam.github.io/webidl/#es-stringifier\n  // https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior\n  toString() {\n    if (typeof this !== 'object' || this === null || !(#searchParams in this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return serializeParams(this.#searchParams);\n  }\n}\n\nObjectDefineProperties(URLSearchParams.prototype\x2C {\n  append: kEnumerableProperty\x2C\n  delete: kEnumerableProperty\x2C\n  get: kEnumerableProperty\x2C\n  getAll: kEnumerableProperty\x2C\n  has: kEnumerableProperty\x2C\n  set: kEnumerableProperty\x2C\n  size: kEnumerableProperty\x2C\n  sort: kEnumerableProperty\x2C\n  entries: kEnumerableProperty\x2C\n  forEach: kEnumerableProperty\x2C\n  keys: kEnumerableProperty\x2C\n  values: kEnumerableProperty\x2C\n  toString: kEnumerableProperty\x2C\n  [SymbolToStringTag]: { __proto__: null\x2C configurable: true\x2C value: 'URLSearchParams' }\x2C\n\n  // https://heycam.github.io/webidl/#es-iterable-entries\n  [SymbolIterator]: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    writable: true\x2C\n    value: URLSearchParams.prototype.entries\x2C\n  }\x2C\n});\n\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron)\x2C so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * We check for `auth` and `path` attribute to distinguish legacy url instance with\n * WHATWG URL instance.\n * @param {*} self\n * @returns {self is URL}\n */\nfunction isURL(self) {\n  return Boolean(self?.href && self.protocol && self.auth === undefined && self.path === undefined);\n}\n\nclass URL {\n  #context = new URLContext();\n  #searchParams;\n\n  constructor(input\x2C base = undefined) {\n    if (arguments.length === 0) {\n      throw new ERR_MISSING_ARGS('url');\n    }\n\n    // toUSVString is not needed.\n    input = `${input}`;\n\n    if (base !== undefined) {\n      base = `${base}`;\n    }\n\n    this.#updateContext(bindingUrl.parse(input\x2C base));\n  }\n\n  [inspect.custom](depth\x2C opts) {\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n\n    const constructor = getConstructorOf(this) || URL;\n    const obj = { __proto__: { constructor } };\n\n    obj.href = this.href;\n    obj.origin = this.origin;\n    obj.protocol = this.protocol;\n    obj.username = this.username;\n    obj.password = this.password;\n    obj.host = this.host;\n    obj.hostname = this.hostname;\n    obj.port = this.port;\n    obj.pathname = this.pathname;\n    obj.search = this.search;\n    obj.searchParams = this.searchParams;\n    obj.hash = this.hash;\n\n    if (opts.showHidden) {\n      obj[contextForInspect] = this.#context;\n    }\n\n    return `${constructor.name} ${inspect(obj\x2C opts)}`;\n  }\n\n  #updateContext(href) {\n    this.#context.href = href;\n\n    const {\n      0: protocol_end\x2C\n      1: username_end\x2C\n      2: host_start\x2C\n      3: host_end\x2C\n      4: port\x2C\n      5: pathname_start\x2C\n      6: search_start\x2C\n      7: hash_start\x2C\n      8: scheme_type\x2C\n    } = bindingUrl.urlComponents;\n\n    this.#context.protocol_end = protocol_end;\n    this.#context.username_end = username_end;\n    this.#context.host_start = host_start;\n    this.#context.host_end = host_end;\n    this.#context.port = port;\n    this.#context.pathname_start = pathname_start;\n    this.#context.search_start = search_start;\n    this.#context.hash_start = hash_start;\n    this.#context.scheme_type = scheme_type;\n\n    if (this.#searchParams) {\n      if (this.#context.hasSearch) {\n        setURLSearchParams(this.#searchParams\x2C this.search);\n      } else {\n        setURLSearchParams(this.#searchParams\x2C undefined);\n      }\n    }\n  }\n\n  toString() {\n    return this.#context.href;\n  }\n\n  get href() {\n    return this.#context.href;\n  }\n\n  set href(value) {\n    value = `${value}`;\n    const href = bindingUrl.update(this.#context.href\x2C updateActions.kHref\x2C value);\n    if (!href) { throw new ERR_INVALID_URL(value); }\n    this.#updateContext(href);\n  }\n\n  // readonly\n  get origin() {\n    const protocol = StringPrototypeSlice(this.#context.href\x2C 0\x2C this.#context.protocol_end);\n\n    // Check if scheme_type is not `NOT_SPECIAL`\n    if (this.#context.scheme_type !== 1) {\n      // Check if scheme_type is `FILE`\n      if (this.#context.scheme_type === 6) {\n        return 'null';\n      }\n      return `${protocol}//${this.host}`;\n    }\n\n    if (protocol === 'blob:') {\n      const path = this.pathname;\n      if (path.length > 0) {\n        try {\n          const out = new URL(path);\n          // Only return origin of scheme is `http` or `https`\n          // Otherwise return a new opaque origin (null).\n          if (out.#context.scheme_type === 0 || out.#context.scheme_type === 2) {\n            return `${out.protocol}//${out.host}`;\n          }\n        } catch {\n          // Do nothing.\n        }\n      }\n    }\n\n    return 'null';\n  }\n\n  get protocol() {\n    return StringPrototypeSlice(this.#context.href\x2C 0\x2C this.#context.protocol_end);\n  }\n\n  set protocol(value) {\n    const href = bindingUrl.update(this.#context.href\x2C updateActions.kProtocol\x2C `${value}`);\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  get username() {\n    if (this.#context.protocol_end + 2 < this.#context.username_end) {\n      return StringPrototypeSlice(this.#context.href\x2C this.#context.protocol_end + 2\x2C this.#context.username_end);\n    }\n    return '';\n  }\n\n  set username(value) {\n    const href = bindingUrl.update(this.#context.href\x2C updateActions.kUsername\x2C `${value}`);\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  get password() {\n    if (this.#context.host_start - this.#context.username_end > 0) {\n      return StringPrototypeSlice(this.#context.href\x2C this.#context.username_end + 1\x2C this.#context.host_start);\n    }\n    return '';\n  }\n\n  set password(value) {\n    const href = bindingUrl.update(this.#context.href\x2C updateActions.kPassword\x2C `${value}`);\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  get host() {\n    let startsAt = this.#context.host_start;\n    if (this.#context.href[startsAt] === '@') {\n      startsAt++;\n    }\n    // If we have an empty host\x2C then the space between components.host_end and\n    // components.pathname_start may be occupied by /.\n    if (startsAt === this.#context.host_end) {\n      return '';\n    }\n    return StringPrototypeSlice(this.#context.href\x2C startsAt\x2C this.#context.pathname_start);\n  }\n\n  set host(value) {\n    const href = bindingUrl.update(this.#context.href\x2C updateActions.kHost\x2C `${value}`);\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  get hostname() {\n    let startsAt = this.#context.host_start;\n    // host_start might be "@" if the URL has credentials\n    if (this.#context.href[startsAt] === '@') {\n      startsAt++;\n    }\n    return StringPrototypeSlice(this.#context.href\x2C startsAt\x2C this.#context.host_end);\n  }\n\n  set hostname(value) {\n    const href = bindingUrl.update(this.#context.href\x2C updateActions.kHostname\x2C `${value}`);\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  get port() {\n    if (this.#context.hasPort) {\n      return `${this.#context.port}`;\n    }\n    return '';\n  }\n\n  set port(value) {\n    const href = bindingUrl.update(this.#context.href\x2C updateActions.kPort\x2C `${value}`);\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  get pathname() {\n    let endsAt;\n    if (this.#context.hasSearch) {\n      endsAt = this.#context.search_start;\n    } else if (this.#context.hasHash) {\n      endsAt = this.#context.hash_start;\n    }\n    return StringPrototypeSlice(this.#context.href\x2C this.#context.pathname_start\x2C endsAt);\n  }\n\n  set pathname(value) {\n    const href = bindingUrl.update(this.#context.href\x2C updateActions.kPathname\x2C `${value}`);\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  get search() {\n    if (!this.#context.hasSearch) { return ''; }\n    let endsAt = this.#context.href.length;\n    if (this.#context.hasHash) { endsAt = this.#context.hash_start; }\n    if (endsAt - this.#context.search_start <= 1) { return ''; }\n    return StringPrototypeSlice(this.#context.href\x2C this.#context.search_start\x2C endsAt);\n  }\n\n  set search(value) {\n    const href = bindingUrl.update(this.#context.href\x2C updateActions.kSearch\x2C toUSVString(value));\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  // readonly\n  get searchParams() {\n    // Create URLSearchParams on demand to greatly improve the URL performance.\n    if (this.#searchParams == null) {\n      this.#searchParams = new URLSearchParams(this.search);\n      setURLSearchParamsContext(this.#searchParams\x2C this);\n    }\n    return this.#searchParams;\n  }\n\n  get hash() {\n    if (!this.#context.hasHash || (this.#context.href.length - this.#context.hash_start <= 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(this.#context.href\x2C this.#context.hash_start);\n  }\n\n  set hash(value) {\n    const href = bindingUrl.update(this.#context.href\x2C updateActions.kHash\x2C `${value}`);\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  toJSON() {\n    return this.#context.href;\n  }\n\n  static canParse(url\x2C base = undefined) {\n    if (arguments.length === 0) {\n      throw new ERR_MISSING_ARGS('url');\n    }\n\n    url = `${url}`;\n\n    if (base !== undefined) {\n      return bindingUrl.canParse(url\x2C `${base}`);\n    }\n\n    // It is important to differentiate the canParse call statements\n    // since they resolve into different v8 fast api overloads.\n    return bindingUrl.canParse(url);\n  }\n}\n\nObjectDefineProperties(URL.prototype\x2C {\n  [SymbolToStringTag]: { __proto__: null\x2C configurable: true\x2C value: 'URL' }\x2C\n  toString: kEnumerableProperty\x2C\n  href: kEnumerableProperty\x2C\n  origin: kEnumerableProperty\x2C\n  protocol: kEnumerableProperty\x2C\n  username: kEnumerableProperty\x2C\n  password: kEnumerableProperty\x2C\n  host: kEnumerableProperty\x2C\n  hostname: kEnumerableProperty\x2C\n  port: kEnumerableProperty\x2C\n  pathname: kEnumerableProperty\x2C\n  search: kEnumerableProperty\x2C\n  searchParams: kEnumerableProperty\x2C\n  hash: kEnumerableProperty\x2C\n  toJSON: kEnumerableProperty\x2C\n});\n\nObjectDefineProperties(URL\x2C {\n  canParse: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    writable: true\x2C\n    enumerable: true\x2C\n  }\x2C\n});\n\nfunction installObjectURLMethods() {\n  const bindingBlob = internalBinding('blob');\n\n  function createObjectURL(obj) {\n    const cryptoRandom = lazyCryptoRandom();\n    if (cryptoRandom === undefined)\n      throw new ERR_NO_CRYPTO();\n\n    const blob = lazyBlob();\n    if (!blob.isBlob(obj))\n      throw new ERR_INVALID_ARG_TYPE('obj'\x2C 'Blob'\x2C obj);\n\n    const id = cryptoRandom.randomUUID();\n\n    bindingBlob.storeDataObject(id\x2C obj[blob.kHandle]\x2C obj.size\x2C obj.type);\n\n    return `blob:nodedata:${id}`;\n  }\n\n  function revokeObjectURL(url) {\n    bindingBlob.revokeObjectURL(`${url}`);\n  }\n\n  ObjectDefineProperties(URL\x2C {\n    createObjectURL: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      enumerable: true\x2C\n      value: createObjectURL\x2C\n    }\x2C\n    revokeObjectURL: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      enumerable: true\x2C\n      value: revokeObjectURL\x2C\n    }\x2C\n  });\n}\n\n// application/x-www-form-urlencoded parser\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-parser\nfunction parseParams(qs) {\n  const out = [];\n  let seenSep = false;\n  let buf = '';\n  let encoded = false;\n  let encodeCheck = 0;\n  let i = qs[0] === '?' ? 1 : 0;\n  let pairStart = i;\n  let lastPos = i;\n  for (; i < qs.length; ++i) {\n    const code = StringPrototypeCharCodeAt(qs\x2C i);\n\n    // Try matching key/value pair separator\n    if (code === CHAR_AMPERSAND) {\n      if (pairStart === i) {\n        // We saw an empty substring between pair separators\n        lastPos = pairStart = i + 1;\n        continue;\n      }\n\n      if (lastPos < i)\n        buf += qs.slice(lastPos\x2C i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n\n      // If `buf` is the key\x2C add an empty value.\n      if (!seenSep)\n        out.push('');\n\n      seenSep = false;\n      buf = '';\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = pairStart = i + 1;\n      continue;\n    }\n\n    // Try matching key/value separator (e.g. '=') if we haven't already\n    if (!seenSep && code === CHAR_EQUAL) {\n      // Key/value separator match!\n      if (lastPos < i)\n        buf += qs.slice(lastPos\x2C i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n\n      seenSep = true;\n      buf = '';\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = i + 1;\n      continue;\n    }\n\n    // Handle + and percent decoding.\n    if (code === CHAR_PLUS) {\n      if (lastPos < i)\n        buf += StringPrototypeSlice(qs\x2C lastPos\x2C i);\n      buf += ' ';\n      lastPos = i + 1;\n    } else if (!encoded) {\n      // Try to match an (valid) encoded byte (once) to minimize unnecessary\n      // calls to string decoding functions\n      if (code === CHAR_PERCENT) {\n        encodeCheck = 1;\n      } else if (encodeCheck > 0) {\n        if (isHexTable[code] === 1) {\n          if (++encodeCheck === 3) {\n            encoded = true;\n          }\n        } else {\n          encodeCheck = 0;\n        }\n      }\n    }\n  }\n\n  // Deal with any leftover key or value data\n\n  // There is a trailing &. No more processing is needed.\n  if (pairStart === i)\n    return out;\n\n  if (lastPos < i)\n    buf += StringPrototypeSlice(qs\x2C lastPos\x2C i);\n  if (encoded)\n    buf = querystring.unescape(buf);\n  ArrayPrototypePush(out\x2C buf);\n\n  // If `buf` is the key\x2C add an empty value.\n  if (!seenSep)\n    ArrayPrototypePush(out\x2C '');\n\n  return out;\n}\n\n// Adapted from querystring's implementation.\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-byte-serializer\nconst noEscape = new Int8Array([\n/*\n  0\x2C 1\x2C 2\x2C 3\x2C 4\x2C 5\x2C 6\x2C 7\x2C 8\x2C 9\x2C A\x2C B\x2C C\x2C D\x2C E\x2C F\n*/\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x00 - 0x0F\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x10 - 0x1F\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 1\x2C 0\x2C 0\x2C 1\x2C 1\x2C 0\x2C // 0x20 - 0x2F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x30 - 0x3F\n  0\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C // 0x40 - 0x4F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 1\x2C // 0x50 - 0x5F\n  0\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C // 0x60 - 0x6F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C  // 0x70 - 0x7F\n]);\n\n// Special version of hexTable that uses `+` for U+0020 SPACE.\nconst paramHexTable = hexTable.slice();\nparamHexTable[0x20] = '+';\n\n// application/x-www-form-urlencoded serializer\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-serializer\nfunction serializeParams(array) {\n  const len = array.length;\n  if (len === 0)\n    return '';\n\n  const firstEncodedParam = encodeStr(array[0]\x2C noEscape\x2C paramHexTable);\n  const firstEncodedValue = encodeStr(array[1]\x2C noEscape\x2C paramHexTable);\n  let output = `${firstEncodedParam}=${firstEncodedValue}`;\n\n  for (let i = 2; i < len; i += 2) {\n    const encodedParam = encodeStr(array[i]\x2C noEscape\x2C paramHexTable);\n    const encodedValue = encodeStr(array[i + 1]\x2C noEscape\x2C paramHexTable);\n    output += `&${encodedParam}=${encodedValue}`;\n  }\n\n  return output;\n}\n\n// for merge sort\nfunction merge(out\x2C start\x2C mid\x2C end\x2C lBuffer\x2C rBuffer) {\n  const sizeLeft = mid - start;\n  const sizeRight = end - mid;\n  let l\x2C r\x2C o;\n\n  for (l = 0; l < sizeLeft; l++)\n    lBuffer[l] = out[start + l];\n  for (r = 0; r < sizeRight; r++)\n    rBuffer[r] = out[mid + r];\n\n  l = 0;\n  r = 0;\n  o = start;\n  while (l < sizeLeft && r < sizeRight) {\n    if (lBuffer[l] <= rBuffer[r]) {\n      out[o++] = lBuffer[l++];\n      out[o++] = lBuffer[l++];\n    } else {\n      out[o++] = rBuffer[r++];\n      out[o++] = rBuffer[r++];\n    }\n  }\n  while (l < sizeLeft)\n    out[o++] = lBuffer[l++];\n  while (r < sizeRight)\n    out[o++] = rBuffer[r++];\n}\n\nfunction domainToASCII(domain) {\n  if (arguments.length < 1)\n    throw new ERR_MISSING_ARGS('domain');\n\n  // toUSVString is not needed.\n  return bindingUrl.domainToASCII(`${domain}`);\n}\n\nfunction domainToUnicode(domain) {\n  if (arguments.length < 1)\n    throw new ERR_MISSING_ARGS('domain');\n\n  // toUSVString is not needed.\n  return bindingUrl.domainToUnicode(`${domain}`);\n}\n\n/**\n * Utility function that converts a URL object into an ordinary options object\n * as expected by the `http.request` and `https.request` APIs.\n * @param {URL} url\n * @returns {Record<string\x2C unknown>}\n */\nfunction urlToHttpOptions(url) {\n  const { hostname\x2C pathname\x2C port\x2C username\x2C password\x2C search } = url;\n  const options = {\n    __proto__: null\x2C\n    ...url\x2C // In case the url object was extended by the user.\n    protocol: url.protocol\x2C\n    hostname: hostname && StringPrototypeStartsWith(hostname\x2C '[') ?\n      StringPrototypeSlice(hostname\x2C 1\x2C -1) :\n      hostname\x2C\n    hash: url.hash\x2C\n    search: search\x2C\n    pathname: pathname\x2C\n    path: `${pathname || ''}${search || ''}`\x2C\n    href: url.href\x2C\n  };\n  if (port !== '') {\n    options.port = Number(port);\n  }\n  if (username || password) {\n    options.auth = `${decodeURIComponent(username)}:${decodeURIComponent(password)}`;\n  }\n  return options;\n}\n\nfunction getPathFromURLWin32(url) {\n  const hostname = url.hostname;\n  let pathname = url.pathname;\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      const third = StringPrototypeCodePointAt(pathname\x2C n + 2) | 0x20;\n      if ((pathname[n + 1] === '2' && third === 102) || // 2f 2F /\n          (pathname[n + 1] === '5' && third === 99)) {  // 5c 5C \\\n        throw new ERR_INVALID_FILE_URL_PATH(\n          'must not include encoded \\\\ or / characters'\x2C\n        );\n      }\n    }\n  }\n  pathname = SideEffectFreeRegExpPrototypeSymbolReplace(FORWARD_SLASH\x2C pathname\x2C '\\\\');\n  pathname = decodeURIComponent(pathname);\n  if (hostname !== '') {\n    // If hostname is set\x2C then we have a UNC path\n    // Pass the hostname through domainToUnicode just in case\n    // it is an IDN using punycode encoding. We do not need to worry\n    // about percent encoding because the URL parser will have\n    // already taken care of that for us. Note that this only\n    // causes IDNs with an appropriate `xn--` prefix to be decoded.\n    return `\\\\\\\\${domainToUnicode(hostname)}${pathname}`;\n  }\n  // Otherwise\x2C it's a local path that requires a drive letter\n  const letter = StringPrototypeCodePointAt(pathname\x2C 1) | 0x20;\n  const sep = StringPrototypeCharAt(pathname\x2C 2);\n  if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z ||   // a..z A..Z\n      (sep !== ':')) {\n    throw new ERR_INVALID_FILE_URL_PATH('must be absolute');\n  }\n  return StringPrototypeSlice(pathname\x2C 1);\n}\n\nfunction getPathFromURLPosix(url) {\n  if (url.hostname !== '') {\n    throw new ERR_INVALID_FILE_URL_HOST(platform);\n  }\n  const pathname = url.pathname;\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      const third = StringPrototypeCodePointAt(pathname\x2C n + 2) | 0x20;\n      if (pathname[n + 1] === '2' && third === 102) {\n        throw new ERR_INVALID_FILE_URL_PATH(\n          'must not include encoded / characters'\x2C\n        );\n      }\n    }\n  }\n  return decodeURIComponent(pathname);\n}\n\nfunction fileURLToPath(path) {\n  if (typeof path === 'string')\n    path = new URL(path);\n  else if (!isURL(path))\n    throw new ERR_INVALID_ARG_TYPE('path'\x2C ['string'\x2C 'URL']\x2C path);\n  if (path.protocol !== 'file:')\n    throw new ERR_INVALID_URL_SCHEME('file');\n  return isWindows ? getPathFromURLWin32(path) : getPathFromURLPosix(path);\n}\n\n// The following characters are percent-encoded when converting from file path\n// to URL:\n// - %: The percent character is the only character not encoded by the\n//        `pathname` setter.\n// - \\: Backslash is encoded on non-windows platforms since it's a valid\n//      character but the `pathname` setters replaces it by a forward slash.\n// - LF: The newline character is stripped out by the `pathname` setter.\n//       (See whatwg/url#419)\n// - CR: The carriage return character is also stripped out by the `pathname`\n//       setter.\n// - TAB: The tab character is also stripped out by the `pathname` setter.\nconst percentRegEx = /%/g;\nconst backslashRegEx = /\\\\/g;\nconst newlineRegEx = /\\n/g;\nconst carriageReturnRegEx = /\\r/g;\nconst tabRegEx = /\\t/g;\nconst questionRegex = /\\?/g;\nconst hashRegex = /#/g;\n\nfunction encodePathChars(filepath) {\n  if (StringPrototypeIndexOf(filepath\x2C '%') !== -1)\n    filepath = RegExpPrototypeSymbolReplace(percentRegEx\x2C filepath\x2C '%25');\n  // In posix\x2C backslash is a valid character in paths:\n  if (!isWindows && StringPrototypeIndexOf(filepath\x2C '\\\\') !== -1)\n    filepath = RegExpPrototypeSymbolReplace(backslashRegEx\x2C filepath\x2C '%5C');\n  if (StringPrototypeIndexOf(filepath\x2C '\\n') !== -1)\n    filepath = RegExpPrototypeSymbolReplace(newlineRegEx\x2C filepath\x2C '%0A');\n  if (StringPrototypeIndexOf(filepath\x2C '\\r') !== -1)\n    filepath = RegExpPrototypeSymbolReplace(carriageReturnRegEx\x2C filepath\x2C '%0D');\n  if (StringPrototypeIndexOf(filepath\x2C '\\t') !== -1)\n    filepath = RegExpPrototypeSymbolReplace(tabRegEx\x2C filepath\x2C '%09');\n  return filepath;\n}\n\nfunction pathToFileURL(filepath) {\n  if (isWindows && StringPrototypeStartsWith(filepath\x2C '\\\\\\\\')) {\n    const outURL = new URL('file://');\n    // UNC path format: \\\\server\\share\\resource\n    const hostnameEndIndex = StringPrototypeIndexOf(filepath\x2C '\\\\'\x2C 2);\n    if (hostnameEndIndex === -1) {\n      throw new ERR_INVALID_ARG_VALUE(\n        'path'\x2C\n        filepath\x2C\n        'Missing UNC resource path'\x2C\n      );\n    }\n    if (hostnameEndIndex === 2) {\n      throw new ERR_INVALID_ARG_VALUE(\n        'path'\x2C\n        filepath\x2C\n        'Empty UNC servername'\x2C\n      );\n    }\n    const hostname = StringPrototypeSlice(filepath\x2C 2\x2C hostnameEndIndex);\n    outURL.hostname = domainToASCII(hostname);\n    outURL.pathname = encodePathChars(\n      RegExpPrototypeSymbolReplace(backslashRegEx\x2C StringPrototypeSlice(filepath\x2C hostnameEndIndex)\x2C '/'));\n    return outURL;\n  }\n  let resolved = path.resolve(filepath);\n  // path.resolve strips trailing slashes so we must add them back\n  const filePathLast = StringPrototypeCharCodeAt(filepath\x2C\n                                                 filepath.length - 1);\n  if ((filePathLast === CHAR_FORWARD_SLASH ||\n       (isWindows && filePathLast === CHAR_BACKWARD_SLASH)) &&\n      resolved[resolved.length - 1] !== path.sep)\n    resolved += '/';\n\n  // Call encodePathChars first to avoid encoding % again for ? and #.\n  resolved = encodePathChars(resolved);\n\n  // Question and hash character should be included in pathname.\n  // Therefore\x2C encoding is required to eliminate parsing them in different states.\n  // This is done as an optimization to not creating a URL instance and\n  // later triggering pathname setter\x2C which impacts performance\n  if (StringPrototypeIndexOf(resolved\x2C '?') !== -1)\n    resolved = RegExpPrototypeSymbolReplace(questionRegex\x2C resolved\x2C '%3F');\n  if (StringPrototypeIndexOf(resolved\x2C '#') !== -1)\n    resolved = RegExpPrototypeSymbolReplace(hashRegex\x2C resolved\x2C '%23');\n  return new URL(`file://${resolved}`);\n}\n\nfunction toPathIfFileURL(fileURLOrPath) {\n  if (!isURL(fileURLOrPath))\n    return fileURLOrPath;\n  return fileURLToPath(fileURLOrPath);\n}\n\n/**\n * This util takes a string containing a URL and return the URL origin\x2C\n * its meant to avoid calls to `new URL` constructor.\n * @param {string} url\n * @returns {URL['origin']}\n */\nfunction getURLOrigin(url) {\n  return bindingUrl.getOrigin(url);\n}\n\nmodule.exports = {\n  toUSVString\x2C\n  fileURLToPath\x2C\n  pathToFileURL\x2C\n  toPathIfFileURL\x2C\n  installObjectURLMethods\x2C\n  URL\x2C\n  URLSearchParams\x2C\n  domainToASCII\x2C\n  domainToUnicode\x2C\n  urlToHttpOptions\x2C\n  encodeStr\x2C\n  isURL\x2C\n\n  urlUpdateActions: updateActions\x2C\n  getURLOrigin\x2C\n  unsafeProtocol\x2C\n  hostlessProtocol\x2C\n  slashedProtocol\x2C\n};\n
code-source-info,0x31e6f6b6e5f6,39,42746,42859,C0O42766C3O42771C9O42797C11O42818C12O42821C15O42828C19O42857,,
tick,0x10c1658ea,67159,0,0x0,3,0x10c9f09d0,0x31e6f6b656a0,0x31e6f6b652e1,0x31e6f6b64bdf,0x31e6f6b62053,0x31e6f6b6075c,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
tick,0x7ff8092cbace,67194,0,0x0,3,0x10c9f09d0,0x31e6f6b656a0,0x31e6f6b652e1,0x31e6f6b64bdf,0x31e6f6b62053,0x31e6f6b6075c,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,67210,0x31e6f6b716a6,45,isURL node:internal/url:755:15,0x31e647c5f568,~
code-source-info,0x31e6f6b716a6,39,21285,21396,C0O21296C12O21315C21O21330C27O21347C34O21374C40O21303C44O21394,,
code-creation,JS,10,67280,0x31e6f6b7182e,81, node:internal/fs/utils:697:38,0x31e647c73b88,~
code-source-info,0x31e6f6b7182e,60,18901,19171,C14O18934C22O18967C25O18967C31O18993C36O19024C49O18999C54O18993C55O19089C68O19089C74O19126C76O19155C78O19155C80O19170,,
code-creation,JS,10,67330,0x31e6f6b71a3e,110, node:internal/fs/utils:366:35,0x31e647c73188,~
code-source-info,0x31e6f6b71a3e,60,8792,9388,C16O8856C21O8909C26O8909C31O9003C37O9026C41O9054C45O9071C51O9071C60O9122C64O9143C69O9143C76O9188C77O9195C78O9215C94O9215C100O9336C104O9358C106O9358C107O9375C109O9386,,
code-creation,JS,10,67370,0x31e6f6b71bb6,16,isUint8Array node:internal/util/types:13:22,0x31e647c44e28,~
script-source,18,node:internal/util/types,'use strict';\n\nconst {\n  ArrayBufferIsView\x2C\n  ObjectDefineProperties\x2C\n  TypedArrayPrototypeGetSymbolToStringTag\x2C\n} = primordials;\n\nfunction isTypedArray(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) !== undefined;\n}\n\nfunction isUint8Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint8Array';\n}\n\nfunction isUint8ClampedArray(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint8ClampedArray';\n}\n\nfunction isUint16Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint16Array';\n}\n\nfunction isUint32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint32Array';\n}\n\nfunction isInt8Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int8Array';\n}\n\nfunction isInt16Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int16Array';\n}\n\nfunction isInt32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int32Array';\n}\n\nfunction isFloat32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Float32Array';\n}\n\nfunction isFloat64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Float64Array';\n}\n\nfunction isBigInt64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'BigInt64Array';\n}\n\nfunction isBigUint64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'BigUint64Array';\n}\n\nmodule.exports = {\n  ...internalBinding('types')\x2C\n  isArrayBufferView: ArrayBufferIsView\x2C\n  isTypedArray\x2C\n  isUint8Array\x2C\n  isUint8ClampedArray\x2C\n  isUint16Array\x2C\n  isUint32Array\x2C\n  isInt8Array\x2C\n  isInt16Array\x2C\n  isInt32Array\x2C\n  isFloat32Array\x2C\n  isFloat64Array\x2C\n  isBigInt64Array\x2C\n  isBigUint64Array\x2C\n};\n\nlet isCryptoKey;\nlet isKeyObject;\n\nObjectDefineProperties(module.exports\x2C {\n  isKeyObject: {\n    __proto__: null\x2C\n    configurable: false\x2C\n    enumerable: true\x2C\n    value(obj) {\n      if (!process.versions.openssl) {\n        return false;\n      }\n\n      if (!isKeyObject) {\n        ({ isKeyObject } = require('internal/crypto/keys'));\n      }\n\n      return isKeyObject(obj);\n    }\x2C\n  }\x2C\n  isCryptoKey: {\n    __proto__: null\x2C\n    configurable: false\x2C\n    enumerable: true\x2C\n    value(obj) {\n      if (!process.versions.openssl) {\n        return false;\n      }\n\n      if (!isCryptoKey) {\n        ({ isCryptoKey } = require('internal/crypto/keys'));\n      }\n\n      return isCryptoKey(obj);\n    }\x2C\n  }\x2C\n});\n
code-source-info,0x31e6f6b71bb6,18,257,342,C0O269C5O276C12O323C15O340,,
tick,0x10cd3260c,67629,0,0x0,0,0x31e6f6b652e1,0x31e6f6b64bdf,0x31e6f6b62053,0x31e6f6b6075c,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,67726,0x31e6f6b7203e,62,splitRoot node:fs:2590:33,0x31e647c6d880,~
code-source-info,0x31e6f6b7203e,55,68426,68618,C0O68451C2O68462C6O68456C11O68483C16O68487C24O68525C26O68521C31O68553C44O68560C49O68592C50O68472C55O68438C59O68603C61O68614,,
code-creation,JS,10,67813,0x31e6f6b72176,20,nextPart node:fs:2623:31,0x31e647c6d920,~
code-source-info,0x31e6f6b72176,55,69333,69391,C0O69346C14O69353C19O69387,,
code-creation,JS,10,68083,0x31e6f6b72286,34,isFileType node:fs:208:20,0x31e647c6bac8,~
code-source-info,0x31e6f6b72286,55,5174,5415,C0O5308C2O5313C6O5320C10O5354C15O5361C20O5377C22O5392C24O5390C30O5400C33O5413,,
code-creation,JS,10,68305,0x31e6f6b7250e,72,encodeRealpathResult node:fs:2599:30,0x31e647c6d8d0,~
code-source-info,0x31e6f6b7250e,55,68652,68910,C0O68674C4O68699C10O68719C17O68728C22O68744C24O68758C25O68778C30O68785C35O68785C41O68813C48O68822C53O68842C55O68858C56O68881C61O68898C66O68881C71O68908,,
code-creation,JS,10,68447,0x31e6f6b727fe,245,Module.load node:internal/modules/cjs/loader:1194:33,0x31e647c771d8,~
code-source-info,0x31e6f6b727fe,63,38021,38862,C0O38036C8O38082C16O38036C21O38090C26O38103C32O38090C36O38114C38O38128C42O38142C45O38162C52O38179C55O38184C60O38184C66O38162C71O38153C75O38225C78O38225C83O38302C91O38306C101O38359C106O38370C112O38386C124O38392C129O38386C130O38436C133O38443C140O38454C144O38465C150O38485C151O38497C155O38531C160O38531C164O38643C169O38678C174O38689C186O38729C191O38736C196O38736C203O38750C205O38748C210O38787C215O38796C220O38796C227O38828C232O38837C237O38837C244O38861,,
code-creation,JS,10,68596,0x31e6f6b72bbe,99,findLongestRegisteredExtension node:internal/modules/cjs/loader:502:40,0x31e647c76c08,~
code-source-info,0x31e6f6b72bbe,63,14608,15045,C0O14636C5O14641C10O14641C16O14667C18O14691C20O14717C22O14785C36O14738C44O14785C49O14799C51O14818C55O14827C56O14837C61O14846C63O14895C68O14914C74O14953C77O14964C84O14975C89O14997C91O15021C92O14722C96O15030C98O15043,,
tick,0x7ff8092cbace,68651,0,0x0,3,0x10c9f09d0,0x31e6f6b7284c,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,68707,0x31e6f6b72dd6,355,basename node:path:1309:11,0x31e647c5b8b0,~
code-source-info,0x31e6f6b72dd6,34,39650,42069,C0O39671C4O39703C12O39703C17O39738C25O39738C30O39785C32O39802C35O39829C37O39840C41O39875C47O39882C52O39896C57O39911C61O39903C66O39927C68O39938C73O39956C75O39966C76O39993C80O40000C84O40034C87O40062C91O40069C95O40076C96O40076C101O40110C106O40110C112O40154C114O40167C116O40163C121O40337C125O40370C127O40380C131O40397C135O40443C137O40464C142O40630C144O40664C146O40685C150O40712C151O40723C156O40794C158O40807C161O40807C166O40803C171O40866C178O40879C183O41015C190O41178C193O41205C198O40084C203O40044C207O41280C209O41290C214O41307C221O41342C223O41350C228O41377C233O41391C247O41398C252O41437C253O41466C257O41473C261O41480C262O41480C267O41499C272O41503C280O41542C282O41538C287O41706C291O41737C293O41747C297O41762C301O41792C303O41800C308O41920C310O41950C312O41958C316O41488C321O41448C325O41982C327O41990C332O42004C334O42014C335O42019C349O42026C354O42065,,
code-creation,JS,10,68975,0x31e6f6b733ce,494,Module._extensions..js node:internal/modules/cjs/loader:1389:37,0x31e647c773e0,~
code-source-info,0x31e6f6b733ce,63,44948,46869,C0O45047C5O45061C10O45061C16O45080C18O45091C25O45101C34O45134C39O45146C40O45160C46O45188C51O45201C60O45201C67O45239C76O45243C83O45303C88O45321C93O45321C105O45441C112O45445C122O45452C127O45600C132O45618C137O45618C143O45656C146O45662C154O45704C159O45709C164O45721C174O45709C181O45766C186O45766C192O45825C211O45825C217O45996C220O46007C227O46013C232O46041C237O46079C243O46097C252O46097C262O46092C265O46210C269O46256C276O46290C279O46315C287O46322C291O46364C301O46322C308O46290C322O46256C329O46392C333O46449C344O46449C357O46418C364O46427C368O46512C374O46524C376O46559C385O46559C393O46605C396O46599C400O46637C412O46654C425O46663C438O46690C447O46721C452O46690C468O46744C473O46744C478O46809C480O46809C481O46839C486O46839C493O46868,,
code-creation,JS,10,69177,0x31e6f6b73866,472,readFileSync node:fs:446:22,0x31e647c6bf28,~
code-source-info,0x31e6f6b73866,55,11323,12941,C0O11343C5O11364C10O11353C17O11404C24O11413C29O11435C36O11444C41O11463C46O11468C52O11491C57O11509C64O11526C67O11526C72O11509C79O11561C84O11576C91O11595C94O11617C99O11595C104O11576C110O11624C111O11649C116O11649C121O11703C129O11721C132O11724C137O11747C150O11724C156O11778C159O11778C165O11820C170O11838C173O11820C182O11854C189O11875C191O11884C193O11930C195O11975C196O11984C201O11997C206O12026C218O12035C224O12083C226O12097C227O12106C232O12130C237O12186C253O12142C259O12200C261O12207C268O12247C269O12241C276O12254C281O12119C287O12378C292O12394C302O12394C308O12419C327O12431C333O12481C334O12495C339O12512C344O12547C351O12547C358O12512C363O12583C365O12590C372O12624C373O12624C378O12278C382O12639C386O12658C391O12661C396O12661C401O12679C402O12688C407O12750C412O12766C417O12766C426O12797C428O12805C433O12835C440O12835C447O12869C453O12895C458O12912C463O12895C469O12925C471O12939,,
code-creation,JS,10,69527,0x31e6f6b74016,30,isEncoding node:buffer:569:40,0x31e647c4ffd8,~
script-source,24,node:buffer,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  Array\x2C\n  ArrayFrom\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeIndexOf\x2C\n  MathFloor\x2C\n  MathMin\x2C\n  MathTrunc\x2C\n  NumberIsNaN\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  NumberMIN_SAFE_INTEGER\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeTrim\x2C\n  SymbolSpecies\x2C\n  SymbolToPrimitive\x2C\n  TypedArrayPrototypeGetBuffer\x2C\n  TypedArrayPrototypeGetByteLength\x2C\n  TypedArrayPrototypeGetByteOffset\x2C\n  TypedArrayPrototypeFill\x2C\n  TypedArrayPrototypeGetLength\x2C\n  TypedArrayPrototypeSet\x2C\n  TypedArrayPrototypeSlice\x2C\n  Uint8Array\x2C\n  Uint8ArrayPrototype\x2C\n} = primordials;\n\nconst {\n  byteLengthUtf8\x2C\n  compare: _compare\x2C\n  compareOffset\x2C\n  createFromString\x2C\n  fill: bindingFill\x2C\n  isAscii: bindingIsAscii\x2C\n  isUtf8: bindingIsUtf8\x2C\n  indexOfBuffer\x2C\n  indexOfNumber\x2C\n  indexOfString\x2C\n  swap16: _swap16\x2C\n  swap32: _swap32\x2C\n  swap64: _swap64\x2C\n  kMaxLength\x2C\n  kStringMaxLength\x2C\n} = internalBinding('buffer');\nconst {\n  constants: {\n    ALL_PROPERTIES\x2C\n    ONLY_ENUMERABLE\x2C\n  }\x2C\n  getOwnNonIndexProperties\x2C\n} = internalBinding('util');\nconst {\n  customInspectSymbol\x2C\n  isInsideNodeModules\x2C\n  lazyDOMException\x2C\n  normalizeEncoding\x2C\n  kIsEncodingSymbol\x2C\n  defineLazyProperties\x2C\n} = require('internal/util');\nconst {\n  isAnyArrayBuffer\x2C\n  isArrayBufferView\x2C\n  isUint8Array\x2C\n  isTypedArray\x2C\n} = require('internal/util/types');\nconst {\n  inspect: utilInspect\x2C\n} = require('internal/util/inspect');\nconst { encodings } = internalBinding('string_decoder');\n\nconst {\n  codes: {\n    ERR_BUFFER_OUT_OF_BOUNDS\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_BUFFER_SIZE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_UNKNOWN_ENCODING\x2C\n  }\x2C\n  genericNodeError\x2C\n  hideStackFrames\x2C\n} = require('internal/errors');\nconst {\n  validateArray\x2C\n  validateBuffer\x2C\n  validateInteger\x2C\n  validateNumber\x2C\n  validateString\x2C\n} = require('internal/validators');\n// Provide validateInteger() but with kMaxLength as the default maximum value.\nconst validateOffset = (value\x2C name\x2C min = 0\x2C max = kMaxLength) =>\n  validateInteger(value\x2C name\x2C min\x2C max);\n\nconst {\n  FastBuffer\x2C\n  markAsUntransferable\x2C\n  addBufferPrototypeMethods\x2C\n  createUnsafeBuffer\x2C\n} = require('internal/buffer');\n\nFastBuffer.prototype.constructor = Buffer;\nBuffer.prototype = FastBuffer.prototype;\naddBufferPrototypeMethods(Buffer.prototype);\n\nconst constants = ObjectDefineProperties({}\x2C {\n  MAX_LENGTH: {\n    __proto__: null\x2C\n    value: kMaxLength\x2C\n    writable: false\x2C\n    enumerable: true\x2C\n  }\x2C\n  MAX_STRING_LENGTH: {\n    __proto__: null\x2C\n    value: kStringMaxLength\x2C\n    writable: false\x2C\n    enumerable: true\x2C\n  }\x2C\n});\n\nBuffer.poolSize = 8 * 1024;\nlet poolSize\x2C poolOffset\x2C allocPool;\n\nconst encodingsMap = { __proto__: null };\nfor (let i = 0; i < encodings.length; ++i)\n  encodingsMap[encodings[i]] = i;\n\nfunction createPool() {\n  poolSize = Buffer.poolSize;\n  allocPool = createUnsafeBuffer(poolSize).buffer;\n  markAsUntransferable(allocPool);\n  poolOffset = 0;\n}\ncreatePool();\n\nfunction alignPool() {\n  // Ensure aligned slices\n  if (poolOffset & 0x7) {\n    poolOffset |= 0x7;\n    poolOffset++;\n  }\n}\n\nlet bufferWarningAlreadyEmitted = false;\nlet nodeModulesCheckCounter = 0;\nconst bufferWarning = 'Buffer() is deprecated due to security and usability ' +\n                      'issues. Please use the Buffer.alloc()\x2C ' +\n                      'Buffer.allocUnsafe()\x2C or Buffer.from() methods instead.';\n\nfunction showFlaggedDeprecation() {\n  if (bufferWarningAlreadyEmitted ||\n      ++nodeModulesCheckCounter > 10000 ||\n      (!require('internal/options').getOptionValue('--pending-deprecation') &&\n       isInsideNodeModules())) {\n    // We don't emit a warning\x2C because we either:\n    // - Already did so\x2C or\n    // - Already checked too many times whether a call is coming\n    //   from node_modules and want to stop slowing down things\x2C or\n    // - We aren't running with `--pending-deprecation` enabled\x2C\n    //   and the code is inside `node_modules`.\n    return;\n  }\n\n  process.emitWarning(bufferWarning\x2C 'DeprecationWarning'\x2C 'DEP0005');\n  bufferWarningAlreadyEmitted = true;\n}\n\nfunction toInteger(n\x2C defaultVal) {\n  n = +n;\n  if (!NumberIsNaN(n) &&\n      n >= NumberMIN_SAFE_INTEGER &&\n      n <= NumberMAX_SAFE_INTEGER) {\n    return ((n % 1) === 0 ? n : MathFloor(n));\n  }\n  return defaultVal;\n}\n\nfunction _copy(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n  if (!isUint8Array(source))\n    throw new ERR_INVALID_ARG_TYPE('source'\x2C ['Buffer'\x2C 'Uint8Array']\x2C source);\n  if (!isUint8Array(target))\n    throw new ERR_INVALID_ARG_TYPE('target'\x2C ['Buffer'\x2C 'Uint8Array']\x2C target);\n\n  if (targetStart === undefined) {\n    targetStart = 0;\n  } else {\n    targetStart = toInteger(targetStart\x2C 0);\n    if (targetStart < 0)\n      throw new ERR_OUT_OF_RANGE('targetStart'\x2C '>= 0'\x2C targetStart);\n  }\n\n  if (sourceStart === undefined) {\n    sourceStart = 0;\n  } else {\n    sourceStart = toInteger(sourceStart\x2C 0);\n    if (sourceStart < 0 || sourceStart > source.length)\n      throw new ERR_OUT_OF_RANGE('sourceStart'\x2C `>= 0 && <= ${source.length}`\x2C sourceStart);\n  }\n\n  if (sourceEnd === undefined) {\n    sourceEnd = source.length;\n  } else {\n    sourceEnd = toInteger(sourceEnd\x2C 0);\n    if (sourceEnd < 0)\n      throw new ERR_OUT_OF_RANGE('sourceEnd'\x2C '>= 0'\x2C sourceEnd);\n  }\n\n  if (targetStart >= target.length || sourceStart >= sourceEnd)\n    return 0;\n\n  return _copyActual(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd);\n}\n\nfunction _copyActual(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n  if (sourceEnd - sourceStart > target.length - targetStart)\n    sourceEnd = sourceStart + target.length - targetStart;\n\n  let nb = sourceEnd - sourceStart;\n  const sourceLen = source.length - sourceStart;\n  if (nb > sourceLen)\n    nb = sourceLen;\n\n  if (sourceStart !== 0 || sourceEnd < source.length)\n    source = new Uint8Array(source.buffer\x2C source.byteOffset + sourceStart\x2C nb);\n\n  TypedArrayPrototypeSet(target\x2C source\x2C targetStart);\n\n  return nb;\n}\n\n/**\n * The Buffer() constructor is deprecated in documentation and should not be\n * used moving forward. Rather\x2C developers should use one of the three new\n * factory APIs: Buffer.from()\x2C Buffer.allocUnsafe() or Buffer.alloc() based on\n * their specific needs. There is no runtime deprecation because of the extent\n * to which the Buffer constructor is used in the ecosystem currently -- a\n * runtime deprecation would introduce too much breakage at this time. It's not\n * likely that the Buffer constructors would ever actually be removed.\n * Deprecation Code: DEP0005\n */\nfunction Buffer(arg\x2C encodingOrOffset\x2C length) {\n  showFlaggedDeprecation();\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new ERR_INVALID_ARG_TYPE('string'\x2C 'string'\x2C arg);\n    }\n    return Buffer.alloc(arg);\n  }\n  return Buffer.from(arg\x2C encodingOrOffset\x2C length);\n}\n\nObjectDefineProperty(Buffer\x2C SymbolSpecies\x2C {\n  __proto__: null\x2C\n  enumerable: false\x2C\n  configurable: true\x2C\n  get() { return FastBuffer; }\x2C\n});\n\n/**\n * Functionally equivalent to Buffer(arg\x2C encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[\x2C encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[\x2C byteOffset[\x2C length]])\n */\nBuffer.from = function from(value\x2C encodingOrOffset\x2C length) {\n  if (typeof value === 'string')\n    return fromString(value\x2C encodingOrOffset);\n\n  if (typeof value === 'object' && value !== null) {\n    if (isAnyArrayBuffer(value))\n      return fromArrayBuffer(value\x2C encodingOrOffset\x2C length);\n\n    const valueOf = value.valueOf && value.valueOf();\n    if (valueOf != null &&\n        valueOf !== value &&\n        (typeof valueOf === 'string' || typeof valueOf === 'object')) {\n      return from(valueOf\x2C encodingOrOffset\x2C length);\n    }\n\n    const b = fromObject(value);\n    if (b)\n      return b;\n\n    if (typeof value[SymbolToPrimitive] === 'function') {\n      const primitive = value[SymbolToPrimitive]('string');\n      if (typeof primitive === 'string') {\n        return fromString(primitive\x2C encodingOrOffset);\n      }\n    }\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'first argument'\x2C\n    ['string'\x2C 'Buffer'\x2C 'ArrayBuffer'\x2C 'Array'\x2C 'Array-like Object']\x2C\n    value\x2C\n  );\n};\n\n/**\n * Creates the Buffer as a copy of the underlying ArrayBuffer of the view\n * rather than the contents of the view.\n * @param {TypedArray} view\n * @param {number} [offset]\n * @param {number} [length]\n * @returns {Buffer}\n */\nBuffer.copyBytesFrom = function copyBytesFrom(view\x2C offset\x2C length) {\n  if (!isTypedArray(view)) {\n    throw new ERR_INVALID_ARG_TYPE('view'\x2C [ 'TypedArray' ]\x2C view);\n  }\n\n  const viewLength = TypedArrayPrototypeGetLength(view);\n  if (viewLength === 0) {\n    return Buffer.alloc(0);\n  }\n\n  if (offset !== undefined || length !== undefined) {\n    if (offset !== undefined) {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n      if (offset >= viewLength) return Buffer.alloc(0);\n    } else {\n      offset = 0;\n    }\n    let end;\n    if (length !== undefined) {\n      validateInteger(length\x2C 'length'\x2C 0);\n      end = offset + length;\n    } else {\n      end = viewLength;\n    }\n\n    view = TypedArrayPrototypeSlice(view\x2C offset\x2C end);\n  }\n\n  return fromArrayLike(new Uint8Array(\n    TypedArrayPrototypeGetBuffer(view)\x2C\n    TypedArrayPrototypeGetByteOffset(view)\x2C\n    TypedArrayPrototypeGetByteLength(view)));\n};\n\n// Identical to the built-in %TypedArray%.of()\x2C but avoids using the deprecated\n// Buffer() constructor. Must use arrow function syntax to avoid automatically\n// adding a `prototype` property and making the function a constructor.\n//\n// Refs: https://tc39.github.io/ecma262/#sec-%typedarray%.of\n// Refs: https://esdiscuss.org/topic/isconstructor#content-11\nconst of = (...items) => {\n  const newObj = createUnsafeBuffer(items.length);\n  for (let k = 0; k < items.length; k++)\n    newObj[k] = items[k];\n  return newObj;\n};\nBuffer.of = of;\n\nObjectSetPrototypeOf(Buffer\x2C Uint8Array);\n\n// The 'assertSize' method will remove itself from the callstack when an error\n// occurs. This is done simply to keep the internal details of the\n// implementation from bleeding out to users.\nconst assertSize = hideStackFrames((size) => {\n  validateNumber(size\x2C 'size'\x2C 0\x2C kMaxLength);\n});\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[\x2C fill[\x2C encoding]])\n */\nBuffer.alloc = function alloc(size\x2C fill\x2C encoding) {\n  assertSize(size);\n  if (fill !== undefined && fill !== 0 && size > 0) {\n    const buf = createUnsafeBuffer(size);\n    return _fill(buf\x2C fill\x2C 0\x2C buf.length\x2C encoding);\n  }\n  return new FastBuffer(size);\n};\n\n/**\n * Equivalent to Buffer(num)\x2C by default creates a non-zero-filled Buffer\n * instance. If `--zero-fill-buffers` is set\x2C will zero-fill the buffer.\n */\nBuffer.allocUnsafe = function allocUnsafe(size) {\n  assertSize(size);\n  return allocate(size);\n};\n\n/**\n * Equivalent to SlowBuffer(num)\x2C by default creates a non-zero-filled\n * Buffer instance that is not allocated off the pre-initialized pool.\n * If `--zero-fill-buffers` is set\x2C will zero-fill the buffer.\n */\nBuffer.allocUnsafeSlow = function allocUnsafeSlow(size) {\n  assertSize(size);\n  return createUnsafeBuffer(size);\n};\n\n// If --zero-fill-buffers command line argument is set\x2C a zero-filled\n// buffer is returned.\nfunction SlowBuffer(length) {\n  assertSize(length);\n  return createUnsafeBuffer(length);\n}\n\nObjectSetPrototypeOf(SlowBuffer.prototype\x2C Uint8ArrayPrototype);\nObjectSetPrototypeOf(SlowBuffer\x2C Uint8Array);\n\nfunction allocate(size) {\n  if (size <= 0) {\n    return new FastBuffer();\n  }\n  if (size < (Buffer.poolSize >>> 1)) {\n    if (size > (poolSize - poolOffset))\n      createPool();\n    const b = new FastBuffer(allocPool\x2C poolOffset\x2C size);\n    poolOffset += size;\n    alignPool();\n    return b;\n  }\n  return createUnsafeBuffer(size);\n}\n\nfunction fromStringFast(string\x2C ops) {\n  const length = ops.byteLength(string);\n\n  if (length >= (Buffer.poolSize >>> 1))\n    return createFromString(string\x2C ops.encodingVal);\n\n  if (length > (poolSize - poolOffset))\n    createPool();\n  let b = new FastBuffer(allocPool\x2C poolOffset\x2C length);\n  const actual = ops.write(b\x2C string\x2C 0\x2C length);\n  if (actual !== length) {\n    // byteLength() may overestimate. That's a rare case\x2C though.\n    b = new FastBuffer(allocPool\x2C poolOffset\x2C actual);\n  }\n  poolOffset += actual;\n  alignPool();\n  return b;\n}\n\nfunction fromString(string\x2C encoding) {\n  let ops;\n  if (typeof encoding !== 'string' || encoding.length === 0) {\n    if (string.length === 0)\n      return new FastBuffer();\n    ops = encodingOps.utf8;\n  } else {\n    ops = getEncodingOps(encoding);\n    if (ops === undefined)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    if (string.length === 0)\n      return new FastBuffer();\n  }\n  return fromStringFast(string\x2C ops);\n}\n\nfunction fromArrayBuffer(obj\x2C byteOffset\x2C length) {\n  // Convert byteOffset to integer\n  if (byteOffset === undefined) {\n    byteOffset = 0;\n  } else {\n    byteOffset = +byteOffset;\n    if (NumberIsNaN(byteOffset))\n      byteOffset = 0;\n  }\n\n  const maxLength = obj.byteLength - byteOffset;\n\n  if (maxLength < 0)\n    throw new ERR_BUFFER_OUT_OF_BOUNDS('offset');\n\n  if (length === undefined) {\n    length = maxLength;\n  } else {\n    // Convert length to non-negative integer.\n    length = +length;\n    if (length > 0) {\n      if (length > maxLength)\n        throw new ERR_BUFFER_OUT_OF_BOUNDS('length');\n    } else {\n      length = 0;\n    }\n  }\n\n  return new FastBuffer(obj\x2C byteOffset\x2C length);\n}\n\nfunction fromArrayLike(obj) {\n  if (obj.length <= 0)\n    return new FastBuffer();\n  if (obj.length < (Buffer.poolSize >>> 1)) {\n    if (obj.length > (poolSize - poolOffset))\n      createPool();\n    const b = new FastBuffer(allocPool\x2C poolOffset\x2C obj.length);\n    TypedArrayPrototypeSet(b\x2C obj\x2C 0);\n    poolOffset += obj.length;\n    alignPool();\n    return b;\n  }\n  return new FastBuffer(obj);\n}\n\nfunction fromObject(obj) {\n  if (obj.length !== undefined || isAnyArrayBuffer(obj.buffer)) {\n    if (typeof obj.length !== 'number') {\n      return new FastBuffer();\n    }\n    return fromArrayLike(obj);\n  }\n\n  if (obj.type === 'Buffer' && ArrayIsArray(obj.data)) {\n    return fromArrayLike(obj.data);\n  }\n}\n\n// Static methods\n\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer;\n};\n\nBuffer.compare = function compare(buf1\x2C buf2) {\n  if (!isUint8Array(buf1)) {\n    throw new ERR_INVALID_ARG_TYPE('buf1'\x2C ['Buffer'\x2C 'Uint8Array']\x2C buf1);\n  }\n\n  if (!isUint8Array(buf2)) {\n    throw new ERR_INVALID_ARG_TYPE('buf2'\x2C ['Buffer'\x2C 'Uint8Array']\x2C buf2);\n  }\n\n  if (buf1 === buf2) {\n    return 0;\n  }\n\n  return _compare(buf1\x2C buf2);\n};\n\nBuffer.isEncoding = function isEncoding(encoding) {\n  return typeof encoding === 'string' && encoding.length !== 0 &&\n         normalizeEncoding(encoding) !== undefined;\n};\nBuffer[kIsEncodingSymbol] = Buffer.isEncoding;\n\nBuffer.concat = function concat(list\x2C length) {\n  validateArray(list\x2C 'list');\n\n  if (list.length === 0)\n    return new FastBuffer();\n\n  if (length === undefined) {\n    length = 0;\n    for (let i = 0; i < list.length; i++) {\n      if (list[i].length) {\n        length += list[i].length;\n      }\n    }\n  } else {\n    validateOffset(length\x2C 'length');\n  }\n\n  const buffer = Buffer.allocUnsafe(length);\n  let pos = 0;\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    if (!isUint8Array(buf)) {\n      // TODO(BridgeAR): This should not be of type ERR_INVALID_ARG_TYPE.\n      // Instead\x2C find the proper error code for this.\n      throw new ERR_INVALID_ARG_TYPE(\n        `list[${i}]`\x2C ['Buffer'\x2C 'Uint8Array']\x2C list[i]);\n    }\n    pos += _copyActual(buf\x2C buffer\x2C pos\x2C 0\x2C buf.length);\n  }\n\n  // Note: `length` is always equal to `buffer.length` at this point\n  if (pos < length) {\n    // Zero-fill the remaining bytes if the specified `length` was more than\n    // the actual total length\x2C i.e. if we have some remaining allocated bytes\n    // there were not initialized.\n    TypedArrayPrototypeFill(buffer\x2C 0\x2C pos\x2C length);\n  }\n\n  return buffer;\n};\n\nfunction base64ByteLength(str\x2C bytes) {\n  // Handle padding\n  if (StringPrototypeCharCodeAt(str\x2C bytes - 1) === 0x3D)\n    bytes--;\n  if (bytes > 1 && StringPrototypeCharCodeAt(str\x2C bytes - 1) === 0x3D)\n    bytes--;\n\n  // Base64 ratio: 3/4\n  return (bytes * 3) >>> 2;\n}\n\nconst encodingOps = {\n  utf8: {\n    encoding: 'utf8'\x2C\n    encodingVal: encodingsMap.utf8\x2C\n    byteLength: byteLengthUtf8\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.utf8Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.utf8Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf8\x2C dir)\x2C\n  }\x2C\n  ucs2: {\n    encoding: 'ucs2'\x2C\n    encodingVal: encodingsMap.utf16le\x2C\n    byteLength: (string) => string.length * 2\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.ucs2Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.ucs2Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf16le\x2C dir)\x2C\n  }\x2C\n  utf16le: {\n    encoding: 'utf16le'\x2C\n    encodingVal: encodingsMap.utf16le\x2C\n    byteLength: (string) => string.length * 2\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.ucs2Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.ucs2Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf16le\x2C dir)\x2C\n  }\x2C\n  latin1: {\n    encoding: 'latin1'\x2C\n    encodingVal: encodingsMap.latin1\x2C\n    byteLength: (string) => string.length\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.latin1Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.latin1Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.latin1\x2C dir)\x2C\n  }\x2C\n  ascii: {\n    encoding: 'ascii'\x2C\n    encodingVal: encodingsMap.ascii\x2C\n    byteLength: (string) => string.length\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.asciiWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.asciiSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.ascii)\x2C\n                    byteOffset\x2C\n                    encodingsMap.ascii\x2C\n                    dir)\x2C\n  }\x2C\n  base64: {\n    encoding: 'base64'\x2C\n    encodingVal: encodingsMap.base64\x2C\n    byteLength: (string) => base64ByteLength(string\x2C string.length)\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.base64Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.base64Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.base64)\x2C\n                    byteOffset\x2C\n                    encodingsMap.base64\x2C\n                    dir)\x2C\n  }\x2C\n  base64url: {\n    encoding: 'base64url'\x2C\n    encodingVal: encodingsMap.base64url\x2C\n    byteLength: (string) => base64ByteLength(string\x2C string.length)\x2C\n    write: (buf\x2C string\x2C offset\x2C len) =>\n      buf.base64urlWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.base64urlSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.base64url)\x2C\n                    byteOffset\x2C\n                    encodingsMap.base64url\x2C\n                    dir)\x2C\n  }\x2C\n  hex: {\n    encoding: 'hex'\x2C\n    encodingVal: encodingsMap.hex\x2C\n    byteLength: (string) => string.length >>> 1\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.hexWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.hexSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.hex)\x2C\n                    byteOffset\x2C\n                    encodingsMap.hex\x2C\n                    dir)\x2C\n  }\x2C\n};\nfunction getEncodingOps(encoding) {\n  encoding += '';\n  switch (encoding.length) {\n    case 4:\n      if (encoding === 'utf8') return encodingOps.utf8;\n      if (encoding === 'ucs2') return encodingOps.ucs2;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'utf8') return encodingOps.utf8;\n      if (encoding === 'ucs2') return encodingOps.ucs2;\n      break;\n    case 5:\n      if (encoding === 'utf-8') return encodingOps.utf8;\n      if (encoding === 'ascii') return encodingOps.ascii;\n      if (encoding === 'ucs-2') return encodingOps.ucs2;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'utf-8') return encodingOps.utf8;\n      if (encoding === 'ascii') return encodingOps.ascii;\n      if (encoding === 'ucs-2') return encodingOps.ucs2;\n      break;\n    case 7:\n      if (encoding === 'utf16le' ||\n          StringPrototypeToLowerCase(encoding) === 'utf16le')\n        return encodingOps.utf16le;\n      break;\n    case 8:\n      if (encoding === 'utf-16le' ||\n          StringPrototypeToLowerCase(encoding) === 'utf-16le')\n        return encodingOps.utf16le;\n      break;\n    case 6:\n      if (encoding === 'latin1' || encoding === 'binary')\n        return encodingOps.latin1;\n      if (encoding === 'base64') return encodingOps.base64;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'latin1' || encoding === 'binary')\n        return encodingOps.latin1;\n      if (encoding === 'base64') return encodingOps.base64;\n      break;\n    case 3:\n      if (encoding === 'hex' || StringPrototypeToLowerCase(encoding) === 'hex')\n        return encodingOps.hex;\n      break;\n    case 9:\n      if (encoding === 'base64url' ||\n          StringPrototypeToLowerCase(encoding) === 'base64url')\n        return encodingOps.base64url;\n      break;\n  }\n}\n\nfunction byteLength(string\x2C encoding) {\n  if (typeof string !== 'string') {\n    if (isArrayBufferView(string) || isAnyArrayBuffer(string)) {\n      return string.byteLength;\n    }\n\n    throw new ERR_INVALID_ARG_TYPE(\n      'string'\x2C ['string'\x2C 'Buffer'\x2C 'ArrayBuffer']\x2C string\x2C\n    );\n  }\n\n  const len = string.length;\n  if (len === 0)\n    return 0;\n\n  if (encoding) {\n    const ops = getEncodingOps(encoding);\n    if (ops) {\n      return ops.byteLength(string);\n    }\n  }\n  return byteLengthUtf8(string);\n}\n\nBuffer.byteLength = byteLength;\n\n// For backwards compatibility.\nObjectDefineProperty(Buffer.prototype\x2C 'parent'\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  get() {\n    if (!(this instanceof Buffer))\n      return undefined;\n    return this.buffer;\n  }\x2C\n});\nObjectDefineProperty(Buffer.prototype\x2C 'offset'\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  get() {\n    if (!(this instanceof Buffer))\n      return undefined;\n    return this.byteOffset;\n  }\x2C\n});\n\nBuffer.prototype.copy =\n  function copy(target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n    return _copy(this\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd);\n  };\n\n// No need to verify that "buf.length <= MAX_UINT32" since it's a read-only\n// property of a typed array.\n// This behaves neither like String nor Uint8Array in that we set start/end\n// to their upper/lower bounds if the value passed is out of range.\nBuffer.prototype.toString = function toString(encoding\x2C start\x2C end) {\n  if (arguments.length === 0) {\n    return this.utf8Slice(0\x2C this.length);\n  }\n\n  const len = this.length;\n\n  if (start <= 0)\n    start = 0;\n  else if (start >= len)\n    return '';\n  else\n    start |= 0;\n\n  if (end === undefined || end > len)\n    end = len;\n  else\n    end |= 0;\n\n  if (end <= start)\n    return '';\n\n  if (encoding === undefined)\n    return this.utf8Slice(start\x2C end);\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n\n  return ops.slice(this\x2C start\x2C end);\n};\n\nBuffer.prototype.equals = function equals(otherBuffer) {\n  if (!isUint8Array(otherBuffer)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'otherBuffer'\x2C ['Buffer'\x2C 'Uint8Array']\x2C otherBuffer);\n  }\n\n  if (this === otherBuffer)\n    return true;\n  const len = TypedArrayPrototypeGetByteLength(this);\n  if (len !== TypedArrayPrototypeGetByteLength(otherBuffer))\n    return false;\n\n  return len === 0 || _compare(this\x2C otherBuffer) === 0;\n};\n\nlet INSPECT_MAX_BYTES = 50;\n// Override how buffers are presented by util.inspect().\nBuffer.prototype[customInspectSymbol] = function inspect(recurseTimes\x2C ctx) {\n  const max = INSPECT_MAX_BYTES;\n  const actualMax = MathMin(max\x2C this.length);\n  const remaining = this.length - max;\n  let str = StringPrototypeTrim(RegExpPrototypeSymbolReplace(\n    /(.{2})/g\x2C this.hexSlice(0\x2C actualMax)\x2C '$1 '));\n  if (remaining > 0)\n    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n  // Inspect special properties as well\x2C if possible.\n  if (ctx) {\n    let extras = false;\n    const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\n    const obj = { __proto__: null };\n    ArrayPrototypeForEach(getOwnNonIndexProperties(this\x2C filter)\x2C\n                          (key) => {\n                            extras = true;\n                            obj[key] = this[key];\n                          });\n    if (extras) {\n      if (this.length !== 0)\n        str += '\x2C ';\n      // '[Object: null prototype] {'.length === 26\n      // This is guarded with a test.\n      str += StringPrototypeSlice(utilInspect(obj\x2C {\n        ...ctx\x2C\n        breakLength: Infinity\x2C\n        compact: true\x2C\n      })\x2C 27\x2C -2);\n    }\n  }\n  return `<${this.constructor.name} ${str}>`;\n};\nBuffer.prototype.inspect = Buffer.prototype[customInspectSymbol];\n\nBuffer.prototype.compare = function compare(target\x2C\n                                            targetStart\x2C\n                                            targetEnd\x2C\n                                            sourceStart\x2C\n                                            sourceEnd) {\n  if (!isUint8Array(target)) {\n    throw new ERR_INVALID_ARG_TYPE('target'\x2C ['Buffer'\x2C 'Uint8Array']\x2C target);\n  }\n  if (arguments.length === 1)\n    return _compare(this\x2C target);\n\n  if (targetStart === undefined)\n    targetStart = 0;\n  else\n    validateOffset(targetStart\x2C 'targetStart');\n\n  if (targetEnd === undefined)\n    targetEnd = target.length;\n  else\n    validateOffset(targetEnd\x2C 'targetEnd'\x2C 0\x2C target.length);\n\n  if (sourceStart === undefined)\n    sourceStart = 0;\n  else\n    validateOffset(sourceStart\x2C 'sourceStart');\n\n  if (sourceEnd === undefined)\n    sourceEnd = this.length;\n  else\n    validateOffset(sourceEnd\x2C 'sourceEnd'\x2C 0\x2C this.length);\n\n  if (sourceStart >= sourceEnd)\n    return (targetStart >= targetEnd ? 0 : -1);\n  if (targetStart >= targetEnd)\n    return 1;\n\n  return compareOffset(this\x2C target\x2C targetStart\x2C sourceStart\x2C targetEnd\x2C\n                       sourceEnd);\n};\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`\x2C\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string\x2C Buffer\x2C or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding\x2C relevant if val is a string\n// - dir - true for indexOf\x2C false for lastIndexOf\nfunction bidirectionalIndexOf(buffer\x2C val\x2C byteOffset\x2C encoding\x2C dir) {\n  validateBuffer(buffer);\n\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = undefined;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  // Coerce to Number. Values like null and [] become 0.\n  byteOffset = +byteOffset;\n  // If the offset is undefined\x2C "foo"\x2C {}\x2C coerces to NaN\x2C search whole buffer.\n  if (NumberIsNaN(byteOffset)) {\n    byteOffset = dir ? 0 : (buffer.length || buffer.byteLength);\n  }\n  dir = !!dir;  // Cast to bool.\n\n  if (typeof val === 'number')\n    return indexOfNumber(buffer\x2C val >>> 0\x2C byteOffset\x2C dir);\n\n  let ops;\n  if (encoding === undefined)\n    ops = encodingOps.utf8;\n  else\n    ops = getEncodingOps(encoding);\n\n  if (typeof val === 'string') {\n    if (ops === undefined)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    return ops.indexOf(buffer\x2C val\x2C byteOffset\x2C dir);\n  }\n\n  if (isUint8Array(val)) {\n    const encodingVal =\n      (ops === undefined ? encodingsMap.utf8 : ops.encodingVal);\n    return indexOfBuffer(buffer\x2C val\x2C byteOffset\x2C encodingVal\x2C dir);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'value'\x2C ['number'\x2C 'string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C val\x2C\n  );\n}\n\nBuffer.prototype.indexOf = function indexOf(val\x2C byteOffset\x2C encoding) {\n  return bidirectionalIndexOf(this\x2C val\x2C byteOffset\x2C encoding\x2C true);\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf(val\x2C byteOffset\x2C encoding) {\n  return bidirectionalIndexOf(this\x2C val\x2C byteOffset\x2C encoding\x2C false);\n};\n\nBuffer.prototype.includes = function includes(val\x2C byteOffset\x2C encoding) {\n  return this.indexOf(val\x2C byteOffset\x2C encoding) !== -1;\n};\n\n// Usage:\n//    buffer.fill(number[\x2C offset[\x2C end]])\n//    buffer.fill(buffer[\x2C offset[\x2C end]])\n//    buffer.fill(string[\x2C offset[\x2C end]][\x2C encoding])\nBuffer.prototype.fill = function fill(value\x2C offset\x2C end\x2C encoding) {\n  return _fill(this\x2C value\x2C offset\x2C end\x2C encoding);\n};\n\nfunction _fill(buf\x2C value\x2C offset\x2C end\x2C encoding) {\n  if (typeof value === 'string') {\n    if (offset === undefined || typeof offset === 'string') {\n      encoding = offset;\n      offset = 0;\n      end = buf.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = buf.length;\n    }\n\n    const normalizedEncoding = normalizeEncoding(encoding);\n    if (normalizedEncoding === undefined) {\n      validateString(encoding\x2C 'encoding');\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    }\n\n    if (value.length === 0) {\n      // If value === '' default to zero.\n      value = 0;\n    } else if (value.length === 1) {\n      // Fast path: If `value` fits into a single byte\x2C use that numeric value.\n      if (normalizedEncoding === 'utf8') {\n        const code = StringPrototypeCharCodeAt(value\x2C 0);\n        if (code < 128) {\n          value = code;\n        }\n      } else if (normalizedEncoding === 'latin1') {\n        value = StringPrototypeCharCodeAt(value\x2C 0);\n      }\n    }\n  } else {\n    encoding = undefined;\n  }\n\n  if (offset === undefined) {\n    offset = 0;\n    end = buf.length;\n  } else {\n    validateOffset(offset\x2C 'offset');\n    // Invalid ranges are not set to a default\x2C so can range check early.\n    if (end === undefined) {\n      end = buf.length;\n    } else {\n      validateOffset(end\x2C 'end'\x2C 0\x2C buf.length);\n    }\n    if (offset >= end)\n      return buf;\n  }\n\n\n  if (typeof value === 'number') {\n    // OOB check\n    const byteLen = TypedArrayPrototypeGetByteLength(buf);\n    const fillLength = end - offset;\n    if (offset > end || fillLength + offset > byteLen)\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\n\n    TypedArrayPrototypeFill(buf\x2C value\x2C offset\x2C end);\n  } else {\n    const res = bindingFill(buf\x2C value\x2C offset\x2C end\x2C encoding);\n    if (res < 0) {\n      if (res === -1)\n        throw new ERR_INVALID_ARG_VALUE('value'\x2C value);\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\n    }\n  }\n\n  return buf;\n}\n\nBuffer.prototype.write = function write(string\x2C offset\x2C length\x2C encoding) {\n  // Buffer#write(string);\n  if (offset === undefined) {\n    return this.utf8Write(string\x2C 0\x2C this.length);\n  }\n  // Buffer#write(string\x2C encoding)\n  if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n\n  // Buffer#write(string\x2C offset[\x2C length][\x2C encoding])\n  } else {\n    validateOffset(offset\x2C 'offset'\x2C 0\x2C this.length);\n\n    const remaining = this.length - offset;\n\n    if (length === undefined) {\n      length = remaining;\n    } else if (typeof length === 'string') {\n      encoding = length;\n      length = remaining;\n    } else {\n      validateOffset(length\x2C 'length'\x2C 0\x2C this.length);\n      if (length > remaining)\n        length = remaining;\n    }\n  }\n\n  if (!encoding)\n    return this.utf8Write(string\x2C offset\x2C length);\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n  return ops.write(this\x2C string\x2C offset\x2C length);\n};\n\nBuffer.prototype.toJSON = function toJSON() {\n  if (this.length > 0) {\n    const data = new Array(this.length);\n    for (let i = 0; i < this.length; ++i)\n      data[i] = this[i];\n    return { type: 'Buffer'\x2C data };\n  }\n  return { type: 'Buffer'\x2C data: [] };\n};\n\nfunction adjustOffset(offset\x2C length) {\n  // Use Math.trunc() to convert offset to an integer value that can be larger\n  // than an Int32. Hence\x2C don't use offset | 0 or similar techniques.\n  offset = MathTrunc(offset);\n  if (offset === 0) {\n    return 0;\n  }\n  if (offset < 0) {\n    offset += length;\n    return offset > 0 ? offset : 0;\n  }\n  if (offset < length) {\n    return offset;\n  }\n  return NumberIsNaN(offset) ? 0 : length;\n}\n\nBuffer.prototype.subarray = function subarray(start\x2C end) {\n  const srcLength = this.length;\n  start = adjustOffset(start\x2C srcLength);\n  end = end !== undefined ? adjustOffset(end\x2C srcLength) : srcLength;\n  const newLength = end > start ? end - start : 0;\n  return new FastBuffer(this.buffer\x2C this.byteOffset + start\x2C newLength);\n};\n\nBuffer.prototype.slice = function slice(start\x2C end) {\n  return this.subarray(start\x2C end);\n};\n\nfunction swap(b\x2C n\x2C m) {\n  const i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16() {\n  // For Buffer.length < 128\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 2 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('16-bits');\n  if (len < 128) {\n    for (let i = 0; i < len; i += 2)\n      swap(this\x2C i\x2C i + 1);\n    return this;\n  }\n  return _swap16(this);\n};\n\nBuffer.prototype.swap32 = function swap32() {\n  // For Buffer.length < 192\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 4 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('32-bits');\n  if (len < 192) {\n    for (let i = 0; i < len; i += 4) {\n      swap(this\x2C i\x2C i + 3);\n      swap(this\x2C i + 1\x2C i + 2);\n    }\n    return this;\n  }\n  return _swap32(this);\n};\n\nBuffer.prototype.swap64 = function swap64() {\n  // For Buffer.length < 192\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 8 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('64-bits');\n  if (len < 192) {\n    for (let i = 0; i < len; i += 8) {\n      swap(this\x2C i\x2C i + 7);\n      swap(this\x2C i + 1\x2C i + 6);\n      swap(this\x2C i + 2\x2C i + 5);\n      swap(this\x2C i + 3\x2C i + 4);\n    }\n    return this;\n  }\n  return _swap64(this);\n};\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString;\n\nlet transcode;\nif (internalBinding('config').hasIntl) {\n  const {\n    icuErrName\x2C\n    transcode: _transcode\x2C\n  } = internalBinding('icu');\n\n  // Transcodes the Buffer from one encoding to another\x2C returning a new\n  // Buffer instance.\n  transcode = function transcode(source\x2C fromEncoding\x2C toEncoding) {\n    if (!isUint8Array(source)) {\n      throw new ERR_INVALID_ARG_TYPE('source'\x2C\n                                     ['Buffer'\x2C 'Uint8Array']\x2C source);\n    }\n    if (source.length === 0) return Buffer.alloc(0);\n\n    fromEncoding = normalizeEncoding(fromEncoding) || fromEncoding;\n    toEncoding = normalizeEncoding(toEncoding) || toEncoding;\n    const result = _transcode(source\x2C fromEncoding\x2C toEncoding);\n    if (typeof result !== 'number')\n      return result;\n\n    const code = icuErrName(result);\n    const err = genericNodeError(\n      `Unable to transcode Buffer [${code}]`\x2C\n      { code: code\x2C errno: result }\x2C\n    );\n    throw err;\n  };\n}\n\nfunction btoa(input) {\n  // The implementation here has not been performance optimized in any way and\n  // should not be.\n  // Refs: https://github.com/nodejs/node/pull/38433#issuecomment-828426932\n  if (arguments.length === 0) {\n    throw new ERR_MISSING_ARGS('input');\n  }\n  input = `${input}`;\n  for (let n = 0; n < input.length; n++) {\n    if (input[n].charCodeAt(0) > 0xff)\n      throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n  }\n  const buf = Buffer.from(input\x2C 'latin1');\n  return buf.toString('base64');\n}\n\n// Refs: https://infra.spec.whatwg.org/#forgiving-base64-decode\nconst kForgivingBase64AllowedChars = [\n  // ASCII whitespace\n  // Refs: https://infra.spec.whatwg.org/#ascii-whitespace\n  0x09\x2C 0x0A\x2C 0x0C\x2C 0x0D\x2C 0x20\x2C\n\n  // Uppercase letters\n  ...ArrayFrom({ length: 26 }\x2C (_\x2C i) => StringPrototypeCharCodeAt('A') + i)\x2C\n\n  // Lowercase letters\n  ...ArrayFrom({ length: 26 }\x2C (_\x2C i) => StringPrototypeCharCodeAt('a') + i)\x2C\n\n  // Decimal digits\n  ...ArrayFrom({ length: 10 }\x2C (_\x2C i) => StringPrototypeCharCodeAt('0') + i)\x2C\n\n  0x2B\x2C // +\n  0x2F\x2C // /\n  0x3D\x2C // =\n];\nconst kEqualSignIndex = ArrayPrototypeIndexOf(kForgivingBase64AllowedChars\x2C\n                                              0x3D);\n\nfunction atob(input) {\n  // The implementation here has not been performance optimized in any way and\n  // should not be.\n  // Refs: https://github.com/nodejs/node/pull/38433#issuecomment-828426932\n  if (arguments.length === 0) {\n    throw new ERR_MISSING_ARGS('input');\n  }\n\n  input = `${input}`;\n  let nonAsciiWhitespaceCharCount = 0;\n  let equalCharCount = 0;\n\n  for (let n = 0; n < input.length; n++) {\n    const index = ArrayPrototypeIndexOf(\n      kForgivingBase64AllowedChars\x2C\n      StringPrototypeCharCodeAt(input\x2C n));\n\n    if (index > 4) {\n      // The first 5 elements of `kForgivingBase64AllowedChars` are\n      // ASCII whitespace char codes.\n      nonAsciiWhitespaceCharCount++;\n\n      if (index === kEqualSignIndex) {\n        equalCharCount++;\n      } else if (equalCharCount) {\n        // The `=` char is only allowed at the end.\n        throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n      }\n\n      if (equalCharCount > 2) {\n        // Only one more `=` is permitted after the first equal sign.\n        throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n      }\n    } else if (index === -1) {\n      throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n    }\n  }\n\n  let reminder = nonAsciiWhitespaceCharCount % 4;\n\n  // See #2\x2C #3\x2C #4 - https://infra.spec.whatwg.org/#forgiving-base64\n  if (!reminder) {\n    // Remove all trailing `=` characters and get the new reminder.\n    reminder = (nonAsciiWhitespaceCharCount - equalCharCount) % 4;\n  } else if (equalCharCount) {\n    // `=` should not in the input if there's a reminder.\n    throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n  }\n\n  // See #3 - https://infra.spec.whatwg.org/#forgiving-base64\n  if (reminder === 1) {\n    throw lazyDOMException(\n      'The string to be decoded is not correctly encoded.'\x2C\n      'InvalidCharacterError');\n  }\n\n  return Buffer.from(input\x2C 'base64').toString('latin1');\n}\n\nfunction isUtf8(input) {\n  if (isTypedArray(input) || isAnyArrayBuffer(input)) {\n    return bindingIsUtf8(input);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE('input'\x2C ['TypedArray'\x2C 'Buffer']\x2C input);\n}\n\nfunction isAscii(input) {\n  if (isTypedArray(input) || isAnyArrayBuffer(input)) {\n    return bindingIsAscii(input);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE('input'\x2C ['ArrayBuffer'\x2C 'Buffer'\x2C 'TypedArray']\x2C input);\n}\n\nmodule.exports = {\n  Buffer\x2C\n  SlowBuffer\x2C\n  transcode\x2C\n  isUtf8\x2C\n  isAscii\x2C\n\n  // Legacy\n  kMaxLength\x2C\n  kStringMaxLength\x2C\n  btoa\x2C\n  atob\x2C\n};\n\nObjectDefineProperties(module.exports\x2C {\n  constants: {\n    __proto__: null\x2C\n    configurable: false\x2C\n    enumerable: true\x2C\n    value: constants\x2C\n  }\x2C\n  INSPECT_MAX_BYTES: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() { return INSPECT_MAX_BYTES; }\x2C\n    set(val) {\n      validateNumber(val\x2C 'INSPECT_MAX_BYTES'\x2C 0);\n      INSPECT_MAX_BYTES = val;\n    }\x2C\n  }\x2C\n});\n\ndefineLazyProperties(\n  module.exports\x2C\n  'internal/blob'\x2C\n  ['Blob'\x2C 'resolveObjectURL']\x2C\n);\ndefineLazyProperties(\n  module.exports\x2C\n  'internal/file'\x2C\n  ['File']\x2C\n);\n
code-source-info,0x31e6f6b74016,24,15940,16072,C0O15955C6O16003C12O16010C20O16028C23O16028C28O16056C29O16070,,
tick,0x7ff809303ad2,72248,0,0x0,3,0x10c9f09d0,0x31e6f6b6e4ec,0x31e6f6b6c4b6,0x31e6f6b73870,0x31e6f6b7340a,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
tick,0x7ff809303b0d,72268,0,0x0,3,0x10c9f09d0,0x31e6f6b6e4ec,0x31e6f6b6c4b6,0x31e6f6b73870,0x31e6f6b7340a,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,72281,0x31e6f6b76d5e,30,normalizeEncoding node:internal/util:212:27,0x31e647c42508,~
code-source-info,0x31e6f6b76d5e,16,5641,5746,C0O5651C7O5674C14O5692C19O5705C21O5719C22O5722C25O5729C29O5744,,
code-creation,JS,10,72316,0x31e6f6b76e46,9,isInt32 node:internal/validators:43:17,0x31e6931beea8,~
code-source-info,0x31e6f6b76e46,15,851,894,C0O863C2O887C5O876C8O892,,
code-creation,JS,10,72359,0x31e6f6b76f36,42, node:internal/fs/utils:727:42,0x31e647c73c28,~
code-source-info,0x31e6f6b76f36,60,19896,20054,C14O19951C19O19951C24O19985C29O19985C34O20017C37O20024C41O20052,,
code-creation,JS,10,72424,0x31e6f6b77076,106,possiblyTransformPath node:internal/fs/utils:715:31,0x31e647c73bd8,~
code-source-info,0x31e6f6b77076,60,19572,19853,C0O19583C5O19598C10O19598C16O19617C22O19655C27O19662C31O19680C32O19691C39O19698C42O19698C47O19691C51O19723C56O19728C62O19750C67O19757C73O19779C80O19797C85O19809C88O19809C93O19797C98O19786C102O19832C103O19839C105O19851,,
tick,0x7ff80912839e,72537,0,0x0,3,0x10c9f09d0,0x31e6f6b76f5b,0x31e6f6b738a9,0x31e6f6b7340a,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,72580,0x31e6f6b774b6,515,stringToFlags node:internal/fs/utils:584:23,0x31e647c739f8,~
code-source-info,0x31e6f6b774b6,60,15805,17039,C14O15833C20O15870C25O15870C30O15902C32O15915C33O15923C38O15948C42O15964C43O15972C202O16004C206O16020C207O16070C214O16088C216O16086C219O16095C220O16112C224O16126C225O16178C232O16194C234O16192C237O16201C238O16218C245O16235C247O16233C253O16245C255O16243C258O16254C259O16304C266O16321C268O16319C274O16331C276O16329C282O16342C284O16340C287O16349C288O16367C295O16384C297O16382C303O16394C305O16392C308O16401C309O16451C316O16468C318O16466C324O16478C326O16476C332O16487C334O16485C337O16494C338O16511C345O16529C347O16527C353O16539C355O16537C358O16548C359O16598C366O16616C368O16614C374O16626C376O16624C382O16637C384O16635C387O16644C388O16694C395O16712C397O16710C403O16722C405O16720C411O16733C413O16731C416O16740C417O16758C424O16776C426O16774C432O16786C434O16784C437O16793C438O16843C445O16861C447O16859C453O16871C455O16869C461O16880C463O16878C466O16887C467O16937C474O16955C476O16953C482O16965C484O16963C490O16974C492O16972C495O16981C496O16989C509O16995C514O16989,,
code-creation,JS,10,73489,0x31e6f6b78416,463,Module._compile node:internal/modules/cjs/loader:1330:37,0x31e647c77350,~
code-source-info,0x31e6f6b78416,63,42944,44762,C0O42972C2O42989C4O43019C9O43019C15O43027C23O43041C25O43061C30O43073C35O43123C40O43123C46O43168C51O43168C57O43236C69O43236C75O43297C77O43305C85O43309C94O43352C101O43373C107O43467C110O43479C117O43483C125O43514C128O43536C136O43561C143O43565C152O43536C160O43527C170O43758C177O43765C182O43778C188O43778C193O43765C198O43758C204O43842C209O43855C215O43922C223O43943C229O43974C231O43970C236O43996C240O44011C246O44025C252O44044C257O44072C262O44122C267O44127C272O44127C278O44164C283O44164C289O44208C291O44239C296O44268C297O44294C300O44302C306O44319C311O44328C316O44340C324O44338C330O44359C334O44387C355O44396C363O44532C368O44571C377O44609C386O44618C395O44627C404O44635C413O44645C423O44541C429O44662C433O44688C439O44698C445O44715C450O44724C454O44734C460O44746C462O44760,,
code-creation,JS,10,73627,0x31e6f6b78b06,364,wrapSafe node:internal/modules/cjs/loader:1257:18,0x31e647c772d0,~
code-source-info,0x31e6f6b78b06,63,40039,42615,C0O40039C14O40121C26O40135C31O40121C36O40405C44O40440C49O40447C54O40447C60O40481C89O40481C95O41013C101O41035C115O41105C126O41035C131O41131C145O41138C150O41182C151O41205C159O41295C196O41295C202O42014C206O42046C224O42086C229O42108C234O42109C240O42126C245O42134C253O42134C258O42253C264O42275C278O42345C289O42275C294O42385C298O42394C310O42417C315O42429C322O42440C327O42498C335O42498C340O42479C345O42549C356O42549C361O42599C363O42599,,
tick,0x10c965311,73739,0,0x0,2,0x10c9f09d0,0x31e6f6b78bca,0x31e6f6b7845b,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,73766,0x31e6f6b78ede,118,internalCompileFunction node:internal/vm:73:33,0x31e647c5bdb8,~
script-source,36,node:internal/vm,'use strict';\n\nconst {\n  ReflectApply\x2C\n  Symbol\x2C\n} = primordials;\n\nconst {\n  ContextifyScript\x2C\n  compileFunction\x2C\n  isContext: _isContext\x2C\n} = internalBinding('contextify');\nconst {\n  runInContext\x2C\n} = ContextifyScript.prototype;\nconst {\n  default_host_defined_options\x2C\n  vm_dynamic_import_missing_flag\x2C\n} = internalBinding('symbols');\nconst {\n  validateFunction\x2C\n  validateObject\x2C\n  kValidateObjectAllowArray\x2C\n} = require('internal/validators');\n\nconst {\n  getOptionValue\x2C\n} = require('internal/options');\n\n\nfunction isContext(object) {\n  validateObject(object\x2C 'object'\x2C kValidateObjectAllowArray);\n\n  return _isContext(object);\n}\n\nfunction getHostDefinedOptionId(importModuleDynamically\x2C hint) {\n  if (importModuleDynamically !== undefined) {\n    // Check that it's either undefined or a function before we pass\n    // it into the native constructor.\n    validateFunction(importModuleDynamically\x2C\n                     'options.importModuleDynamically');\n  }\n  if (importModuleDynamically === undefined) {\n    // We need a default host defined options that are the same for all\n    // scripts not needing custom module callbacks so that the isolate\n    // compilation cache can be hit.\n    return default_host_defined_options;\n  }\n  // We should've thrown here immediately when we introduced\n  // --experimental-vm-modules and importModuleDynamically\x2C but since\n  // users are already using this callback to throw a similar error\x2C\n  // we also defer the error to the time when an actual import() is called\n  // to avoid breaking them. To ensure that the isolate compilation\n  // cache can still be hit\x2C use a constant sentinel symbol here.\n  if (!getOptionValue('--experimental-vm-modules')) {\n    return vm_dynamic_import_missing_flag;\n  }\n\n  return Symbol(hint);\n}\n\nfunction registerImportModuleDynamically(referrer\x2C importModuleDynamically) {\n  const { importModuleDynamicallyWrap } = require('internal/vm/module');\n  const { registerModule } = require('internal/modules/esm/utils');\n  registerModule(referrer\x2C {\n    __proto__: null\x2C\n    importModuleDynamically:\n      importModuleDynamicallyWrap(importModuleDynamically)\x2C\n  });\n}\n\nfunction internalCompileFunction(\n  code\x2C filename\x2C lineOffset\x2C columnOffset\x2C\n  cachedData\x2C produceCachedData\x2C parsingContext\x2C contextExtensions\x2C\n  params\x2C hostDefinedOptionId\x2C importModuleDynamically) {\n  const result = compileFunction(\n    code\x2C\n    filename\x2C\n    lineOffset\x2C\n    columnOffset\x2C\n    cachedData\x2C\n    produceCachedData\x2C\n    parsingContext\x2C\n    contextExtensions\x2C\n    params\x2C\n    hostDefinedOptionId\x2C\n  );\n\n  if (produceCachedData) {\n    result.function.cachedDataProduced = result.cachedDataProduced;\n  }\n\n  if (result.cachedData) {\n    result.function.cachedData = result.cachedData;\n  }\n\n  if (typeof result.cachedDataRejected === 'boolean') {\n    result.function.cachedDataRejected = result.cachedDataRejected;\n  }\n\n  if (importModuleDynamically !== undefined) {\n    registerImportModuleDynamically(result.function\x2C importModuleDynamically);\n  }\n\n  return result;\n}\n\nfunction makeContextifyScript(code\x2C\n                              filename\x2C\n                              lineOffset\x2C\n                              columnOffset\x2C\n                              cachedData\x2C\n                              produceCachedData\x2C\n                              parsingContext\x2C\n                              hostDefinedOptionId\x2C\n                              importModuleDynamically) {\n  let script;\n  // Calling `ReThrow()` on a native TryCatch does not generate a new\n  // abort-on-uncaught-exception check. A dummy try/catch in JS land\n  // protects against that.\n  try { // eslint-disable-line no-useless-catch\n    script = new ContextifyScript(code\x2C\n                                  filename\x2C\n                                  lineOffset\x2C\n                                  columnOffset\x2C\n                                  cachedData\x2C\n                                  produceCachedData\x2C\n                                  parsingContext\x2C\n                                  hostDefinedOptionId);\n  } catch (e) {\n    throw e; /* node-do-not-add-exception-line */\n  }\n\n  if (importModuleDynamically !== undefined) {\n    registerImportModuleDynamically(script\x2C importModuleDynamically);\n  }\n  return script;\n}\n\n// Internal version of vm.Script.prototype.runInThisContext() which skips\n// argument validation.\nfunction runScriptInThisContext(script\x2C displayErrors\x2C breakOnFirstLine) {\n  return ReflectApply(\n    runInContext\x2C\n    script\x2C\n    [\n      null\x2C                // sandbox - use current context\n      -1\x2C                  // timeout\n      displayErrors\x2C       // displayErrors\n      false\x2C               // breakOnSigint\n      breakOnFirstLine\x2C    // breakOnFirstLine\n    ]\x2C\n  );\n}\n\nmodule.exports = {\n  getHostDefinedOptionId\x2C\n  internalCompileFunction\x2C\n  isContext\x2C\n  makeContextifyScript\x2C\n  registerImportModuleDynamically\x2C\n  runScriptInThisContext\x2C\n};\n
code-source-info,0x31e6f6b78ede,36,2169,3020,C0O2358C35O2358C41O2560C45O2596C50O2633C54O2624C58O2671C64O2696C69O2725C73O2716C77O2762C85O2809C90O2846C94O2837C98O2873C102O2922C105O2961C110O2922C115O3004C117O3018,,
code-creation,Eval,10,74280,0x31e6f6b79e6e,5, /Users/peterhage/Applications/WebStorm.app/Contents/plugins/javascript-debugger/debugConnector.js:1:1,0x31e6f6b79c80,~
script-source,81,/Users/peterhage/Applications/WebStorm.app/Contents/plugins/javascript-debugger/debugConnector.js,const debugConnectorUtil = require('./debugConnectorUtil');\n\ntry {\n  if (debugConnectorUtil.isVerboseLoggingEnabled()) {\n    log('Starting execArgv=' + JSON.stringify(process.execArgv) + '\x2C argv=' + JSON.stringify(process.argv));\n  }\n\n  const reason = findReasonToSkipAttachingDebugger();\n  if (reason != null) {\n    if (debugConnectorUtil.isVerboseLoggingEnabled()) {\n      log('Attaching debugger skipped: ' + reason);\n    }\n    return;\n  }\n\n  const inspector = require('inspector');\n  const asyncInspectorOpenSupported = isAsyncInspectorOpenSupported();\n  const debugPort = findAvailablePort(inspector\x2C asyncInspectorOpenSupported);\n  if (debugConnectorUtil.getGatewayHostPort() != null) {\n    debugConnectorUtil.forwardDebugConnectionAndWait(debugPort);\n    return;\n  }\n\n  const {execFile\x2C execFileSync} = require('child_process');\n  const launchPortPublisher = asyncInspectorOpenSupported ? execFileSync : execFile;\n  const interpreter = process.env['JB_INTERPRETER'] || process.execPath;\n  const publisherEnv = Object.assign({}\x2C process.env\x2C {\n    NODE_OPTIONS: ''\n  });\n  if (debugConnectorUtil.isVerboseLoggingEnabled()) {\n    log('Publishing debug port ' + debugPort + '\x2C asyncInspectorOpenSupported: ' + asyncInspectorOpenSupported\n          + '\x2C process.versions.node: ' + (process.versions || {}).node);\n  }\n  launchPortPublisher(interpreter\x2C [require.resolve('./debugConnectorPortPublisher.js')\x2C debugPort.toString()]\x2C {\n    env: publisherEnv\x2C\n    stdio: 'inherit'\x2C\n    windowsHide: true\n  });\n  if (!asyncInspectorOpenSupported) {\n    inspector.open(debugPort\x2C getBindHost()\x2C true);\n  }\n}\ncatch (e) {\n  console.error(formatMessage('Attaching debugger skipped (unhandled exception)')\x2C e);\n}\n\nfunction findReasonToSkipAttachingDebugger() {\n  if (hasInspectArg()) {\n    return '--inspect* passed';\n  }\n  if (isElectronRendererProcess()) {\n    return 'electron process detected';\n  }\n  const helperProcessInfo = getMatchedHelperProcess();\n  if (helperProcessInfo != null) {\n    return 'matched as helper process ' + JSON.stringify(helperProcessInfo);\n  }\n  try {\n    if (!require('worker_threads').isMainThread) {\n      // will be attached using WIP NodeWorker domain\n      return 'worker thread detected';\n    }\n  }\n  catch (ignored) {\n  }\n  return null;\n}\n\nfunction hasInspectArg() {\n  return process.execArgv.some(\n      arg => arg === '--inspect' || arg === '--inspect-brk' || arg.startsWith('--inspect-brk=') || arg.startsWith('--inspect=')\n  );\n}\n\nfunction isElectronRendererProcess() {\n  return process.type && process.type === 'renderer' || process.argv.indexOf('--type=renderer') >= 0;\n}\n\n/**\n * A helper process is a Node.js process that is known not to run application code\x2C\n * so it's safe not to attach a debugger to it.\n * Skipping attaching debugger to a helper process would produce less debugger related output in the console.\n *\n * @returns {Array<String>} a helper process info matching the current process; null if none matched\n */\nfunction getMatchedHelperProcess() {\n  const INTERPRETER_DIR_MACRO = '[interpreter dir]';\n  const helperProcessInfoList = [\n    ['/node_modules/npm/bin/npm-cli.js'\x2C 'prefix'\x2C '-g']\x2C // 'npm prefix -g' is run by npm.cmd on Windows\n    ['/node_modules/update-notifier/check.js']\x2C // check for npm/yarn available updates\n\n    // npm/Yarn script (e.g. 'npm run start') spawns the process hierarchy\x2C\n    // where the root Node.js process doesn't run any application code\n    ['/node_modules/npm/bin/npm-cli.js'\x2C 'run']\x2C\n    [INTERPRETER_DIR_MACRO + '/npm'\x2C 'run']\x2C // ~/.nvm/versions/node/v18.12.1/bin/npm ('npm' and 'node' are the same folder)\n    ['/Yarn/bin/yarn.js'\x2C 'run']\x2C\n    ['/usr/local/bin/npm'\x2C 'run']\n  ];\n  if (process.env.JETBRAINS_NODE_DEBUGGER_ATTACH_TO_HELPERS) {\n    return null;\n  }\n  const argv = process.argv;\n  return helperProcessInfoList.find((helperProcessInfo) => {\n    return isHelperInfoMatched(helperProcessInfo\x2C argv);\n  });\n\n  /**\n   * @param {Array<String>} helperProcessInfo\n   * @param {Array<String>} argv\n   * @returns {boolean}\n   */\n  function isHelperInfoMatched(helperProcessInfo\x2C argv) {\n    if (argv.length <= helperProcessInfo.length || helperProcessInfo.length === 0) {\n      return false;\n    }\n    return helperProcessInfo.every((value\x2C index) => {\n      if (index === 0) {\n        return matchPathSuffix(value\x2C argv[1]);\n      }\n      return value === argv[index + 1];\n    });\n  }\n\n  function matchPathSuffix(pathSuffix\x2C path) {\n    if (pathSuffix.startsWith(INTERPRETER_DIR_MACRO)) {\n      const expectedPath = require('path').dirname(process.execPath) + pathSuffix.substring(INTERPRETER_DIR_MACRO.length);\n      return toSystemIndependentPath(path) === toSystemIndependentPath(expectedPath);\n    }\n    return toSystemIndependentPath(path).endsWith(pathSuffix);\n  }\n\n  function toSystemIndependentPath(path) {\n    return path.replace(/\\\\/g\x2C '/');\n  }\n}\n\n/**\n * inspector.open(...\x2C...\x2Cfalse) doesn't work properly on some node versions. It opens the port but debugger can't attach.\n */\nfunction isAsyncInspectorOpenSupported() {\n  try {\n    const versions = process.versions.node.split('.');\n    const major = parseInt(versions[0]\x2C 10);\n    const minor = parseInt(versions[1]\x2C 10);\n    return major >= 11 || major === 10 && minor >= 7;\n  }\n  catch (e) {\n    console.error(formatMessage('Cannot parse node version: ' + JSON.stringify(process.versions))\x2C e);\n    return false;\n  }\n}\n\nfunction findAvailablePort(inspector\x2C asyncInspectorOpenSupported) {\n  try {\n    inspector.open(0\x2C getBindHost()\x2C false);\n    const port = parsePort(inspector.url());\n    if (!asyncInspectorOpenSupported) {\n      inspector.close();\n    }\n    return port;\n  }\n  catch(e) {\n    inspector.close();\n    throw e;\n  }\n\n  /**\n   * @param {String} url\x2C like 'ws://127.0.0.1:45681/98f5f884-7eba-4037-aa71-ba972e8ad0dd'\n   */\n  function parsePort(url) {\n    const { URL } = require('url');\n    const parsedURL = new URL(url);\n    const port = parseInt(parsedURL.port\x2C 10);\n    if (isNaN(port)) throw Error('Failed to parse debug port from ' + url);\n    return port;\n  }\n}\n\n/**\n * @return host to listen on for inspector connections. If undefined\x2C localhost will be used.\n */\nfunction getBindHost() {\n  return process.env.JETBRAINS_NODE_BIND_HOST;\n}\n\nfunction log(message) {\n  console.log(formatMessage(message));\n}\n\nfunction formatMessage(message) {\n  return debugConnectorUtil.formatMessage('debugConnector'\x2C message);\n}\n
code-source-info,0x31e6f6b79e6e,81,0,6398,C0O0C4O6398,,
code-creation,JS,10,74721,0x31e6f6b7a456,590, /Users/peterhage/Applications/WebStorm.app/Contents/plugins/javascript-debugger/debugConnector.js:1:1,0x31e6f6b79de8,~
code-source-info,0x31e6f6b7a456,81,0,6398,C0O0C62O27C68O27C72O27C77O69C81O92C86O92C92O125C96O152C101O157C107O167C112O175C118O157C123O150C130O185C135O199C140O204C146O214C151O222C157O204C162O197C167O125C171O252C175O291C178O317C182O340C187O340C193O375C199O410C204O375C208O431C209O438C210O464C217O464C222O524C226O577C232O638C236O661C241O661C248O697C252O716C257O716C262O762C263O769C264O810C271O810C276O784C281O794C286O866C297O943C301O951C306O954C312O976C316O984C321O1017C326O1024C334O1035C339O1043C351O1024C357O1079C361O1102C366O1102C372O1135C378O1164C385O1176C392O1212C399O1252C404O1285C409O1293C421O1309C425O1282C430O1135C434O1342C447O1364C457O1364C470O1419C476O1419C492O1443C499O1322C504O1509C508O1559C517O1575C531O1559C549O1617C554O1625C570O1631C580O1625C589O6397,,
tick,0x7ff8093038b3,74846,1,0x10c1f3810,3,0x10c41e000,0x31e6f6b78f01,0x31e6f6b78bca,0x31e6f6b7845b,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,74872,0x31e6f6b7b126,52,registerImportModuleDynamically node:internal/vm:63:41,0x31e647c5bd68,~
code-source-info,0x31e6f6b7b126,36,1810,2135,C0O1890C6O1890C11O1858C16O1950C22O1950C27O1931C32O2006C37O2074C45O1991C51O2134,,
code-creation,JS,10,74954,0x31e6f6b7b2f6,19,importModuleDynamicallyWrap node:internal/vm/module:429:37,0x31e647c7ae60,~
script-source,68,node:internal/vm/module,'use strict';\n\nconst assert = require('internal/assert');\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeSome\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n  SafePromiseAllReturnVoid\x2C\n  Symbol\x2C\n  SymbolToStringTag\x2C\n  TypeError\x2C\n} = primordials;\n\nconst { isContext } = internalBinding('contextify');\nconst {\n  isModuleNamespaceObject\x2C\n} = require('internal/util/types');\nconst {\n  customInspectSymbol\x2C\n  emitExperimentalWarning\x2C\n  getConstructorOf\x2C\n  kEmptyObject\x2C\n} = require('internal/util');\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_VM_MODULE_ALREADY_LINKED\x2C\n  ERR_VM_MODULE_DIFFERENT_CONTEXT\x2C\n  ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA\x2C\n  ERR_VM_MODULE_LINK_FAILURE\x2C\n  ERR_VM_MODULE_NOT_MODULE\x2C\n  ERR_VM_MODULE_STATUS\x2C\n} = require('internal/errors').codes;\nconst {\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateObject\x2C\n  validateUint32\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst binding = internalBinding('module_wrap');\nconst {\n  ModuleWrap\x2C\n  kUninstantiated\x2C\n  kInstantiating\x2C\n  kInstantiated\x2C\n  kEvaluating\x2C\n  kEvaluated\x2C\n  kErrored\x2C\n} = binding;\n\nconst STATUS_MAP = {\n  [kUninstantiated]: 'unlinked'\x2C\n  [kInstantiating]: 'linking'\x2C\n  [kInstantiated]: 'linked'\x2C\n  [kEvaluating]: 'evaluating'\x2C\n  [kEvaluated]: 'evaluated'\x2C\n  [kErrored]: 'errored'\x2C\n};\n\nlet globalModuleId = 0;\nconst defaultModuleName = 'vm:module';\n\nconst kWrap = Symbol('kWrap');\nconst kContext = Symbol('kContext');\nconst kPerContextModuleId = Symbol('kPerContextModuleId');\nconst kLink = Symbol('kLink');\n\nclass Module {\n  constructor(options) {\n    emitExperimentalWarning('VM Modules');\n\n    if (new.target === Module) {\n      // eslint-disable-next-line no-restricted-syntax\n      throw new TypeError('Module is not a constructor');\n    }\n\n    const {\n      context\x2C\n      sourceText\x2C\n      syntheticExportNames\x2C\n      syntheticEvaluationSteps\x2C\n    } = options;\n\n    if (context !== undefined) {\n      validateObject(context\x2C 'context');\n      if (!isContext(context)) {\n        throw new ERR_INVALID_ARG_TYPE('options.context'\x2C 'vm.Context'\x2C\n                                       context);\n      }\n    }\n\n    let { identifier } = options;\n    if (identifier !== undefined) {\n      validateString(identifier\x2C 'options.identifier');\n    } else if (context === undefined) {\n      identifier = `${defaultModuleName}(${globalModuleId++})`;\n    } else if (context[kPerContextModuleId] !== undefined) {\n      const curId = context[kPerContextModuleId];\n      identifier = `${defaultModuleName}(${curId})`;\n      context[kPerContextModuleId] += 1;\n    } else {\n      identifier = `${defaultModuleName}(0)`;\n      ObjectDefineProperty(context\x2C kPerContextModuleId\x2C {\n        __proto__: null\x2C\n        value: 1\x2C\n        writable: true\x2C\n        enumerable: false\x2C\n        configurable: true\x2C\n      });\n    }\n\n    let registry = { __proto__: null };\n    if (sourceText !== undefined) {\n      this[kWrap] = new ModuleWrap(identifier\x2C context\x2C sourceText\x2C\n                                   options.lineOffset\x2C options.columnOffset\x2C\n                                   options.cachedData);\n      registry = {\n        __proto__: null\x2C\n        initializeImportMeta: options.initializeImportMeta\x2C\n        importModuleDynamically: options.importModuleDynamically ?\n          importModuleDynamicallyWrap(options.importModuleDynamically) :\n          undefined\x2C\n      };\n    } else {\n      assert(syntheticEvaluationSteps);\n      this[kWrap] = new ModuleWrap(identifier\x2C context\x2C\n                                   syntheticExportNames\x2C\n                                   syntheticEvaluationSteps);\n    }\n\n    // This will take precedence over the referrer as the object being\n    // passed into the callbacks.\n    registry.callbackReferrer = this;\n    const { registerModule } = require('internal/modules/esm/utils');\n    registerModule(this[kWrap]\x2C registry);\n\n    this[kContext] = context;\n  }\n\n  get identifier() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return this[kWrap].url;\n  }\n\n  get context() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return this[kContext];\n  }\n\n  get namespace() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kWrap].getStatus() < kInstantiated) {\n      throw new ERR_VM_MODULE_STATUS('must not be unlinked or linking');\n    }\n    return this[kWrap].getNamespace();\n  }\n\n  get status() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return STATUS_MAP[this[kWrap].getStatus()];\n  }\n\n  get error() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kWrap].getStatus() !== kErrored) {\n      throw new ERR_VM_MODULE_STATUS('must be errored');\n    }\n    return this[kWrap].getError();\n  }\n\n  async link(linker) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    validateFunction(linker\x2C 'linker');\n    if (this.status === 'linked') {\n      throw new ERR_VM_MODULE_ALREADY_LINKED();\n    }\n    if (this.status !== 'unlinked') {\n      throw new ERR_VM_MODULE_STATUS('must be unlinked');\n    }\n    await this[kLink](linker);\n    this[kWrap].instantiate();\n  }\n\n  async evaluate(options = kEmptyObject) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n\n    validateObject(options\x2C 'options');\n\n    let timeout = options.timeout;\n    if (timeout === undefined) {\n      timeout = -1;\n    } else {\n      validateUint32(timeout\x2C 'options.timeout'\x2C true);\n    }\n    const { breakOnSigint = false } = options;\n    validateBoolean(breakOnSigint\x2C 'options.breakOnSigint');\n    const status = this[kWrap].getStatus();\n    if (status !== kInstantiated &&\n        status !== kEvaluated &&\n        status !== kErrored) {\n      throw new ERR_VM_MODULE_STATUS(\n        'must be one of linked\x2C evaluated\x2C or errored'\x2C\n      );\n    }\n    await this[kWrap].evaluate(timeout\x2C breakOnSigint);\n  }\n\n  [customInspectSymbol](depth\x2C options) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n\n    const constructor = getConstructorOf(this) || Module;\n    const o = { __proto__: { constructor } };\n    o.status = this.status;\n    o.identifier = this.identifier;\n    o.context = this.context;\n\n    ObjectSetPrototypeOf(o\x2C ObjectGetPrototypeOf(this));\n    ObjectDefineProperty(o\x2C SymbolToStringTag\x2C {\n      __proto__: null\x2C\n      value: constructor.name\x2C\n      configurable: true\x2C\n    });\n\n    // Lazy to avoid circular dependency\n    const { inspect } = require('internal/util/inspect');\n    return inspect(o\x2C { ...options\x2C customInspect: false });\n  }\n}\n\nconst kDependencySpecifiers = Symbol('kDependencySpecifiers');\nconst kNoError = Symbol('kNoError');\n\nclass SourceTextModule extends Module {\n  #error = kNoError;\n  #statusOverride;\n\n  constructor(sourceText\x2C options = kEmptyObject) {\n    validateString(sourceText\x2C 'sourceText');\n    validateObject(options\x2C 'options');\n\n    const {\n      lineOffset = 0\x2C\n      columnOffset = 0\x2C\n      initializeImportMeta\x2C\n      importModuleDynamically\x2C\n      context\x2C\n      identifier\x2C\n      cachedData\x2C\n    } = options;\n\n    validateInt32(lineOffset\x2C 'options.lineOffset');\n    validateInt32(columnOffset\x2C 'options.columnOffset');\n\n    if (initializeImportMeta !== undefined) {\n      validateFunction(initializeImportMeta\x2C 'options.initializeImportMeta');\n    }\n\n    if (importModuleDynamically !== undefined) {\n      validateFunction(importModuleDynamically\x2C 'options.importModuleDynamically');\n    }\n\n    if (cachedData !== undefined) {\n      validateBuffer(cachedData\x2C 'options.cachedData');\n    }\n\n    super({\n      sourceText\x2C\n      context\x2C\n      identifier\x2C\n      lineOffset\x2C\n      columnOffset\x2C\n      cachedData\x2C\n      initializeImportMeta\x2C\n      importModuleDynamically\x2C\n    });\n\n    this[kLink] = async (linker) => {\n      this.#statusOverride = 'linking';\n\n      const promises = this[kWrap].link(async (identifier\x2C attributes) => {\n        const module = await linker(identifier\x2C this\x2C { attributes\x2C assert: attributes });\n        if (module[kWrap] === undefined) {\n          throw new ERR_VM_MODULE_NOT_MODULE();\n        }\n        if (module.context !== this.context) {\n          throw new ERR_VM_MODULE_DIFFERENT_CONTEXT();\n        }\n        if (module.status === 'errored') {\n          throw new ERR_VM_MODULE_LINK_FAILURE(`request for '${identifier}' resolved to an errored module`\x2C module.error);\n        }\n        if (module.status === 'unlinked') {\n          await module[kLink](linker);\n        }\n        return module[kWrap];\n      });\n\n      try {\n        if (promises !== undefined) {\n          await SafePromiseAllReturnVoid(promises);\n        }\n      } catch (e) {\n        this.#error = e;\n        throw e;\n      } finally {\n        this.#statusOverride = undefined;\n      }\n    };\n\n    this[kDependencySpecifiers] = undefined;\n  }\n\n  get dependencySpecifiers() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kDependencySpecifiers] === undefined) {\n      this[kDependencySpecifiers] = this[kWrap].getStaticDependencySpecifiers();\n    }\n    return this[kDependencySpecifiers];\n  }\n\n  get status() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this.#error !== kNoError) {\n      return 'errored';\n    }\n    if (this.#statusOverride) {\n      return this.#statusOverride;\n    }\n    return super.status;\n  }\n\n  get error() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this.#error !== kNoError) {\n      return this.#error;\n    }\n    return super.error;\n  }\n\n  createCachedData() {\n    const { status } = this;\n    if (status === 'evaluating' ||\n        status === 'evaluated' ||\n        status === 'errored') {\n      throw new ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA();\n    }\n    return this[kWrap].createCachedData();\n  }\n}\n\nclass SyntheticModule extends Module {\n  constructor(exportNames\x2C evaluateCallback\x2C options = kEmptyObject) {\n    if (!ArrayIsArray(exportNames) ||\n      ArrayPrototypeSome(exportNames\x2C (e) => typeof e !== 'string')) {\n      throw new ERR_INVALID_ARG_TYPE('exportNames'\x2C\n                                     'Array of unique strings'\x2C\n                                     exportNames);\n    } else {\n      ArrayPrototypeForEach(exportNames\x2C (name\x2C i) => {\n        if (ArrayPrototypeIndexOf(exportNames\x2C name\x2C i + 1) !== -1) {\n          throw new ERR_INVALID_ARG_VALUE(`exportNames.${name}`\x2C\n                                          name\x2C\n                                          'is duplicated');\n        }\n      });\n    }\n    validateFunction(evaluateCallback\x2C 'evaluateCallback');\n\n    validateObject(options\x2C 'options');\n\n    const { context\x2C identifier } = options;\n\n    super({\n      syntheticExportNames: exportNames\x2C\n      syntheticEvaluationSteps: evaluateCallback\x2C\n      context\x2C\n      identifier\x2C\n    });\n\n    this[kLink] = () => this[kWrap].link(() => {\n      assert.fail('link callback should not be called');\n    });\n  }\n\n  setExport(name\x2C value) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    validateString(name\x2C 'name');\n    if (this[kWrap].getStatus() < kInstantiated) {\n      throw new ERR_VM_MODULE_STATUS('must be linked');\n    }\n    this[kWrap].setExport(name\x2C value);\n  }\n}\n\nfunction importModuleDynamicallyWrap(importModuleDynamically) {\n  const importModuleDynamicallyWrapper = async (...args) => {\n    const m = await ReflectApply(importModuleDynamically\x2C this\x2C args);\n    if (isModuleNamespaceObject(m)) {\n      return m;\n    }\n    if (!m || m[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (m.status === 'errored') {\n      throw m.error;\n    }\n    return m.namespace;\n  };\n  return importModuleDynamicallyWrapper;\n}\n\nmodule.exports = {\n  Module\x2C\n  SourceTextModule\x2C\n  SyntheticModule\x2C\n  importModuleDynamicallyWrap\x2C\n};\n
code-source-info,0x31e6f6b7b2f6,68,11681,12124,C0O11681C13O11750C18O12122,,
tick,0x10cd8a980,75833,0,0x0,0,0x31e6f6b7b14f,0x31e6f6b78f4c,0x31e6f6b78bca,0x31e6f6b7845b,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,75868,0x31e6f6b7c2b6,63,registerModule node:internal/modules/esm/utils:146:24,0x31e647c78b08,~
code-source-info,0x31e6f6b7c2b6,66,4414,4934,C0O4456C2O4465C4O4464C8O4496C10O4513C12O4509C19O4564C21O4560C26O4798C27O4805C28O4849C41O4875C45O4891C50O4908C55O4908C62O4933,,
code-creation,JS,10,75971,0x31e6f6b7c696,215,makeRequireFunction node:internal/modules/helpers:127:29,0x31e647c77f88,~
code-source-info,0x31e6f6b7c696,64,3790,6294,C0O3790C22O3849C27O3849C30O3849C32O3865C37O3873C46O3907C64O3913C69O3907C70O4005C72O4016C92O4048C97O4052C108O4068C112O4048C114O4095C119O4095C122O4095C124O4127C130O4136C136O4164C145O5314C150O5800C152O5816C156O6067C158O6081C162O6093C177O6133C185O6093C190O6199C193O6227C197O6218C201O6243C204O6266C208O6257C212O6277C214O6292,,
code-creation,JS,10,76020,0x31e6f6b7c946,35,lazyModule node:internal/modules/helpers:110:20,0x31e647c77f38,~
code-source-info,0x31e6f6b7c946,64,3079,3173,C0O3086C12O3107C17O3145C24O3094C30O3156C34O3171,,
code-creation,JS,10,76118,0x31e6f6b7ccb6,14,require node:internal/modules/helpers:174:31,0x31e6f6b7c558,~
code-source-info,0x31e6f6b7ccb6,64,5340,5464,C0O5433C3O5444C8O5444C13O5458,,
code-creation,JS,10,76181,0x31e6f6b7cdfe,127,Module.require node:internal/modules/cjs/loader:1227:36,0x31e647c77248,~
code-source-info,0x31e6f6b7cdfe,63,39157,39448,C0O39166C8O39166C13O39194C15O39201C20O39215C36O39221C41O39215C42O39330C51O39342C60O39358C63O39372C76O39372C93O39427C102O39439C126O39447,,
code-creation,JS,11,76328,0x112585e80,1556,readPackageScope node:internal/modules/package_json_reader:149:26,0x31e647c78548,^
code-source-info,0x112585e80,65,4262,5057,,,
code-creation,JS,11,76360,0x1125864c0,1448,Module._nodeModulePaths node:internal/modules/cjs/loader:793:37,0x31e647c76dd8,^
code-source-info,0x1125864c0,63,24237,25417,,,
code-creation,JS,11,76392,0x112586a80,40,toNamespacedPath node:path:1269:19,0x31e647c5b810,^
code-source-info,0x112586a80,34,38744,38804,,,
code-creation,JS,11,76414,0x112586ac0,1316,dirname node:path:1278:10,0x31e647c5b860,^
code-source-info,0x112586ac0,34,38877,39546,,,
code-creation,JS,11,76434,0x112587000,272,validateString node:internal/validators:160:24,0x31e6931bf300,^
code-source-info,0x112587000,15,4120,4229,,,
code-creation,JS,11,76451,0x112587140,188,readPackage node:internal/modules/package_json_reader:140:21,0x31e647c784f8,^
code-source-info,0x112587140,65,3950,4020,,,
code-creation,JS,10,76525,0x31e6f6b7d58e,159,normalize node:path:1130:12,0x31e647c5b6d0,~
code-source-info,0x31e6f6b7d58e,34,34902,35506,C0O34915C8O34915C13O34959C19O34966C24O34979C26O34990C27O35021C34O35021C42O35060C44O35056C48O35116C53O35153C57O35160C61O35116C69O35169C71O35165C75O35220C80O35250C91O35227C98O35304C104O35311C109O35326C113O35350C115O35361C116O35368C126O35406C127O35417C131O35446C141O35464C150O35488C158O35502,,
code-creation,JS,10,76694,0x31e6f6b7d846,212,resolveExports node:internal/modules/cjs/loader:581:24,0x31e647c76cf8,~
code-source-info,0x31e6f6b7d846,63,16968,17763,C0O17106C7O17126C10O17106C19O17155C25O17074C32O17083C40O17171C44O17184C45O17191C46O17212C51O17217C56O17217C63O17254C68O17254C73O17287C79O17301C89O17370C95O17370C100O17344C105O17417C110O17477C115O17499C119O17477C129O17523C137O17555C140O17555C147O17446C158O17424C163O17591C175O17616C178O17622C185O17627C190O17665C197O17709C201O17671C206O17665C207O17743C209O17743C211O17762,,
code-creation,JS,10,76970,0x31e6f6b7da5e,45,tryExtensions node:internal/modules/cjs/loader:487:23,0x31e647c76bb8,~
code-source-info,0x31e6f6b7da5e,63,14187,14385,C0O14229C2O14241C6O14234C11O14277C16O14300C19O14294C23O14277C29O14319C31O14341C33O14357C34O14250C39O14216C43O14370C44O14383,,
code-creation,JS,10,77015,0x31e6f6b7dba6,62,tryFile node:internal/modules/cjs/loader:472:17,0x31e647c76b68,~
code-source-info,0x31e6f6b7dba6,63,13680,13900,C0O13717C5O13717C10O13739C11O13746C16O13755C17O13762C18O13767C26O13771C34O13813C36O13827C41O13839C46O13839C51O13860C52O13867C57O13874C61O13898,,
tick,0x7ff8092c9f8e,77118,1,0x10c217c00,6,0x10c41e000,0x31e6f6b6516f,0x31e6f6b7dbab,0x31e6f6b7da75,0x31e6f6b64c3a,0x31e6f6b62053,0x31e6f6b6075c,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f6b7a49a,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,Eval,10,77732,0x31e6f6b7e416,5, /Users/peterhage/Applications/WebStorm.app/Contents/plugins/javascript-debugger/debugConnectorUtil.js:1:1,0x31e6f6b7e2a0,~
script-source,82,/Users/peterhage/Applications/WebStorm.app/Contents/plugins/javascript-debugger/debugConnectorUtil.js,exports.getGatewayHostPort = () => {\n  const host = process.env.JB_NODE_DEBUG_CONNECTION_GATEWAY_HOST;\n  const port = parseInt(process.env.JB_NODE_DEBUG_CONNECTION_GATEWAY_PORT\x2C 10);\n  if (host != null && !isNaN(port) && port > 0) {\n    return {host: host\x2C port: port};\n  }\n  return null;\n};\n\nexports.forwardDebugConnectionAndWait = (debugPort) => {\n  const { spawn } = require('child_process');\n  const childProcessEnv = Object.assign({}\x2C process.env\x2C {\n    NODE_OPTIONS: ''\n  });\n  spawn(process.execPath\x2C [require.resolve('./debugConnectionForwarder.js')\x2C debugPort.toString()]\x2C {\n    env: childProcessEnv\x2C\n    stdio: 'inherit'\x2C\n    windowsHide: true\n  });\n\n  const inspector = require('inspector');\n  // https://nodejs.org/api/inspector.html#inspectorwaitfordebugger\n  if (typeof inspector.waitForDebugger === 'function') {\n    // Wait for IDE to register breakpoints and call `org.jetbrains.wip.protocol.runtime.RuntimeKt.RunIfWaitingForDebugger`.\n    inspector.waitForDebugger();\n  }\n  else {\n    console.error(formatMessage('debugConnectionForwarder'\x2C 'inspector.waitForDebugger is unavailable in ' + process.versions.node +\n      ' (added in v12.7.0). Some initial breakpoints might be skipped.'));\n  }\n};\n\nlet verboseLoggingEnabled = null;\n\nfunction isVerboseLoggingEnabled() {\n  if (verboseLoggingEnabled === null) {\n    verboseLoggingEnabled = process.env.JETBRAINS_NODE_DEBUGGER_VERBOSE_LOGGING != null;\n  }\n  return verboseLoggingEnabled;\n}\n\nexports.isVerboseLoggingEnabled = isVerboseLoggingEnabled;\n\nexports.formatMessage = (caller\x2C message) => {\n  const pidMsg = isVerboseLoggingEnabled() ? ' pid:' + process.pid + '\x2C ppid:' + process.ppid : '';\n  return '[' + caller + pidMsg + '] ' + message;\n};\n
code-source-info,0x31e6f6b7e416,82,0,1714,C0O0C4O1714,,
code-creation,JS,10,77918,0x31e6f6b7e6d6,53, /Users/peterhage/Applications/WebStorm.app/Contents/plugins/javascript-debugger/debugConnectorUtil.js:1:1,0x31e6f6b7e390,~
code-source-info,0x31e6f6b7e6d6,82,0,1714,C0O0C18O0C22O27C26O293C30O331C34O1243C35O1243C37O1455C39O1487C43O1515C47O1537C52O1713,,
code-creation,JS,10,78059,0x31e6f6b7ec4e,16, node:internal/modules/cjs/loader:122:3,0x31e647c763e8,~
code-source-info,0x31e6f6b7ec4e,63,3697,3751,C0O3741C6O3703C11O3741C15O3751,,
code-creation,Eval,10,78232,0x31e6f6b7f01e,5, node:internal/process/esm_loader:1:1,0x31e6f6b7ee58,~
script-source,83,node:internal/process/esm_loader,'use strict';\n\nconst { createModuleLoader } = require('internal/modules/esm/loader');\nconst { getOptionValue } = require('internal/options');\nconst {\n  hasUncaughtExceptionCaptureCallback\x2C\n} = require('internal/process/execution');\nconst { kEmptyObject\x2C getCWDURL } = require('internal/util');\n\nlet esmLoader;\n\nmodule.exports = {\n  get esmLoader() {\n    return esmLoader ??= createModuleLoader();\n  }\x2C\n  async loadESM(callback) {\n    esmLoader ??= createModuleLoader();\n    try {\n      const userImports = getOptionValue('--import');\n      if (userImports.length > 0) {\n        const parentURL = getCWDURL().href;\n        for (let i = 0; i < userImports.length; i++) {\n          await esmLoader.import(userImports[i]\x2C parentURL\x2C kEmptyObject);\n        }\n      } else {\n        esmLoader.forceLoadHooks();\n      }\n      await callback(esmLoader);\n    } catch (err) {\n      if (hasUncaughtExceptionCaptureCallback()) {\n        process._fatalException(err);\n        return;\n      }\n      internalBinding('errors').triggerUncaughtException(\n        err\x2C\n        true\x2C /* fromPromise */\n      );\n    }\n  }\x2C\n};\n
code-source-info,0x31e6f6b7f01e,83,0,1105,C0O0C4O1105,,
code-creation,JS,10,78431,0x31e6f6b7f20e,137, node:internal/process/esm_loader:1:1,0x31e6f6b7ef98,~
code-source-info,0x31e6f6b7f20e,83,0,1105,C0O0C31O46C34O46C39O23C45O113C48O113C53O94C59O193C62O193C67O152C73O268C76O268C81O240C87O254C93O299C94O299C96O311C101O404C131O326C136O1104,,
tick,0x7ff809250fcf,78479,1,0x10c1e6120,3,0x10c41e000,0x112583f26,0x112583ca1,0x31e6f6b7ec54,0x31e6f6b5f603,0x31e6f6b7289e,0x31e6f6b60853,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f6b7a49a,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,Eval,10,78887,0x31e6f25c956e,5, node:internal/modules/esm/loader:1:1,0x31e6f6b7fe28,~
script-source,84,node:internal/modules/esm/loader,'use strict';\n\n// This is needed to avoid cycles in esm/resolve <-> cjs/loader\nrequire('internal/modules/cjs/loader');\n\nconst {\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypeReduce\x2C\n  FunctionPrototypeCall\x2C\n  JSONStringify\x2C\n  ObjectSetPrototypeOf\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  SafeWeakMap\x2C\n  encodeURIComponent\x2C\n  hardenRegExp\x2C\n} = primordials;\n\nconst {\n  ERR_REQUIRE_ESM\x2C\n  ERR_UNKNOWN_MODULE_FORMAT\x2C\n} = require('internal/errors').codes;\nconst { getOptionValue } = require('internal/options');\nconst { pathToFileURL\x2C isURL } = require('internal/url');\nconst { emitExperimentalWarning } = require('internal/util');\nconst {\n  getDefaultConditions\x2C\n} = require('internal/modules/esm/utils');\nlet defaultResolve\x2C defaultLoad\x2C defaultLoadSync\x2C importMetaInitializer;\n\n/**\n * Lazy loads the module_map module and returns a new instance of ResolveCache.\n * @returns {import('./module_map.js').ResolveCache')}\n */\nfunction newResolveCache() {\n  const { ResolveCache } = require('internal/modules/esm/module_map');\n  return new ResolveCache();\n}\n\n/**\n * Generate a load cache (to store the final result of a load-chain for a particular module).\n * @returns {import('./module_map.js').LoadCache')}\n */\nfunction newLoadCache() {\n  const { LoadCache } = require('internal/modules/esm/module_map');\n  return new LoadCache();\n}\n\n/**\n * Lazy-load translators to avoid potentially unnecessary work at startup (ex if ESM is not used).\n * @returns {import('./translators.js').Translators}\n */\nfunction getTranslators() {\n  const { translators } = require('internal/modules/esm/translators');\n  return translators;\n}\n\n/**\n * @type {HooksProxy}\n * Multiple loader instances exist for various\x2C specific reasons (see code comments at site).\n * In order to maintain consistency\x2C we use a single worker (sandbox)\x2C which must sit apart of an\n * individual loader instance.\n */\nlet hooksProxy;\n\n/**\n * @typedef {Record<string\x2C any>} ModuleExports\n */\n\n/**\n * @typedef {'builtin'|'commonjs'|'json'|'module'|'wasm'} ModuleFormat\n */\n\n/**\n * @typedef {ArrayBuffer|TypedArray|string} ModuleSource\n */\n\n/**\n * This class covers the base machinery of module loading. To add custom\n * behavior you can pass a customizations object and this object will be\n * used to do the loading/resolving/registration process.\n */\nclass ModuleLoader {\n  /**\n   * The conditions for resolving packages if `--conditions` is not used.\n   */\n  #defaultConditions = getDefaultConditions();\n\n  /**\n   * Map of already-loaded CJS modules to use\n   */\n  cjsCache = new SafeWeakMap();\n\n  /**\n   * The index for assigning unique URLs to anonymous module evaluation\n   */\n  evalIndex = 0;\n\n  /**\n   * Registry of resolved specifiers\n   */\n  #resolveCache = newResolveCache();\n\n  /**\n   * Registry of loaded modules\x2C akin to `require.cache`\n   */\n  loadCache = newLoadCache();\n\n  /**\n   * Methods which translate input code or other information into ES modules\n   */\n  translators = getTranslators();\n\n  /**\n   * Truthy to allow the use of `import.meta.resolve`. This is needed\n   * currently because the `Hooks` class does not have `resolveSync`\n   * implemented and `import.meta.resolve` requires it.\n   */\n  allowImportMetaResolve;\n\n  /**\n   * Customizations to pass requests to.\n   *\n   * Note that this value _MUST_ be set with `setCustomizations`\n   * because it needs to copy `customizations.allowImportMetaResolve`\n   *  to this property and failure to do so will cause undefined\n   * behavior when invoking `import.meta.resolve`.\n   * @see {ModuleLoader.setCustomizations}\n   */\n  #customizations;\n\n  constructor(customizations) {\n    if (getOptionValue('--experimental-network-imports')) {\n      emitExperimentalWarning('Network Imports');\n    }\n    this.setCustomizations(customizations);\n  }\n\n  /**\n   * Change the currently activate customizations for this module\n   * loader to be the provided `customizations`.\n   *\n   * If present\x2C this class customizes its core functionality to the\n   * `customizations` object\x2C including registration\x2C loading\x2C and resolving.\n   * There are some responsibilities that this class _always_ takes\n   * care of\x2C like validating outputs\x2C so that the customizations object\n   * does not have to do so.\n   *\n   * The customizations object has the shape:\n   *\n   * ```ts\n   * interface LoadResult {\n   *   format: ModuleFormat;\n   *   source: ModuleSource;\n   * }\n   *\n   * interface ResolveResult {\n   *   format: string;\n   *   url: URL['href'];\n   * }\n   *\n   * interface Customizations {\n   *   allowImportMetaResolve: boolean;\n   *   load(url: string\x2C context: object): Promise<LoadResult>\n   *   resolve(\n   *     originalSpecifier:\n   *     string\x2C parentURL: string\x2C\n   *     importAttributes: Record<string\x2C string>\n   *   ): Promise<ResolveResult>\n   *   resolveSync(\n   *     originalSpecifier:\n   *     string\x2C parentURL: string\x2C\n   *     importAttributes: Record<string\x2C string>\n   *   ) ResolveResult;\n   *   register(specifier: string\x2C parentURL: string): any;\n   *   forceLoadHooks(): void;\n   * }\n   * ```\n   *\n   * Note that this class _also_ implements the `Customizations`\n   * interface\x2C as does `CustomizedModuleLoader` and `Hooks`.\n   *\n   * Calling this function alters how modules are loaded and should be\n   * invoked with care.\n   * @param {object} customizations\n   */\n  setCustomizations(customizations) {\n    this.#customizations = customizations;\n    if (customizations) {\n      this.allowImportMetaResolve = customizations.allowImportMetaResolve;\n    } else {\n      this.allowImportMetaResolve = true;\n    }\n  }\n\n  async eval(\n    source\x2C\n    url = pathToFileURL(`${process.cwd()}/[eval${++this.evalIndex}]`).href\x2C\n  ) {\n    const evalInstance = (url) => {\n      const { ModuleWrap } = internalBinding('module_wrap');\n      const { registerModule } = require('internal/modules/esm/utils');\n      const module = new ModuleWrap(url\x2C undefined\x2C source\x2C 0\x2C 0);\n      registerModule(module\x2C {\n        __proto__: null\x2C\n        initializeImportMeta: (meta\x2C wrap) => this.importMetaInitialize(meta\x2C { url })\x2C\n        importModuleDynamically: (specifier\x2C { url }\x2C importAttributes) => {\n          return this.import(specifier\x2C url\x2C importAttributes);\n        }\x2C\n      });\n\n      return module;\n    };\n    const ModuleJob = require('internal/modules/esm/module_job');\n    const job = new ModuleJob(\n      this\x2C url\x2C undefined\x2C evalInstance\x2C false\x2C false);\n    this.loadCache.set(url\x2C undefined\x2C job);\n    const { module } = await job.run();\n\n    return {\n      __proto__: null\x2C\n      namespace: module.getNamespace()\x2C\n    };\n  }\n\n  /**\n   * Get a (possibly still pending) module job from the cache\x2C\n   * or create one and return its Promise.\n   * @param {string} specifier The string after `from` in an `import` statement\x2C\n   *                           or the first parameter of an `import()`\n   *                           expression\n   * @param {string | undefined} parentURL The URL of the module importing this\n   *                                     one\x2C unless this is the Node.js entry\n   *                                     point.\n   * @param {Record<string\x2C string>} importAttributes Validations for the\n   *                                                  module import.\n   * @returns {Promise<ModuleJob>} The (possibly pending) module job\n   */\n  async getModuleJob(specifier\x2C parentURL\x2C importAttributes) {\n    const resolveResult = await this.resolve(specifier\x2C parentURL\x2C importAttributes);\n    return this.getJobFromResolveResult(resolveResult\x2C parentURL\x2C importAttributes);\n  }\n\n  getModuleJobSync(specifier\x2C parentURL\x2C importAttributes) {\n    const resolveResult = this.resolveSync(specifier\x2C parentURL\x2C importAttributes);\n    return this.getJobFromResolveResult(resolveResult\x2C parentURL\x2C importAttributes\x2C true);\n  }\n\n  getJobFromResolveResult(resolveResult\x2C parentURL\x2C importAttributes\x2C sync) {\n    const { url\x2C format } = resolveResult;\n    const resolvedImportAttributes = resolveResult.importAttributes ?? importAttributes;\n    let job = this.loadCache.get(url\x2C resolvedImportAttributes.type);\n\n    // CommonJS will set functions for lazy job evaluation.\n    if (typeof job === 'function') {\n      this.loadCache.set(url\x2C undefined\x2C job = job());\n    }\n\n    if (job === undefined) {\n      job = this.#createModuleJob(url\x2C resolvedImportAttributes\x2C parentURL\x2C format\x2C sync);\n    }\n\n    return job;\n  }\n\n  /**\n   * Create and cache an object representing a loaded module.\n   * @param {string} url The absolute URL that was resolved for this module\n   * @param {Record<string\x2C string>} importAttributes Validations for the\n   *                                                  module import.\n   * @param {string} [parentURL] The absolute URL of the module importing this\n   *                             one\x2C unless this is the Node.js entry point\n   * @param {string} [format] The format hint possibly returned by the\n   *                          `resolve` hook\n   * @returns {Promise<ModuleJob>} The (possibly pending) module job\n   */\n  #createModuleJob(url\x2C importAttributes\x2C parentURL\x2C format\x2C sync) {\n    const callTranslator = ({ format: finalFormat\x2C responseURL\x2C source }\x2C isMain) => {\n      const translator = getTranslators().get(finalFormat);\n\n      if (!translator) {\n        throw new ERR_UNKNOWN_MODULE_FORMAT(finalFormat\x2C responseURL);\n      }\n\n      return FunctionPrototypeCall(translator\x2C this\x2C responseURL\x2C source\x2C isMain);\n    };\n    const context = { format\x2C importAttributes };\n\n    const moduleProvider = sync ?\n      (url\x2C isMain) => callTranslator(this.loadSync(url\x2C context)\x2C isMain) :\n      async (url\x2C isMain) => callTranslator(await this.load(url\x2C context)\x2C isMain);\n\n    const inspectBrk = (\n      parentURL === undefined &&\n      getOptionValue('--inspect-brk')\n    );\n\n    if (process.env.WATCH_REPORT_DEPENDENCIES && process.send) {\n      process.send({ 'watch:import': [url] });\n    }\n\n    const ModuleJob = require('internal/modules/esm/module_job');\n    const job = new ModuleJob(\n      this\x2C\n      url\x2C\n      importAttributes\x2C\n      moduleProvider\x2C\n      parentURL === undefined\x2C\n      inspectBrk\x2C\n      sync\x2C\n    );\n\n    this.loadCache.set(url\x2C importAttributes.type\x2C job);\n\n    return job;\n  }\n\n  /**\n   * This method is usually called indirectly as part of the loading processes.\n   * Use directly with caution.\n   * @param {string} specifier The first parameter of an `import()` expression.\n   * @param {string} parentURL Path of the parent importing the module.\n   * @param {Record<string\x2C string>} importAttributes Validations for the\n   *                                                  module import.\n   * @returns {Promise<ModuleExports>}\n   */\n  async import(specifier\x2C parentURL\x2C importAttributes) {\n    const moduleJob = await this.getModuleJob(specifier\x2C parentURL\x2C importAttributes);\n    const { module } = await moduleJob.run();\n    return module.getNamespace();\n  }\n\n  /**\n   * @see {@link CustomizedModuleLoader.register}\n   */\n  register(specifier\x2C parentURL\x2C data\x2C transferList) {\n    if (!this.#customizations) {\n      // `CustomizedModuleLoader` is defined at the bottom of this file and\n      // available well before this line is ever invoked. This is here in\n      // order to preserve the git diff instead of moving the class.\n      // eslint-disable-next-line no-use-before-define\n      this.setCustomizations(new CustomizedModuleLoader());\n    }\n    return this.#customizations.register(`${specifier}`\x2C `${parentURL}`\x2C data\x2C transferList);\n  }\n\n  /**\n   * Resolve the location of the module.\n   * @param {string} originalSpecifier The specified URL path of the module to\n   *                                   be resolved.\n   * @param {string} [parentURL] The URL path of the module's parent.\n   * @param {ImportAttributes} importAttributes Attributes from the import\n   *                                            statement or expression.\n   * @returns {{ format: string\x2C url: URL['href'] }}\n   */\n  resolve(originalSpecifier\x2C parentURL\x2C importAttributes) {\n    if (this.#customizations) {\n      return this.#customizations.resolve(originalSpecifier\x2C parentURL\x2C importAttributes);\n    }\n    const requestKey = this.#resolveCache.serializeKey(originalSpecifier\x2C importAttributes);\n    const cachedResult = this.#resolveCache.get(requestKey\x2C parentURL);\n    if (cachedResult != null) {\n      return cachedResult;\n    }\n    const result = this.defaultResolve(originalSpecifier\x2C parentURL\x2C importAttributes);\n    this.#resolveCache.set(requestKey\x2C parentURL\x2C result);\n    return result;\n  }\n\n  /**\n   * Just like `resolve` except synchronous. This is here specifically to support\n   * `import.meta.resolve` which must happen synchronously.\n   */\n  resolveSync(originalSpecifier\x2C parentURL\x2C importAttributes) {\n    if (this.#customizations) {\n      return this.#customizations.resolveSync(originalSpecifier\x2C parentURL\x2C importAttributes);\n    }\n    return this.defaultResolve(originalSpecifier\x2C parentURL\x2C importAttributes);\n  }\n\n  /**\n   * Our `defaultResolve` is synchronous and can be used in both\n   * `resolve` and `resolveSync`. This function is here just to avoid\n   * repeating the same code block twice in those functions.\n   */\n  defaultResolve(originalSpecifier\x2C parentURL\x2C importAttributes) {\n    defaultResolve ??= require('internal/modules/esm/resolve').defaultResolve;\n\n    const context = {\n      __proto__: null\x2C\n      conditions: this.#defaultConditions\x2C\n      importAttributes\x2C\n      parentURL\x2C\n    };\n\n    return defaultResolve(originalSpecifier\x2C context);\n  }\n\n  /**\n   * Provide source that is understood by one of Node's translators.\n   * @param {URL['href']} url The URL/path of the module to be loaded\n   * @param {object} [context] Metadata about the module\n   * @returns {Promise<{ format: ModuleFormat\x2C source: ModuleSource }>}\n   */\n  async load(url\x2C context) {\n    defaultLoad ??= require('internal/modules/esm/load').defaultLoad;\n    const result = this.#customizations ?\n      await this.#customizations.load(url\x2C context) :\n      await defaultLoad(url\x2C context);\n    this.validateLoadResult(url\x2C result?.format);\n    return result;\n  }\n\n  loadSync(url\x2C context) {\n    defaultLoadSync ??= require('internal/modules/esm/load').defaultLoadSync;\n\n    let result = this.#customizations ?\n      this.#customizations.loadSync(url\x2C context) :\n      defaultLoadSync(url\x2C context);\n    let format = result?.format;\n    if (format === 'module') {\n      throw new ERR_REQUIRE_ESM(url\x2C true);\n    }\n    if (format === 'commonjs') {\n      format = 'require-commonjs';\n      result = { __proto__: result\x2C format };\n    }\n    this.validateLoadResult(url\x2C format);\n    return result;\n  }\n\n  validateLoadResult(url\x2C format) {\n    if (format == null) {\n      require('internal/modules/esm/load').throwUnknownModuleFormat(url\x2C format);\n    }\n  }\n\n  importMetaInitialize(meta\x2C context) {\n    if (this.#customizations) {\n      return this.#customizations.importMetaInitialize(meta\x2C context\x2C this);\n    }\n    importMetaInitializer ??= require('internal/modules/esm/initialize_import_meta').initializeImportMeta;\n    meta = importMetaInitializer(meta\x2C context\x2C this);\n    return meta;\n  }\n\n  /**\n   * No-op when no hooks have been supplied.\n   */\n  forceLoadHooks() {\n    this.#customizations?.forceLoadHooks();\n  }\n}\nObjectSetPrototypeOf(ModuleLoader.prototype\x2C null);\n\nclass CustomizedModuleLoader {\n\n  allowImportMetaResolve = true;\n\n  /**\n   * Instantiate a module loader that uses user-provided custom loader hooks.\n   */\n  constructor() {\n    getHooksProxy();\n  }\n\n  /**\n   * Register some loader specifier.\n   * @param {string} originalSpecifier The specified URL path of the loader to\n   *                                   be registered.\n   * @param {string} parentURL The parent URL from where the loader will be\n   *                           registered if using it package name as specifier\n   * @param {any} [data] Arbitrary data to be passed from the custom loader\n   * (user-land) to the worker.\n   * @param {any[]} [transferList] Objects in `data` that are changing ownership\n   * @returns {{ format: string\x2C url: URL['href'] }}\n   */\n  register(originalSpecifier\x2C parentURL\x2C data\x2C transferList) {\n    return hooksProxy.makeSyncRequest('register'\x2C transferList\x2C originalSpecifier\x2C parentURL\x2C data);\n  }\n\n  /**\n   * Resolve the location of the module.\n   * @param {string} originalSpecifier The specified URL path of the module to\n   *                                   be resolved.\n   * @param {string} [parentURL] The URL path of the module's parent.\n   * @param {ImportAttributes} importAttributes Attributes from the import\n   *                                            statement or expression.\n   * @returns {{ format: string\x2C url: URL['href'] }}\n   */\n  resolve(originalSpecifier\x2C parentURL\x2C importAttributes) {\n    return hooksProxy.makeAsyncRequest('resolve'\x2C undefined\x2C originalSpecifier\x2C parentURL\x2C importAttributes);\n  }\n\n  resolveSync(originalSpecifier\x2C parentURL\x2C importAttributes) {\n    // This happens only as a result of `import.meta.resolve` calls\x2C which must be sync per spec.\n    return hooksProxy.makeSyncRequest('resolve'\x2C undefined\x2C originalSpecifier\x2C parentURL\x2C importAttributes);\n  }\n\n  /**\n   * Provide source that is understood by one of Node's translators.\n   * @param {URL['href']} url The URL/path of the module to be loaded\n   * @param {object} [context] Metadata about the module\n   * @returns {Promise<{ format: ModuleFormat\x2C source: ModuleSource }>}\n   */\n  load(url\x2C context) {\n    return hooksProxy.makeAsyncRequest('load'\x2C undefined\x2C url\x2C context);\n  }\n  loadSync(url\x2C context) {\n    return hooksProxy.makeSyncRequest('load'\x2C undefined\x2C url\x2C context);\n  }\n\n  importMetaInitialize(meta\x2C context\x2C loader) {\n    hooksProxy.importMetaInitialize(meta\x2C context\x2C loader);\n  }\n\n  forceLoadHooks() {\n    hooksProxy.waitForWorker();\n  }\n}\n\nlet emittedLoaderFlagWarning = false;\n/**\n * A loader instance is used as the main entry point for loading ES modules. Currently\x2C this is a singleton; there is\n * only one used for loading the main module and everything in its dependency graph\x2C though separate instances of this\n * class might be instantiated as part of bootstrap for other purposes.\n * @returns {ModuleLoader}\n */\nfunction createModuleLoader() {\n  let customizations = null;\n  // Don't spawn a new worker if custom loaders are disabled. For instance\x2C if\n  // we're already in a worker thread created by instantiating\n  // CustomizedModuleLoader; doing so would cause an infinite loop.\n  if (!require('internal/modules/esm/utils').forceDefaultLoader()) {\n    const userLoaderPaths = getOptionValue('--experimental-loader');\n    if (userLoaderPaths.length > 0) {\n      if (!emittedLoaderFlagWarning) {\n        const readableURIEncode = (string) => ArrayPrototypeReduce(\n          [\n            [/'/g\x2C '%27']\x2C // We need to URL-encode the single quote as it's the delimiter for the --import flag.\n            [/%22/g\x2C '"']\x2C // We can decode the double quotes to improve readability.\n            [/%2F/ig\x2C '/']\x2C // We can decode the slashes to improve readability.\n          ]\x2C\n          (str\x2C { 0: regex\x2C 1: replacement }) => RegExpPrototypeSymbolReplace(hardenRegExp(regex)\x2C str\x2C replacement)\x2C\n          encodeURIComponent(string));\n        process.emitWarning(\n          '`--experimental-loader` may be removed in the future; instead use `register()`:\\n' +\n          `--import 'data:text/javascript\x2Cimport { register } from "node:module"; import { pathToFileURL } from "node:url"; ${ArrayPrototypeJoin(\n            ArrayPrototypeMap(userLoaderPaths\x2C (loader) => `register(${readableURIEncode(JSONStringify(loader))}\x2C pathToFileURL("./"))`)\x2C\n            '; '\x2C\n          )};'`\x2C\n          'ExperimentalWarning'\x2C\n        );\n        emittedLoaderFlagWarning = true;\n      }\n      customizations = new CustomizedModuleLoader();\n    }\n  }\n\n  return new ModuleLoader(customizations);\n}\n\n\n/**\n * Get the HooksProxy instance. If it is not defined\x2C then create a new one.\n * @returns {HooksProxy}\n */\nfunction getHooksProxy() {\n  if (!hooksProxy) {\n    const { HooksProxy } = require('internal/modules/esm/hooks');\n    hooksProxy = new HooksProxy();\n  }\n\n  return hooksProxy;\n}\n\n/**\n * Register a single loader programmatically.\n * @param {string|import('url').URL} specifier\n * @param {string|import('url').URL} [parentURL] Base to use when resolving `specifier`; optional if\n * `specifier` is absolute. Same as `options.parentUrl`\x2C just inline\n * @param {object} [options] Additional options to apply\x2C described below.\n * @param {string|import('url').URL} [options.parentURL] Base to use when resolving `specifier`\n * @param {any} [options.data] Arbitrary data passed to the loader's `initialize` hook\n * @param {any[]} [options.transferList] Objects in `data` that are changing ownership\n * @returns {void} We want to reserve the return value for potential future extension of the API.\n * @example\n * ```js\n * register('./myLoader.js');\n * register('ts-node/esm'\x2C { parentURL: import.meta.url });\n * register('./myLoader.js'\x2C { parentURL: import.meta.url });\n * register('ts-node/esm'\x2C import.meta.url);\n * register('./myLoader.js'\x2C import.meta.url);\n * register(new URL('./myLoader.js'\x2C import.meta.url));\n * register('./myLoader.js'\x2C {\n *   parentURL: import.meta.url\x2C\n *   data: { banana: 'tasty' }\x2C\n * });\n * register('./myLoader.js'\x2C {\n *   parentURL: import.meta.url\x2C\n *   data: someArrayBuffer\x2C\n *   transferList: [someArrayBuffer]\x2C\n * });\n * ```\n */\nfunction register(specifier\x2C parentURL = undefined\x2C options) {\n  const moduleLoader = require('internal/process/esm_loader').esmLoader;\n  if (parentURL != null && typeof parentURL === 'object' && !isURL(parentURL)) {\n    options = parentURL;\n    parentURL = options.parentURL;\n  }\n  moduleLoader.register(\n    specifier\x2C\n    parentURL ?? 'data:'\x2C\n    options?.data\x2C\n    options?.transferList\x2C\n  );\n}\n\nmodule.exports = {\n  createModuleLoader\x2C\n  getHooksProxy\x2C\n  register\x2C\n};\n
code-source-info,0x31e6f25c956e,84,0,21896,C0O0C4O21896,,
code-creation,JS,10,80570,0x31e6f25ca70e,597, node:internal/modules/esm/loader:1:1,0x31e6f25c94e8,~
code-source-info,0x31e6f25ca70e,84,0,21896,C0O0C123O79C129O79C133O130C139O152C145O173C151O197C157O222C163O239C168O263C174O295C180O310C186O332C192O424C198O424C203O450C208O374C214O393C220O485C226O485C231O466C237O547C243O547C248O522C254O537C260O608C266O608C271O580C277O670C283O670C288O644C294O713C295O713C297O729C298O729C300O742C301O742C303O759C304O759C306O1876C307O1876C481O2304C483O15240C486O15274C493O15240C561O15293C563O17836C564O17836C566O21823C573O21844C579O21866C585O21883C591O21838C596O21895,,
code-creation,JS,10,80637,0x31e6f25caa8e,7,<instance_members_initializer> node:internal/modules/esm/loader:456:1,0x31e6f25c9f88,~
code-source-info,0x31e6f25caa8e,84,15293,17803,C0O15352C6O17803,,
code-creation,JS,10,80675,0x31e6f25cab4e,95,<instance_members_initializer> node:internal/modules/esm/loader:83:1,0x31e6f25c9cd0,~
code-source-info,0x31e6f25cab4e,84,2304,15239,C3O2434C10O2434C18O2530C25O2530C34O2648C42O2719C47O2719C55O2822C60O2822C67O2944C72O2944C80O3172C88O3551C94O15239,,
tick,0x10c1659ec,80720,1,0x10c1e6120,3,0x10c41e000,0x112583f26,0x112583ca1,0x31e6f6b7f230,0x112583feb,0x112583ca1,0x31e6f6b7ec54,0x31e6f6b5f603,0x31e6f6b7289e,0x31e6f6b60853,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f6b7a49a,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
tick,0x7ff8092cae7e,80832,1,0x10c1e6120,3,0x10c41e000,0x112583f26,0x112583ca1,0x31e6f6b7f230,0x112583feb,0x112583ca1,0x31e6f6b7ec54,0x31e6f6b5f603,0x31e6f6b7289e,0x31e6f6b60853,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f6b7a49a,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,81095,0x31e6f25cc926,26,get esmLoader node:internal/process/esm_loader:13:16,0x31e6f6b7f0c0,~
code-source-info,0x31e6f25cc926,83,345,400,C0O354C10O375C13O375C19O371C25O396,,
code-creation,JS,10,81255,0x31e6f25cce5e,179,createModuleLoader node:internal/modules/esm/loader:529:28,0x31e6f25c9690,~
code-source-info,0x31e6f25cce5e,84,18214,19849,C0O18242C2O18460C8O18465C13O18502C18O18503C24O18555C32O18555C37O18620C43O18627C48O18640C61O18707C65O18707C67O19212C72O19220C87O19455C94O19487C97O19505C102O19487C111O19455C126O19327C133O19220C139O19700C145O19725C155O19747C160O19764C166O19807C173O19814C178O19847,,
code-creation,JS,10,81297,0x31e6f25ce426,5,forceDefaultLoader node:internal/modules/esm/utils:237:28,0x31e647c78c98,~
code-source-info,0x31e6f25ce426,66,8157,8193,C0O8164C4O8191,,
code-creation,JS,10,81334,0x31e6f25ce55e,66,ModuleLoader node:internal/modules/esm/loader:132:14,0x31e6f25c97d0,~
code-source-info,0x31e6f25ce55e,84,3582,3764,C5O3582C24O3605C34O3609C40O3667C50O3667C54O3726C59O3726C65O3763,,
code-creation,JS,10,81379,0x31e6f25ce766,21,getDefaultConditions node:internal/modules/esm/utils:42:30,0x31e647c787d0,~
code-source-info,0x31e6f25ce766,66,965,1042,C0O972C7O979C10O997C12O972C16O1015C20O1040,,
code-creation,JS,10,81424,0x31e6f25cea2e,22,newResolveCache node:internal/modules/esm/loader:35:25,0x31e6f25c95a0,~
code-source-info,0x31e6f25cea2e,84,950,1056,C0O982C6O982C11O965C16O1035C21O1054,,
code-creation,Eval,10,81558,0x31e6f25cef7e,5, node:internal/modules/esm/module_map:1:1,0x31e6f25cecc8,~
script-source,85,node:internal/modules/esm/module_map,'use strict';\n\nconst {\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypeSort\x2C\n  JSONStringify\x2C\n  ObjectKeys\x2C\n  SafeMap\x2C\n} = primordials;\nconst { kImplicitAssertType } = require('internal/modules/esm/assert');\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\nconst { ERR_INVALID_ARG_TYPE } = require('internal/errors').codes;\nconst { validateString } = require('internal/validators');\n\n/**\n * Cache the results of the `resolve` step of the module resolution and loading process.\n * Future resolutions of the same input (specifier\x2C parent URL and import attributes)\n * must return the same result if the first attempt was successful\x2C per\n * https://tc39.es/ecma262/#sec-HostLoadImportedModule.\n * This cache is *not* used when custom loaders are registered.\n */\nclass ResolveCache extends SafeMap {\n  constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n\n  /**\n   * Generates the internal serialized cache key and returns it along the actual cache object.\n   *\n   * It is exposed to allow more efficient read and overwrite a cache entry.\n   * @param {string} specifier\n   * @param {Record<string\x2Cstring>} importAttributes\n   * @returns {string}\n   */\n  serializeKey(specifier\x2C importAttributes) {\n    // To serialize the ModuleRequest (specifier + list of import attributes)\x2C\n    // we need to sort the attributes by key\x2C then stringifying\x2C\n    // so that different import statements with the same attributes are always treated\n    // as identical.\n    const keys = ObjectKeys(importAttributes);\n\n    if (keys.length === 0) {\n      return specifier + '::';\n    }\n\n    return specifier + '::' + ArrayPrototypeJoin(\n      ArrayPrototypeMap(\n        ArrayPrototypeSort(keys)\x2C\n        (key) => JSONStringify(key) + JSONStringify(importAttributes[key]))\x2C\n      '\x2C');\n  }\n\n  #getModuleCachedImports(parentURL) {\n    let internalCache = super.get(parentURL);\n    if (internalCache == null) {\n      super.set(parentURL\x2C internalCache = { __proto__: null });\n    }\n    return internalCache;\n  }\n\n  /**\n   * @param {string} serializedKey\n   * @param {string} parentURL\n   * @returns {import('./loader').ModuleExports | Promise<import('./loader').ModuleExports>}\n   */\n  get(serializedKey\x2C parentURL) {\n    return this.#getModuleCachedImports(parentURL)[serializedKey];\n  }\n\n  /**\n   * @param {string} serializedKey\n   * @param {string} parentURL\n   * @param {{ format: string\x2C url: URL['href'] }} result\n   */\n  set(serializedKey\x2C parentURL\x2C result) {\n    this.#getModuleCachedImports(parentURL)[serializedKey] = result;\n    return this;\n  }\n\n  has(serializedKey\x2C parentURL) {\n    return serializedKey in this.#getModuleCachedImports(parentURL);\n  }\n}\n\n/**\n * Cache the results of the `load` step of the module resolution and loading process.\n */\nclass LoadCache extends SafeMap {\n  constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  get(url\x2C type = kImplicitAssertType) {\n    validateString(url\x2C 'url');\n    validateString(type\x2C 'type');\n    return super.get(url)?.[type];\n  }\n  set(url\x2C type = kImplicitAssertType\x2C job) {\n    validateString(url\x2C 'url');\n    validateString(type\x2C 'type');\n\n    const ModuleJob = require('internal/modules/esm/module_job');\n    if (job instanceof ModuleJob !== true &&\n        typeof job !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE('job'\x2C 'ModuleJob'\x2C job);\n    }\n    debug(`Storing ${url} (${\n      type === kImplicitAssertType ? 'implicit type' : type\n    }) in ModuleLoadMap`);\n    const cachedJobsForUrl = super.get(url) ?? { __proto__: null };\n    cachedJobsForUrl[type] = job;\n    return super.set(url\x2C cachedJobsForUrl);\n  }\n  has(url\x2C type = kImplicitAssertType) {\n    validateString(url\x2C 'url');\n    validateString(type\x2C 'type');\n    return super.get(url)?.[type] !== undefined;\n  }\n}\n\nmodule.exports = {\n  LoadCache\x2C\n  ResolveCache\x2C\n};\n
code-source-info,0x31e6f25cef7e,85,0,3877,C0O0C4O3877,,
code-creation,JS,10,81799,0x31e6f25cf7d6,299, node:internal/modules/esm/module_map:1:1,0x31e6f25ceef8,~
code-source-info,0x31e6f25cf7d6,85,0,3877,C0O0C36O25C42O47C48O68C54O90C60O107C66O121C71O179C77O179C82O155C88O231C94O231C99O264C112O265C118O231C120O342C126O342C131O368C136O317C142O403C148O403C153O384C179O838C227O811C231O2832C274O3826C281O3847C287O3860C293O3841C298O3876,,
tick,0x10c6be134,81948,1,0x10c1e6120,3,0x10c41e000,0x112583f26,0x112583ca1,0x31e6f25cf823,0x112583feb,0x112583ca1,0x31e6f25cea34,0x31e6f25cab7d,0x31e6f25ce56f,0x31e6f25ccf0b,0x31e6f25cc933,0x31e6f6b7ec59,0x31e6f6b5f603,0x31e6f6b7289e,0x31e6f6b60853,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f6b7a49a,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,Eval,10,81980,0x31e6f25d02de,5, node:internal/modules/esm/assert:1:1,0x31e6f25d00d8,~
script-source,86,node:internal/modules/esm/assert,'use strict';\n\nconst {\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ObjectKeys\x2C\n  ObjectValues\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n} = primordials;\nconst { validateString } = require('internal/validators');\n\nconst {\n  ERR_IMPORT_ASSERTION_TYPE_FAILED\x2C\n  ERR_IMPORT_ASSERTION_TYPE_MISSING\x2C\n  ERR_IMPORT_ASSERTION_TYPE_UNSUPPORTED\x2C\n  ERR_IMPORT_ATTRIBUTE_UNSUPPORTED\x2C\n} = require('internal/errors').codes;\n\n// The HTML spec has an implied default type of `'javascript'`.\nconst kImplicitAssertType = 'javascript';\n\n/**\n * Define a map of module formats to import attributes types (the value of\n * `type` in `with { type: 'json' }`).\n * @type {Map<string\x2C string>}\n */\nconst formatTypeMap = {\n  '__proto__': null\x2C\n  'builtin': kImplicitAssertType\x2C\n  'commonjs': kImplicitAssertType\x2C\n  'json': 'json'\x2C\n  'module': kImplicitAssertType\x2C\n  'wasm': kImplicitAssertType\x2C // It's unclear whether the HTML spec will require an attribute type or not for Wasm; see https://github.com/WebAssembly/esm-integration/issues/42\n};\n\n/**\n * The HTML spec disallows the default type to be explicitly specified\n * (for now); so `import './file.js'` is okay but\n * `import './file.js' with { type: 'javascript' }` throws.\n * @type {Array<string\x2C string>}\n */\nconst supportedAssertionTypes = ArrayPrototypeFilter(\n  ObjectValues(formatTypeMap)\x2C\n  (type) => type !== kImplicitAssertType);\n\n\n/**\n * Test a module's import attributes.\n * @param {string} url The URL of the imported module\x2C for error reporting.\n * @param {string} format One of Node's supported translators\n * @param {Record<string\x2C string>} importAttributes Validations for the\n *                                                  module import.\n * @returns {true}\n * @throws {TypeError} If the format and assertion type are incompatible.\n */\nfunction validateAttributes(url\x2C format\x2C\n                            importAttributes = { __proto__: null }) {\n  const keys = ObjectKeys(importAttributes);\n  for (let i = 0; i < keys.length; i++) {\n    if (keys[i] !== 'type') {\n      throw new ERR_IMPORT_ATTRIBUTE_UNSUPPORTED(keys[i]\x2C importAttributes[keys[i]]);\n    }\n  }\n  const validType = formatTypeMap[format];\n\n  switch (validType) {\n    case undefined:\n      // Ignore attributes for module formats we don't recognize\x2C to allow new\n      // formats in the future.\n      return true;\n\n    case kImplicitAssertType:\n      // This format doesn't allow an import assertion type\x2C so the property\n      // must not be set on the import attributes object.\n      if (!ObjectPrototypeHasOwnProperty(importAttributes\x2C 'type')) {\n        return true;\n      }\n      return handleInvalidType(url\x2C importAttributes.type);\n\n    case importAttributes.type:\n      // The asserted type is the valid type for this format.\n      return true;\n\n    default:\n      // There is an expected type for this format\x2C but the value of\n      // `importAttributes.type` might not have been it.\n      if (!ObjectPrototypeHasOwnProperty(importAttributes\x2C 'type')) {\n        // `type` wasn't specified at all.\n        throw new ERR_IMPORT_ASSERTION_TYPE_MISSING(url\x2C validType);\n      }\n      return handleInvalidType(url\x2C importAttributes.type);\n  }\n}\n\n/**\n * Throw the correct error depending on what's wrong with the type assertion.\n * @param {string} url The resolved URL for the module to be imported\n * @param {string} type The value of the import assertion `type` property\n */\nfunction handleInvalidType(url\x2C type) {\n  // `type` might have not been a string.\n  validateString(type\x2C 'type');\n\n  // `type` might not have been one of the types we understand.\n  if (!ArrayPrototypeIncludes(supportedAssertionTypes\x2C type)) {\n    throw new ERR_IMPORT_ASSERTION_TYPE_UNSUPPORTED(type);\n  }\n\n  // `type` was the wrong value for this format.\n  throw new ERR_IMPORT_ASSERTION_TYPE_FAILED(url\x2C type);\n}\n\n\nmodule.exports = {\n  kImplicitAssertType\x2C\n  validateAttributes\x2C\n};\n
code-source-info,0x31e6f25d02de,86,0,3876,C0O0C4O3876,,
code-creation,JS,10,82254,0x31e6f25d05be,210, node:internal/modules/esm/assert:1:1,0x31e6f25d0258,~
code-source-info,0x31e6f25d05be,86,0,3876,C0O0C49O25C54O49C60O75C66O89C71O105C77O180C80O180C85O161C91O375C94O375C99O401C104O223C110O259C116O296C122O337C128O502C130O502C132O692C139O728C145O763C151O814C157O845C163O692C165O1271C168O1295C178O1271C183O1271C185O3809C192O3830C198O3853C204O3824C209O3875,,
code-creation,JS,10,82354,0x31e6f25d0c0e,9, node:internal/modules/esm/assert:44:3,0x31e6f25d03b0,~
code-source-info,0x31e6f25d0c0e,86,1326,1364,C0O1341C2O1345C4O1341C8O1364,,
code-creation,JS,10,82425,0x31e6f25d1636,53,ResolveCache node:internal/modules/esm/module_map:26:14,0x31e6f25cf050,~
code-source-info,0x31e6f25d1636,85,861,878,C3O867C27O867C52O877,,
code-creation,JS,10,82468,0x31e6f25d1c56,22,newLoadCache node:internal/modules/esm/loader:44:22,0x31e6f25c95f0,~
code-source-info,0x31e6f25d1c56,84,1233,1333,C0O1262C6O1262C11O1248C16O1315C21O1331,,
code-creation,JS,10,82503,0x31e6f25d1d2e,43,LoadCache node:internal/modules/esm/module_map:90:14,0x31e6f25cf1e0,~
code-source-info,0x31e6f25d1d2e,85,2855,2872,C3O2861C27O2861C42O2871,,
code-creation,JS,10,82537,0x31e6f25d1f16,17,getTranslators node:internal/modules/esm/loader:53:24,0x31e6f25c9640,~
code-source-info,0x31e6f25d1f16,84,1518,1617,C0O1549C6O1549C11O1533C16O1615,,
code-creation,Eval,10,82873,0x31e6f25d2b3e,5, node:internal/modules/esm/translators:1:1,0x31e6f25d2638,~
script-source,87,node:internal/modules/esm/translators,'use strict';\n\nconst {\n  ArrayPrototypeMap\x2C\n  Boolean\x2C\n  JSONParse\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectKeys\x2C\n  ReflectApply\x2C\n  SafeArrayIterator\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeReplaceAll\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n  Symbol\x2C\n  SyntaxErrorPrototype\x2C\n  globalThis: { WebAssembly }\x2C\n} = primordials;\n\n/** @type {import('internal/util/types')} */\nlet _TYPES = null;\n/**\n * Lazily loads and returns the internal/util/types module.\n */\nfunction lazyTypes() {\n  if (_TYPES !== null) { return _TYPES; }\n  return _TYPES = require('internal/util/types');\n}\n\nconst { containsModuleSyntax } = internalBinding('contextify');\nconst { BuiltinModule } = require('internal/bootstrap/realm');\nconst assert = require('internal/assert');\nconst { readFileSync } = require('fs');\nconst { dirname\x2C extname\x2C isAbsolute } = require('path');\nconst {\n  loadBuiltinModule\x2C\n  stripBOM\x2C\n} = require('internal/modules/helpers');\nconst {\n  Module: CJSModule\x2C\n  cjsParseCache\x2C\n} = require('internal/modules/cjs/loader');\nconst { fileURLToPath\x2C pathToFileURL\x2C URL } = require('internal/url');\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\nconst { emitExperimentalWarning\x2C kEmptyObject\x2C setOwnProperty } = require('internal/util');\nconst {\n  ERR_UNKNOWN_BUILTIN_MODULE\x2C\n  ERR_INVALID_RETURN_PROPERTY_VALUE\x2C\n} = require('internal/errors').codes;\nconst { maybeCacheSourceMap } = require('internal/source_map/source_map_cache');\nconst moduleWrap = internalBinding('module_wrap');\nconst { ModuleWrap } = moduleWrap;\nconst asyncESM = require('internal/process/esm_loader');\nconst { emitWarningSync } = require('internal/process/warning');\nconst { internalCompileFunction } = require('internal/vm');\n\n// Lazy-loading to avoid circular dependencies.\nlet getSourceSync;\n/**\n * @param {Parameters<typeof import('./load').getSourceSync>[0]} url\n * @returns {ReturnType<typeof import('./load').getSourceSync>}\n */\nfunction getSource(url) {\n  getSourceSync ??= require('internal/modules/esm/load').getSourceSync;\n  return getSourceSync(url);\n}\n\n/** @type {import('deps/cjs-module-lexer/lexer.js').parse} */\nlet cjsParse;\n/**\n * Initializes the CommonJS module lexer parser.\n * If WebAssembly is available\x2C it uses the optimized version from the dist folder.\n * Otherwise\x2C it falls back to the JavaScript version from the lexer folder.\n */\nasync function initCJSParse() {\n  if (typeof WebAssembly === 'undefined') {\n    cjsParse = require('internal/deps/cjs-module-lexer/lexer').parse;\n  } else {\n    const { parse\x2C init } =\n        require('internal/deps/cjs-module-lexer/dist/lexer');\n    try {\n      await init();\n      cjsParse = parse;\n    } catch {\n      cjsParse = require('internal/deps/cjs-module-lexer/lexer').parse;\n    }\n  }\n}\n\nconst translators = new SafeMap();\nexports.translators = translators;\nexports.enrichCJSError = enrichCJSError;\n\nlet DECODER = null;\n/**\n * Asserts that the given body is a buffer source (either a string\x2C array buffer\x2C or typed array).\n * Throws an error if the body is not a buffer source.\n * @param {string | ArrayBufferView | ArrayBuffer} body - The body to check.\n * @param {boolean} allowString - Whether or not to allow a string as a valid buffer source.\n * @param {string} hookName - The name of the hook being called.\n * @throws {ERR_INVALID_RETURN_PROPERTY_VALUE} If the body is not a buffer source.\n */\nfunction assertBufferSource(body\x2C allowString\x2C hookName) {\n  if (allowString && typeof body === 'string') {\n    return;\n  }\n  const { isArrayBufferView\x2C isAnyArrayBuffer } = lazyTypes();\n  if (isArrayBufferView(body) || isAnyArrayBuffer(body)) {\n    return;\n  }\n  throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n    `${allowString ? 'string\x2C ' : ''}array buffer\x2C or typed array`\x2C\n    hookName\x2C\n    'source'\x2C\n    body\x2C\n  );\n}\n\n/**\n * Converts a buffer or buffer-like object to a string.\n * @param {string | ArrayBuffer | ArrayBufferView} body - The buffer or buffer-like object to convert to a string.\n * @returns {string} The resulting string.\n */\nfunction stringify(body) {\n  if (typeof body === 'string') { return body; }\n  assertBufferSource(body\x2C false\x2C 'transformSource');\n  const { TextDecoder } = require('internal/encoding');\n  DECODER = DECODER === null ? new TextDecoder() : DECODER;\n  return DECODER.decode(body);\n}\n\n/**\n * Converts a URL to a file path if the URL protocol is 'file:'.\n * @param {string} url - The URL to convert.\n */\nfunction errPath(url) {\n  const parsed = new URL(url);\n  if (parsed.protocol === 'file:') {\n    return fileURLToPath(parsed);\n  }\n  return url;\n}\n\n/**\n * Dynamically imports a module using the ESM loader.\n * @param {string} specifier - The module specifier to import.\n * @param {object} options - An object containing options for the import.\n * @param {string} options.url - The URL of the module requesting the import.\n * @param {Record<string\x2C string>} [attributes] - An object containing attributes for the import.\n * @returns {Promise<import('internal/modules/esm/loader.js').ModuleExports>} The imported module.\n */\nasync function importModuleDynamically(specifier\x2C { url }\x2C attributes) {\n  return asyncESM.esmLoader.import(specifier\x2C url\x2C attributes);\n}\n\n// Strategy for loading a standard JavaScript module.\ntranslators.set('module'\x2C async function moduleStrategy(url\x2C source\x2C isMain) {\n  assertBufferSource(source\x2C true\x2C 'load');\n  source = stringify(source);\n  maybeCacheSourceMap(url\x2C source);\n  debug(`Translating StandardModule ${url}`);\n  const module = new ModuleWrap(url\x2C undefined\x2C source\x2C 0\x2C 0);\n  const { registerModule } = require('internal/modules/esm/utils');\n  registerModule(module\x2C {\n    __proto__: null\x2C\n    initializeImportMeta: (meta\x2C wrap) => this.importMetaInitialize(meta\x2C { url })\x2C\n    importModuleDynamically\x2C\n  });\n  return module;\n});\n\n/**\n * Provide a more informative error for CommonJS imports.\n * @param {Error | any} err\n * @param {string} [content] Content of the file\x2C if known.\n * @param {string} [filename] The filename of the erroring module.\n */\nfunction enrichCJSError(err\x2C content\x2C filename) {\n  if (err != null && ObjectGetPrototypeOf(err) === SyntaxErrorPrototype &&\n      containsModuleSyntax(content\x2C filename)) {\n    // Emit the warning synchronously because we are in the middle of handling\n    // a SyntaxError that will throw and likely terminate the process before an\n    // asynchronous warning would be emitted.\n    emitWarningSync(\n      'To load an ES module\x2C set "type": "module" in the package.json or use ' +\n      'the .mjs extension.'\x2C\n    );\n  }\n}\n\n/**\n * Loads a CommonJS module via the ESM Loader sync CommonJS translator.\n * This translator creates its own version of the `require` function passed into CommonJS modules.\n * Any monkey patches applied to the CommonJS Loader will not affect this module.\n * Any `require` calls in this module will load all children in the same way.\n * @param {import('internal/modules/cjs/loader').Module} module - The module to load.\n * @param {string} source - The source code of the module.\n * @param {string} url - The URL of the module.\n * @param {string} filename - The filename of the module.\n */\nfunction loadCJSModule(module\x2C source\x2C url\x2C filename) {\n  let compiledWrapper;\n  async function importModuleDynamically(specifier\x2C _\x2C importAttributes) {\n    return asyncESM.esmLoader.import(specifier\x2C url\x2C importAttributes);\n  }\n  try {\n    compiledWrapper = internalCompileFunction(\n      source\x2C                         // code\x2C\n      filename\x2C                       // filename\n      0\x2C                              // lineOffset\n      0\x2C                              // columnOffset\x2C\n      undefined\x2C                      // cachedData\n      false\x2C                          // produceCachedData\n      undefined\x2C                      // parsingContext\n      undefined\x2C                      // contextExtensions\n      [                               // params\n        'exports'\x2C\n        'require'\x2C\n        'module'\x2C\n        '__filename'\x2C\n        '__dirname'\x2C\n      ]\x2C\n      Symbol(`cjs:${filename}`)\x2C      // hostDefinedOptionsId\n      importModuleDynamically\x2C        // importModuleDynamically\n    ).function;\n  } catch (err) {\n    enrichCJSError(err\x2C source\x2C filename);\n    throw err;\n  }\n\n  const __dirname = dirname(filename);\n  // eslint-disable-next-line func-name-matching\x2Cfunc-style\n  const requireFn = function require(specifier) {\n    let importAttributes = kEmptyObject;\n    if (!StringPrototypeStartsWith(specifier\x2C 'node:') && !BuiltinModule.normalizeRequirableId(specifier)) {\n      // TODO: do not depend on the monkey-patchable CJS loader here.\n      const path = CJSModule._resolveFilename(specifier\x2C module);\n      switch (extname(path)) {\n        case '.json':\n          importAttributes = { __proto__: null\x2C type: 'json' };\n          break;\n        case '.node':\n          return CJSModule._load(specifier\x2C module);\n        default:\n            // fall through\n      }\n      specifier = `${pathToFileURL(path)}`;\n    }\n    const job = asyncESM.esmLoader.getModuleJobSync(specifier\x2C url\x2C importAttributes);\n    job.runSync();\n    return cjsCache.get(job.url).exports;\n  };\n  setOwnProperty(requireFn\x2C 'resolve'\x2C function resolve(specifier) {\n    if (!StringPrototypeStartsWith(specifier\x2C 'node:')) {\n      const path = CJSModule._resolveFilename(specifier\x2C module);\n      if (specifier !== path) {\n        specifier = `${pathToFileURL(path)}`;\n      }\n    }\n    const { url: resolvedURL } = asyncESM.esmLoader.resolveSync(specifier\x2C url\x2C kEmptyObject);\n    return StringPrototypeStartsWith(resolvedURL\x2C 'file://') ? fileURLToPath(resolvedURL) : resolvedURL;\n  });\n  setOwnProperty(requireFn\x2C 'main'\x2C process.mainModule);\n\n  ReflectApply(compiledWrapper\x2C module.exports\x2C\n               [module.exports\x2C requireFn\x2C module\x2C filename\x2C __dirname]);\n  setOwnProperty(module\x2C 'loaded'\x2C true);\n}\n\n// TODO: can we use a weak map instead?\nconst cjsCache = new SafeMap();\n/**\n * Creates a ModuleWrap object for a CommonJS module.\n * @param {string} url - The URL of the module.\n * @param {string} source - The source code of the module.\n * @param {boolean} isMain - Whether the module is the main module.\n * @param {typeof loadCJSModule} [loadCJS=loadCJSModule] - The function to load the CommonJS module.\n * @returns {ModuleWrap} The ModuleWrap object for the CommonJS module.\n */\nfunction createCJSModuleWrap(url\x2C source\x2C isMain\x2C loadCJS = loadCJSModule) {\n  debug(`Translating CJSModule ${url}`);\n\n  const filename = StringPrototypeStartsWith(url\x2C 'file://') ? fileURLToPath(url) : url;\n  // In case the source was not provided by the `load` step\x2C we need fetch it now.\n  source = stringify(source ?? getSource(new URL(url)).source);\n\n  const { exportNames\x2C module } = cjsPreparseModuleExports(filename\x2C source);\n  cjsCache.set(url\x2C module);\n  const namesWithDefault = exportNames.has('default') ?\n    [...exportNames] : ['default'\x2C ...exportNames];\n\n  if (isMain) {\n    setOwnProperty(process\x2C 'mainModule'\x2C module);\n  }\n\n  return new ModuleWrap(url\x2C undefined\x2C namesWithDefault\x2C function() {\n    debug(`Loading CJSModule ${url}`);\n\n    if (!module.loaded) {\n      loadCJS(module\x2C source\x2C url\x2C filename);\n    }\n\n    let exports;\n    if (asyncESM.esmLoader.cjsCache.has(module)) {\n      exports = asyncESM.esmLoader.cjsCache.get(module);\n      asyncESM.esmLoader.cjsCache.delete(module);\n    } else {\n      ({ exports } = module);\n    }\n    for (const exportName of exportNames) {\n      if (!ObjectPrototypeHasOwnProperty(exports\x2C exportName) ||\n          exportName === 'default') {\n        continue;\n      }\n      // We might trigger a getter -> dont fail.\n      let value;\n      try {\n        value = exports[exportName];\n      } catch {\n        // Continue regardless of error.\n      }\n      this.setExport(exportName\x2C value);\n    }\n    this.setExport('default'\x2C exports);\n  });\n\n}\n\n// Handle CommonJS modules referenced by `require` calls.\n// This translator function must be sync\x2C as `require` is sync.\ntranslators.set('require-commonjs'\x2C (url\x2C source\x2C isMain) => {\n  assert(cjsParse);\n\n  return createCJSModuleWrap(url\x2C source);\n});\n\n// Handle CommonJS modules referenced by `import` statements or expressions\x2C\n// or as the initial entry point when the ESM loader handles a CommonJS entry.\ntranslators.set('commonjs'\x2C async function commonjsStrategy(url\x2C source\x2C\n                                                            isMain) {\n  if (!cjsParse) {\n    await initCJSParse();\n  }\n\n  // For backward-compatibility\x2C it's possible to return a nullish value for\n  // CJS source associated with a file: URL. In this case\x2C the source is\n  // obtained by calling the monkey-patchable CJS loader.\n  const cjsLoader = source == null ? (module\x2C source\x2C url\x2C filename) => {\n    try {\n      assert(module === CJSModule._cache[filename]);\n      CJSModule._load(filename);\n    } catch (err) {\n      enrichCJSError(err\x2C source\x2C filename);\n      throw err;\n    }\n  } : loadCJSModule;\n\n  try {\n    // We still need to read the FS to detect the exports.\n    source ??= readFileSync(new URL(url)\x2C 'utf8');\n  } catch {\n    // Continue regardless of error.\n  }\n  return createCJSModuleWrap(url\x2C source\x2C isMain\x2C cjsLoader);\n\n});\n\n/**\n * Pre-parses a CommonJS module's exports and re-exports.\n * @param {string} filename - The filename of the module.\n * @param {string} [source] - The source code of the module.\n */\nfunction cjsPreparseModuleExports(filename\x2C source) {\n  // TODO: Do we want to keep hitting the user mutable CJS loader here?\n  let module = CJSModule._cache[filename];\n  if (module) {\n    const cached = cjsParseCache.get(module);\n    if (cached) {\n      return { module\x2C exportNames: cached.exportNames };\n    }\n  }\n  const loaded = Boolean(module);\n  if (!loaded) {\n    module = new CJSModule(filename);\n    module.filename = filename;\n    module.paths = CJSModule._nodeModulePaths(module.path);\n    CJSModule._cache[filename] = module;\n  }\n\n  let exports\x2C reexports;\n  try {\n    ({ exports\x2C reexports } = cjsParse(source || ''));\n  } catch {\n    exports = [];\n    reexports = [];\n  }\n\n  const exportNames = new SafeSet(new SafeArrayIterator(exports));\n\n  // Set first for cycles.\n  cjsParseCache.set(module\x2C { source\x2C exportNames });\n\n  if (reexports.length) {\n    module.filename = filename;\n    module.paths = CJSModule._nodeModulePaths(module.path);\n    for (let i = 0; i < reexports.length; i++) {\n      const reexport = reexports[i];\n      let resolved;\n      try {\n        // TODO: this should be calling the `resolve` hook chain instead.\n        // Doing so would mean dropping support for CJS in the loader thread\x2C as\n        // this call needs to be sync from the perspective of the main thread\x2C\n        // which we can do via HooksProxy and Atomics\x2C but we can't do within\n        // the loaders thread. Until this is done\x2C the lexer will use the\n        // monkey-patchable CJS loader to get the path to the module file to\n        // load (which may or may not be aligned with the URL that the `resolve`\n        // hook have returned).\n        resolved = CJSModule._resolveFilename(reexport\x2C module);\n      } catch {\n        continue;\n      }\n      // TODO: this should be calling the `load` hook chain and check if it returns\n      // `format: 'commonjs'` instead of relying on file extensions.\n      const ext = extname(resolved);\n      if ((ext === '.js' || ext === '.cjs' || !CJSModule._extensions[ext]) &&\n      isAbsolute(resolved)) {\n        // TODO: this should be calling the `load` hook chain to get the source\n        // (and fallback to reading the FS only if the source is nullish).\n        const source = readFileSync(resolved\x2C 'utf-8');\n        const { exportNames: reexportNames } = cjsPreparseModuleExports(resolved\x2C source);\n        for (const name of reexportNames) {\n          exportNames.add(name);\n        }\n      }\n    }\n  }\n\n  return { module\x2C exportNames };\n}\n\n// Strategy for loading a node builtin CommonJS module that isn't\n// through normal resolution\ntranslators.set('builtin'\x2C function builtinStrategy(url) {\n  debug(`Translating BuiltinModule ${url}`);\n  // Slice 'node:' scheme\n  const id = StringPrototypeSlice(url\x2C 5);\n  const module = loadBuiltinModule(id\x2C url);\n  cjsCache.set(url\x2C module);\n  if (!StringPrototypeStartsWith(url\x2C 'node:') || !module) {\n    throw new ERR_UNKNOWN_BUILTIN_MODULE(url);\n  }\n  debug(`Loading BuiltinModule ${url}`);\n  return module.getESMFacade();\n});\n\n// Strategy for loading a JSON file\nconst isWindows = process.platform === 'win32';\ntranslators.set('json'\x2C function jsonStrategy(url\x2C source) {\n  emitExperimentalWarning('Importing JSON modules');\n  assertBufferSource(source\x2C true\x2C 'load');\n  debug(`Loading JSONModule ${url}`);\n  const pathname = StringPrototypeStartsWith(url\x2C 'file:') ?\n    fileURLToPath(url) : null;\n  const shouldCheckAndPopulateCJSModuleCache =\n    // We want to involve the CJS loader cache only for `file:` URL with no search query and no hash.\n    pathname && !StringPrototypeIncludes(url\x2C '?') && !StringPrototypeIncludes(url\x2C '#');\n  let modulePath;\n  let module;\n  if (shouldCheckAndPopulateCJSModuleCache) {\n    modulePath = isWindows ?\n      StringPrototypeReplaceAll(pathname\x2C '/'\x2C '\\\\') : pathname;\n    module = CJSModule._cache[modulePath];\n    if (module && module.loaded) {\n      const exports = module.exports;\n      return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n        this.setExport('default'\x2C exports);\n      });\n    }\n  }\n  source = stringify(source);\n  if (shouldCheckAndPopulateCJSModuleCache) {\n    // A require call could have been called on the same file during loading and\n    // that resolves synchronously. To make sure we always return the identical\n    // export\x2C we have to check again if the module already exists or not.\n    // TODO: remove CJS loader from here as well.\n    module = CJSModule._cache[modulePath];\n    if (module && module.loaded) {\n      const exports = module.exports;\n      return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n        this.setExport('default'\x2C exports);\n      });\n    }\n  }\n  try {\n    const exports = JSONParse(stripBOM(source));\n    module = {\n      exports\x2C\n      loaded: true\x2C\n    };\n  } catch (err) {\n    // TODO (BridgeAR): We could add a NodeCore error that wraps the JSON\n    // parse error instead of just manipulating the original error message.\n    // That would allow to add further properties and maybe additional\n    // debugging information.\n    err.message = errPath(url) + ': ' + err.message;\n    throw err;\n  }\n  if (shouldCheckAndPopulateCJSModuleCache) {\n    CJSModule._cache[modulePath] = module;\n  }\n  cjsCache.set(url\x2C module);\n  return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n    debug(`Parsing JSONModule ${url}`);\n    this.setExport('default'\x2C module.exports);\n  });\n});\n\n// Strategy for loading a wasm module\ntranslators.set('wasm'\x2C async function(url\x2C source) {\n  emitExperimentalWarning('Importing WebAssembly modules');\n\n  assertBufferSource(source\x2C false\x2C 'load');\n\n  debug(`Translating WASMModule ${url}`);\n\n  let compiled;\n  try {\n    compiled = await WebAssembly.compile(source);\n  } catch (err) {\n    err.message = errPath(url) + ': ' + err.message;\n    throw err;\n  }\n\n  const imports =\n      ArrayPrototypeMap(WebAssembly.Module.imports(compiled)\x2C\n                        ({ module }) => module);\n  const exports =\n    ArrayPrototypeMap(WebAssembly.Module.exports(compiled)\x2C\n                      ({ name }) => name);\n\n  const createDynamicModule = require(\n    'internal/modules/esm/create_dynamic_module');\n  return createDynamicModule(imports\x2C exports\x2C url\x2C (reflect) => {\n    const { exports } = new WebAssembly.Instance(compiled\x2C reflect.imports);\n    for (const expt of ObjectKeys(exports)) {\n      reflect.exports[expt].set(exports[expt]);\n    }\n  }).module;\n});\n
tick,0x10c6e4436,84241,1,0x10c1e6120,3,0x10c41e000,0x112583f26,0x112583ca1,0x31e6f25d1f1c,0x31e6f25cab96,0x31e6f25ce56f,0x31e6f25ccf0b,0x31e6f25cc933,0x31e6f6b7ec59,0x31e6f6b5f603,0x31e6f6b7289e,0x31e6f6b60853,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f6b7a49a,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-source-info,0x31e6f25d2b3e,87,0,19831,C0O0C4O19831,,
code-creation,JS,10,84310,0x31e6f25d34be,828, node:internal/modules/esm/translators:1:1,0x31e6f25d2ab8,~
code-source-info,0x31e6f25d34be,87,0,19831,C0O0C220O25C226O46C232O57C238O70C244O94C250O127C256O141C262O157C268O178C273O189C279O200C285O227C291O256C297O280C303O309C309O319C315O355C320O357C326O448C327O448C329O673C332O673C337O648C343O730C349O730C354O712C360O782C366O782C370O782C372O835C378O835C383O818C389O891C395O891C400O858C406O867C412O876C418O953C424O953C429O918C435O939C441O1040C447O1040C452O1008C458O1021C464O1126C470O1126C475O1088C481O1103C487O1118C493O1163C499O1163C504O1196C517O1197C523O1163C525O1307C531O1307C536O1249C542O1274C548O1288C554O1412C560O1412C565O1438C570O1343C576O1373C582O1478C588O1478C593O1454C599O1546C602O1546C607O1586C613O1630C619O1630C623O1630C625O1698C631O1698C636O1678C642O1771C648O1771C653O1743C659O1848C660O1848C662O2200C663O2200C665O2848C667O2848C673O2863C675O2883C679O2898C681O2921C685O2954C686O2954C688O5310C701O5310C707O9956C709O9956C714O9956C716O12023C729O12023C735O12311C748O12311C754O16011C767O16011C773O16490C776O16498C783O16507C786O16490C788O16532C801O16532C807O18872C820O18872C827O19830,,
tick,0x7ff809333fd4,84447,1,0x10c1e6120,3,0x10c41e000,0x112583f26,0x112583ca1,0x31e6f25d1f1c,0x31e6f25cab96,0x31e6f25ce56f,0x31e6f25ccf0b,0x31e6f25cc933,0x31e6f6b7ec59,0x31e6f6b5f603,0x31e6f6b7289e,0x31e6f6b60853,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f6b7a49a,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,84578,0x31e6f25d4f7e,30,setCustomizations node:internal/modules/esm/loader:187:20,0x31e6f25c9820,~
code-source-info,0x31e6f25d4f7e,84,5321,5548,C0O5344C5O5365C9O5387C13O5460C17O5443C23O5503C24O5531C29O5547,,
code-creation,JS,10,84656,0x31e6f25d50ce,35,isVerboseLoggingEnabled /Users/peterhage/Applications/WebStorm.app/Contents/plugins/javascript-debugger/debugConnectorUtil.js:35:33,0x31e6f6b7e448,~
code-source-info,0x31e6f25d50ce,82,1282,1453,C0O1289C6O1331C10O1363C15O1367C20O1407C24O1353C30O1422C34O1451,,
code-creation,JS,10,84784,0x31e6f25d51d6,5,get node:internal/bootstrap/node:371:8,0x31e6931bc258,~
code-source-info,0x31e6f25d51d6,12,12775,12808,C0O12786C4O12802,,
code-creation,JS,10,84880,0x31e6f25d53fe,93,findReasonToSkipAttachingDebugger /Users/peterhage/Applications/WebStorm.app/Contents/plugins/javascript-debugger/debugConnector.js:47:43,0x31e6f6b79ea0,~
code-source-info,0x31e6f25d53fe,81,1747,2267,C0O1754C3O1758C8O1781C10O1808C11O1815C14O1819C19O1854C21O1889C22O1922C25O1922C29O1951C32O1988C35O2026C39O2031C44O2031C49O2024C52O2060C56O2077C62O2082C67O2107C73O2184C75O2216C91O2253C92O2265,,
code-creation,JS,10,84944,0x31e6f25d5636,25,hasInspectArg /Users/peterhage/Applications/WebStorm.app/Contents/plugins/javascript-debugger/debugConnector.js:69:23,0x31e6f6b79ef0,~
code-source-info,0x31e6f25d5636,81,2291,2462,C0O2298C4O2313C9O2322C19O2322C24O2460,,
code-creation,JS,10,85065,0x31e6f25d5776,43, /Users/peterhage/Applications/WebStorm.app/Contents/plugins/javascript-debugger/debugConnector.js:71:7,0x31e6f25d5580,~
code-source-info,0x31e6f25d5776,81,2334,2455,C0O2345C2O2345C9O2368C14O2395C22O2395C29O2431C37O2431C42O2455,,
code-creation,JS,10,85194,0x31e6f25d58e6,54,isElectronRendererProcess /Users/peterhage/Applications/WebStorm.app/Contents/plugins/javascript-debugger/debugConnector.js:75:35,0x31e6f6b79f40,~
code-source-info,0x31e6f25d58e6,81,2498,2606,C0O2505C4O2520C10O2528C14O2536C21O2541C26O2559C30O2567C35O2572C43O2572C50O2599C53O2604,,
code-creation,JS,10,85319,0x31e6f25d5f0e,112,getMatchedHelperProcess /Users/peterhage/Applications/WebStorm.app/Contents/plugins/javascript-debugger/debugConnector.js:86:33,0x31e6f6b79f90,~
code-source-info,0x31e6f25d5f0e,81,2994,4857,C0O2994C29O3031C31O3031C33O3084C53O3504C69O3677C73O3689C78O3693C84O3742C85O3754C86O3774C90O3782C94O3774C96O3819C106O3819C111O3911,,
tick,0x7ff8092cbace,85469,0,0x0,3,0x10c9f09d0,0x31e6f25d5417,0x31e6f6b7a501,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,85509,0x31e6f25d610e,14, /Users/peterhage/Applications/WebStorm.app/Contents/plugins/javascript-debugger/debugConnector.js:103:37,0x31e6f25d5c60,~
code-source-info,0x31e6f25d610e,81,3824,3909,C0O3853C5O3899C8O3860C13O3905,,
code-creation,JS,10,85592,0x31e6f25d626e,55,isHelperInfoMatched /Users/peterhage/Applications/WebStorm.app/Contents/plugins/javascript-debugger/debugConnector.js:112:31,0x31e6f25d5b70,~
code-source-info,0x31e6f25d626e,81,4058,4384,C0O4058C9O4090C12O4099C17O4127C21O4106C26O4155C32O4162C37O4177C38O4190C39O4226C49O4226C54O4380,,
code-creation,JS,10,85689,0x31e6f25d63a6,41, /Users/peterhage/Applications/WebStorm.app/Contents/plugins/javascript-debugger/debugConnector.js:116:36,0x31e6f25d61b8,~
code-source-info,0x31e6f25d63a6,81,4232,4378,C0O4258C1O4268C6O4285C16O4319C20O4292C25O4324C26O4339C31O4367C34O4360C37O4352C40O4372,,
code-creation,JS,10,85793,0x31e6f25d64f6,112,matchPathSuffix /Users/peterhage/Applications/WebStorm.app/Contents/plugins/javascript-debugger/debugConnector.js:124:27,0x31e6f25d5bc0,~
code-source-info,0x31e6f25d64f6,81,4412,4770,C0O4452C7O4463C10O4452C17O4516C25O4516C30O4531C35O4540C39O4548C44O4532C50O4571C57O4581C60O4603C65O4571C70O4558C74O4618C77O4625C85O4659C89O4655C92O4697C93O4708C96O4715C101O4744C106O4745C111O4766,,
code-creation,JS,10,86022,0x31e6f25d668e,21,toSystemIndependentPath /Users/peterhage/Applications/WebStorm.app/Contents/plugins/javascript-debugger/debugConnector.js:132:35,0x31e6f25d5c10,~
code-source-info,0x31e6f25d668e,81,4806,4855,C0O4831C14O4831C20O4851,,
code-creation,JS,10,86165,0x31e6f25d6846,65,loadBuiltinModule node:internal/modules/helpers:93:27,0x31e647c77ee8,~
code-source-info,0x31e6f25d6846,64,2613,2967,C0O2631C5O2650C10O2650C17O2682C18O2689C19O2777C24O2791C29O2795C34O2795C40O2806C48O2806C53O2926C58O2926C62O2954C64O2965,,
code-creation,JS,10,86224,0x31e6f25d6986,18,canBeRequiredByUsers node:internal/bootstrap/realm:293:30,0x31e6931b6c20,~
code-source-info,0x31e6f25d6986,9,9414,9469,C0O9425C7O9457C12O9457C17O9465,,
code-creation,JS,10,86269,0x31e6f25d6a6e,10, node:internal/modules/helpers:37:66,0x31e647c77b40,~
code-source-info,0x31e6f25d6a6e,64,1032,1057,C0O1044C2O1050C9O1056,,
code-creation,JS,10,86334,0x31e6f25d6c3e,145,compileForPublicLoader node:internal/bootstrap/realm:331:25,0x31e6931b6e00,~
code-source-info,0x31e6f25d6c3e,9,10482,11172,C0O10491C5O10510C10O10536C15O10510C22O10663C32O10706C49O10669C54O10663C55O10743C60O10743C64O10785C70O10974C77O11005C85O10974C91O11029C96O11047C106O11063C109O11079C114O11063C118O11045C122O11104C127O11104C131O11129C136O11129C140O11160C144O11168,,
tick,0x7ff8092cbace,86505,0,0x0,3,0x10c9f09d0,0x31e6f25d6880,0x31e6f6b607cb,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f25d543c,0x31e6f6b7a501,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,Eval,10,86562,0x31e6f25d7076,5, node:worker_threads:1:1,0x31e6f25d6f30,~
script-source,88,node:worker_threads,'use strict';\n\nconst {\n  isMainThread\x2C\n  SHARE_ENV\x2C\n  resourceLimits\x2C\n  setEnvironmentData\x2C\n  getEnvironmentData\x2C\n  threadId\x2C\n  Worker\x2C\n} = require('internal/worker');\n\nconst {\n  MessagePort\x2C\n  MessageChannel\x2C\n  moveMessagePortToContext\x2C\n  receiveMessageOnPort\x2C\n  BroadcastChannel\x2C\n} = require('internal/worker/io');\n\nconst {\n  markAsUntransferable\x2C\n} = require('internal/buffer');\n\nmodule.exports = {\n  isMainThread\x2C\n  MessagePort\x2C\n  MessageChannel\x2C\n  markAsUntransferable\x2C\n  moveMessagePortToContext\x2C\n  receiveMessageOnPort\x2C\n  resourceLimits\x2C\n  threadId\x2C\n  SHARE_ENV\x2C\n  Worker\x2C\n  parentPort: null\x2C\n  workerData: null\x2C\n  BroadcastChannel\x2C\n  setEnvironmentData\x2C\n  getEnvironmentData\x2C\n};\n
code-source-info,0x31e6f25d7076,88,0,687,C0O0C4O687,,
code-creation,JS,10,86686,0x31e6f25d7286,180, node:worker_threads:1:1,0x31e6f25d6ff0,~
code-source-info,0x31e6f25d7286,88,0,687,C0O140C3O140C8O25C13O41C18O54C23O72C28O94C33O116C38O128C43O286C46O286C51O179C56O194C61O212C66O240C71O264C76O354C79O354C84O328C89O383C96O404C102O420C108O435C114O453C120O477C126O505C132O529C138O547C144O559C150O572C156O622C162O642C168O664C174O398C179O686,,
code-creation,Eval,10,87439,0x31e6f25d8b9e,5, node:internal/worker:1:1,0x31e6f25d7f90,~
script-source,89,node:internal/worker,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  Float64Array\x2C\n  FunctionPrototypeBind\x2C\n  JSONStringify\x2C\n  MathMax\x2C\n  ObjectEntries\x2C\n  Promise\x2C\n  PromiseResolve\x2C\n  ReflectApply\x2C\n  RegExpPrototypeExec\x2C\n  SafeArrayIterator\x2C\n  SafeMap\x2C\n  String\x2C\n  StringPrototypeTrim\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  TypedArrayPrototypeFill\x2C\n  Uint32Array\x2C\n  globalThis: { Atomics\x2C SharedArrayBuffer }\x2C\n} = primordials;\n\nconst EventEmitter = require('events');\nconst assert = require('internal/assert');\nconst path = require('path');\nconst {\n  internalEventLoopUtilization\x2C\n} = require('internal/perf/event_loop_utilization');\n\nconst errorCodes = require('internal/errors').codes;\nconst {\n  ERR_WORKER_NOT_RUNNING\x2C\n  ERR_WORKER_PATH\x2C\n  ERR_WORKER_UNSERIALIZABLE_ERROR\x2C\n  ERR_WORKER_INVALID_EXEC_ARGV\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n} = errorCodes;\nconst { getOptionValue } = require('internal/options');\n\nconst workerIo = require('internal/worker/io');\nconst {\n  drainMessagePort\x2C\n  receiveMessageOnPort\x2C\n  MessageChannel\x2C\n  messageTypes\x2C\n  kPort\x2C\n  kIncrementsPortRef\x2C\n  kWaitingStreams\x2C\n  kStdioWantsMoreDataCallback\x2C\n  setupPortReferencing\x2C\n  ReadableWorkerStdio\x2C\n  WritableWorkerStdio\x2C\n} = workerIo;\nconst { deserializeError } = require('internal/error_serdes');\nconst { fileURLToPath\x2C isURL\x2C pathToFileURL } = require('internal/url');\nconst { kEmptyObject } = require('internal/util');\nconst { validateArray\x2C validateString } = require('internal/validators');\nconst {\n  throwIfBuildingSnapshot\x2C\n} = require('internal/v8/startup_snapshot');\nconst {\n  ownsProcessState\x2C\n  isMainThread\x2C\n  resourceLimits: resourceLimitsRaw\x2C\n  threadId\x2C\n  Worker: WorkerImpl\x2C\n  kMaxYoungGenerationSizeMb\x2C\n  kMaxOldGenerationSizeMb\x2C\n  kCodeRangeSizeMb\x2C\n  kStackSizeMb\x2C\n  kTotalResourceLimitCount\x2C\n} = internalBinding('worker');\n\nconst kHandle = Symbol('kHandle');\nconst kPublicPort = Symbol('kPublicPort');\nconst kDispose = Symbol('kDispose');\nconst kOnExit = Symbol('kOnExit');\nconst kOnMessage = Symbol('kOnMessage');\nconst kOnCouldNotSerializeErr = Symbol('kOnCouldNotSerializeErr');\nconst kOnErrorMessage = Symbol('kOnErrorMessage');\nconst kParentSideStdio = Symbol('kParentSideStdio');\nconst kLoopStartTime = Symbol('kLoopStartTime');\nconst kIsInternal = Symbol('kIsInternal');\nconst kIsOnline = Symbol('kIsOnline');\n\nconst SHARE_ENV = SymbolFor('nodejs.worker_threads.SHARE_ENV');\nlet debug = require('internal/util/debuglog').debuglog('worker'\x2C (fn) => {\n  debug = fn;\n});\n\nconst dc = require('diagnostics_channel');\nconst workerThreadsChannel = dc.channel('worker_threads');\n\nlet cwdCounter;\n\nconst environmentData = new SafeMap();\n\n// SharedArrayBuffers can be disabled with --no-harmony-sharedarraybuffer.\n// Atomics can be disabled with --no-harmony-atomics.\nif (isMainThread && SharedArrayBuffer !== undefined && Atomics !== undefined) {\n  cwdCounter = new Uint32Array(new SharedArrayBuffer(4));\n  const originalChdir = process.chdir;\n  process.chdir = function(path) {\n    Atomics.add(cwdCounter\x2C 0\x2C 1);\n    originalChdir(path);\n  };\n}\n\nfunction setEnvironmentData(key\x2C value) {\n  if (value === undefined)\n    environmentData.delete(key);\n  else\n    environmentData.set(key\x2C value);\n}\n\nfunction getEnvironmentData(key) {\n  return environmentData.get(key);\n}\n\nfunction assignEnvironmentData(data) {\n  if (data === undefined) return;\n  data.forEach((value\x2C key) => {\n    environmentData.set(key\x2C value);\n  });\n}\n\nclass Worker extends EventEmitter {\n  constructor(filename\x2C options = kEmptyObject) {\n    throwIfBuildingSnapshot('Creating workers');\n    super();\n    const isInternal = arguments[2] === kIsInternal;\n    debug(\n      `[${threadId}] create new worker`\x2C\n      filename\x2C\n      options\x2C\n      `isInternal: ${isInternal}`\x2C\n    );\n    if (options.execArgv)\n      validateArray(options.execArgv\x2C 'options.execArgv');\n\n    let argv;\n    if (options.argv) {\n      validateArray(options.argv\x2C 'options.argv');\n      argv = ArrayPrototypeMap(options.argv\x2C String);\n    }\n\n    let url\x2C doEval;\n    if (isInternal) {\n      doEval = 'internal';\n      url = `node:${filename}`;\n    } else if (options.eval) {\n      if (typeof filename !== 'string') {\n        throw new ERR_INVALID_ARG_VALUE(\n          'options.eval'\x2C\n          options.eval\x2C\n          'must be false when \\'filename\\' is not a string'\x2C\n        );\n      }\n      url = null;\n      doEval = 'classic';\n    } else if (isURL(filename) && filename.protocol === 'data:') {\n      url = null;\n      doEval = 'module';\n      filename = `import ${JSONStringify(`${filename}`)}`;\n    } else {\n      doEval = false;\n      if (isURL(filename)) {\n        url = filename;\n        filename = fileURLToPath(filename);\n      } else if (typeof filename !== 'string') {\n        throw new ERR_INVALID_ARG_TYPE(\n          'filename'\x2C\n          ['string'\x2C 'URL']\x2C\n          filename\x2C\n        );\n      } else if (path.isAbsolute(filename) ||\n                 RegExpPrototypeExec(/^\\.\\.?[\\\\/]/\x2C filename) !== null) {\n        filename = path.resolve(filename);\n        url = pathToFileURL(filename);\n      } else {\n        throw new ERR_WORKER_PATH(filename);\n      }\n    }\n\n    let env;\n    if (typeof options.env === 'object' && options.env !== null) {\n      env = { __proto__: null };\n      ArrayPrototypeForEach(\n        ObjectEntries(options.env)\x2C\n        ({ 0: key\x2C 1: value }) => { env[key] = `${value}`; }\x2C\n      );\n    } else if (options.env == null) {\n      env = process.env;\n    } else if (options.env !== SHARE_ENV) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.env'\x2C\n        ['object'\x2C 'undefined'\x2C 'null'\x2C 'worker_threads.SHARE_ENV']\x2C\n        options.env);\n    }\n\n    let name = '';\n    if (options.name) {\n      validateString(options.name\x2C 'options.name');\n      name = StringPrototypeTrim(options.name);\n    }\n\n    debug('instantiating Worker.'\x2C `url: ${url}`\x2C `doEval: ${doEval}`);\n    // Set up the C++ handle for the worker\x2C as well as some internal wiring.\n    this[kHandle] = new WorkerImpl(url\x2C\n                                   env === process.env ? null : env\x2C\n                                   options.execArgv\x2C\n                                   parseResourceLimits(options.resourceLimits)\x2C\n                                   !!(options.trackUnmanagedFds ?? true)\x2C\n                                   isInternal\x2C\n                                   name);\n    if (this[kHandle].invalidExecArgv) {\n      throw new ERR_WORKER_INVALID_EXEC_ARGV(this[kHandle].invalidExecArgv);\n    }\n    if (this[kHandle].invalidNodeOptions) {\n      throw new ERR_WORKER_INVALID_EXEC_ARGV(\n        this[kHandle].invalidNodeOptions\x2C 'invalid NODE_OPTIONS env variable');\n    }\n    this[kHandle].onexit = (code\x2C customErr\x2C customErrReason) => {\n      this[kOnExit](code\x2C customErr\x2C customErrReason);\n    };\n    this[kPort] = this[kHandle].messagePort;\n    this[kPort].on('message'\x2C (data) => this[kOnMessage](data));\n    this[kPort].start();\n    this[kPort].unref();\n    this[kPort][kWaitingStreams] = 0;\n    debug(`[${threadId}] created Worker with ID ${this.threadId}`);\n\n    let stdin = null;\n    if (options.stdin)\n      stdin = new WritableWorkerStdio(this[kPort]\x2C 'stdin');\n    const stdout = new ReadableWorkerStdio(this[kPort]\x2C 'stdout');\n    if (!options.stdout) {\n      stdout[kIncrementsPortRef] = false;\n      pipeWithoutWarning(stdout\x2C process.stdout);\n    }\n    const stderr = new ReadableWorkerStdio(this[kPort]\x2C 'stderr');\n    if (!options.stderr) {\n      stderr[kIncrementsPortRef] = false;\n      pipeWithoutWarning(stderr\x2C process.stderr);\n    }\n\n    this[kParentSideStdio] = { stdin\x2C stdout\x2C stderr };\n\n    const { port1\x2C port2 } = new MessageChannel();\n    const transferList = [port2];\n    // If transferList is provided.\n    if (options.transferList)\n      ArrayPrototypePush(transferList\x2C\n                         ...new SafeArrayIterator(options.transferList));\n\n    this[kPublicPort] = port1;\n    ArrayPrototypeForEach(['message'\x2C 'messageerror']\x2C (event) => {\n      this[kPublicPort].on(event\x2C (message) => this.emit(event\x2C message));\n    });\n    setupPortReferencing(this[kPublicPort]\x2C this\x2C 'message');\n    this[kPort].postMessage({\n      argv\x2C\n      type: messageTypes.LOAD_SCRIPT\x2C\n      filename\x2C\n      doEval\x2C\n      isInternal\x2C\n      cwdCounter: cwdCounter || workerIo.sharedCwdCounter\x2C\n      workerData: options.workerData\x2C\n      environmentData\x2C\n      publicPort: port2\x2C\n      manifestURL: getOptionValue('--experimental-policy') ?\n        require('internal/process/policy').url :\n        null\x2C\n      manifestSrc: getOptionValue('--experimental-policy') ?\n        require('internal/process/policy').src :\n        null\x2C\n      hasStdin: !!options.stdin\x2C\n    }\x2C transferList);\n    // Use this to cache the Worker's loopStart value once available.\n    this[kLoopStartTime] = -1;\n    this[kIsOnline] = false;\n    this.performance = {\n      eventLoopUtilization: FunctionPrototypeBind(eventLoopUtilization\x2C this)\x2C\n    };\n    // Actually start the new thread now that everything is in place.\n    this[kHandle].startThread();\n\n    process.nextTick(() => process.emit('worker'\x2C this));\n    if (workerThreadsChannel.hasSubscribers) {\n      workerThreadsChannel.publish({\n        worker: this\x2C\n      });\n    }\n  }\n\n  [kOnExit](code\x2C customErr\x2C customErrReason) {\n    debug(`[${threadId}] hears end event for Worker ${this.threadId}`);\n    drainMessagePort(this[kPublicPort]);\n    drainMessagePort(this[kPort]);\n    this.removeAllListeners('message');\n    this.removeAllListeners('messageerrors');\n    this[kPublicPort].unref();\n    this[kPort].unref();\n    this[kDispose]();\n    if (customErr) {\n      debug(`[${threadId}] failing with custom error ${customErr} \\\n        and with reason ${customErrReason}`);\n      this.emit('error'\x2C new errorCodes[customErr](customErrReason));\n    }\n    this.emit('exit'\x2C code);\n    this.removeAllListeners();\n  }\n\n  [kOnCouldNotSerializeErr]() {\n    this.emit('error'\x2C new ERR_WORKER_UNSERIALIZABLE_ERROR());\n  }\n\n  [kOnErrorMessage](serialized) {\n    // This is what is called for uncaught exceptions.\n    const error = deserializeError(serialized);\n    this.emit('error'\x2C error);\n  }\n\n  [kOnMessage](message) {\n    switch (message.type) {\n      case messageTypes.UP_AND_RUNNING:\n        this[kIsOnline] = true;\n        return this.emit('online');\n      case messageTypes.COULD_NOT_SERIALIZE_ERROR:\n        return this[kOnCouldNotSerializeErr]();\n      case messageTypes.ERROR_MESSAGE:\n        return this[kOnErrorMessage](message.error);\n      case messageTypes.STDIO_PAYLOAD:\n      {\n        const { stream\x2C chunks } = message;\n        const readable = this[kParentSideStdio][stream];\n        ArrayPrototypeForEach(chunks\x2C ({ chunk\x2C encoding }) => {\n          readable.push(chunk\x2C encoding);\n        });\n        return;\n      }\n      case messageTypes.STDIO_WANTS_MORE_DATA:\n      {\n        const { stream } = message;\n        return this[kParentSideStdio][stream][kStdioWantsMoreDataCallback]();\n      }\n    }\n\n    assert.fail(`Unknown worker message type ${message.type}`);\n  }\n\n  [kDispose]() {\n    this[kHandle].onexit = null;\n    this[kHandle] = null;\n    this[kPort] = null;\n    this[kPublicPort] = null;\n\n    const { stdout\x2C stderr } = this[kParentSideStdio];\n\n    if (!stdout.readableEnded) {\n      debug(`[${threadId}] explicitly closes stdout for ${this.threadId}`);\n      stdout.push(null);\n    }\n    if (!stderr.readableEnded) {\n      debug(`[${threadId}] explicitly closes stderr for ${this.threadId}`);\n      stderr.push(null);\n    }\n  }\n\n  postMessage(...args) {\n    if (this[kPublicPort] === null) return;\n\n    ReflectApply(this[kPublicPort].postMessage\x2C this[kPublicPort]\x2C args);\n  }\n\n  terminate(callback) {\n    debug(`[${threadId}] terminates Worker with ID ${this.threadId}`);\n\n    this.ref();\n\n    if (typeof callback === 'function') {\n      process.emitWarning(\n        'Passing a callback to worker.terminate() is deprecated. ' +\n        'It returns a Promise instead.'\x2C\n        'DeprecationWarning'\x2C 'DEP0132');\n      if (this[kHandle] === null) return PromiseResolve();\n      this.once('exit'\x2C (exitCode) => callback(null\x2C exitCode));\n    }\n\n    if (this[kHandle] === null) return PromiseResolve();\n\n    this[kHandle].stopThread();\n\n    // Do not use events.once() here\x2C because the 'exit' event will always be\n    // emitted regardless of any errors\x2C and the point is to only resolve\n    // once the thread has actually stopped.\n    return new Promise((resolve) => {\n      this.once('exit'\x2C resolve);\n    });\n  }\n\n  ref() {\n    if (this[kHandle] === null) return;\n\n    this[kHandle].ref();\n    this[kPublicPort].ref();\n  }\n\n  unref() {\n    if (this[kHandle] === null) return;\n\n    this[kHandle].unref();\n    this[kPublicPort].unref();\n  }\n\n  get threadId() {\n    if (this[kHandle] === null) return -1;\n\n    return this[kHandle].threadId;\n  }\n\n  get stdin() {\n    return this[kParentSideStdio].stdin;\n  }\n\n  get stdout() {\n    return this[kParentSideStdio].stdout;\n  }\n\n  get stderr() {\n    return this[kParentSideStdio].stderr;\n  }\n\n  get resourceLimits() {\n    if (this[kHandle] === null) return {};\n\n    return makeResourceLimits(this[kHandle].getResourceLimits());\n  }\n\n  getHeapSnapshot(options) {\n    const {\n      HeapSnapshotStream\x2C\n      getHeapSnapshotOptions\x2C\n    } = require('internal/heap_utils');\n    const optionsArray = getHeapSnapshotOptions(options);\n    const heapSnapshotTaker = this[kHandle]?.takeHeapSnapshot(optionsArray);\n    return new Promise((resolve\x2C reject) => {\n      if (!heapSnapshotTaker) return reject(new ERR_WORKER_NOT_RUNNING());\n      heapSnapshotTaker.ondone = (handle) => {\n        resolve(new HeapSnapshotStream(handle));\n      };\n    });\n  }\n}\n\n/**\n * A worker which has an internal module for entry point (e.g. internal/module/esm/worker).\n * Internal workers bypass the permission model.\n */\nclass InternalWorker extends Worker {\n  constructor(filename\x2C options) {\n    super(filename\x2C options\x2C kIsInternal);\n  }\n\n  receiveMessageSync() {\n    return receiveMessageOnPort(this[kPublicPort]);\n  }\n}\n\nfunction pipeWithoutWarning(source\x2C dest) {\n  const sourceMaxListeners = source._maxListeners;\n  const destMaxListeners = dest._maxListeners;\n  source.setMaxListeners(Infinity);\n  dest.setMaxListeners(Infinity);\n\n  source.pipe(dest);\n\n  source._maxListeners = sourceMaxListeners;\n  dest._maxListeners = destMaxListeners;\n}\n\nconst resourceLimitsArray = new Float64Array(kTotalResourceLimitCount);\nfunction parseResourceLimits(obj) {\n  const ret = resourceLimitsArray;\n  TypedArrayPrototypeFill(ret\x2C -1);\n  if (typeof obj !== 'object' || obj === null) return ret;\n\n  if (typeof obj.maxOldGenerationSizeMb === 'number')\n    ret[kMaxOldGenerationSizeMb] = MathMax(obj.maxOldGenerationSizeMb\x2C 2);\n  if (typeof obj.maxYoungGenerationSizeMb === 'number')\n    ret[kMaxYoungGenerationSizeMb] = obj.maxYoungGenerationSizeMb;\n  if (typeof obj.codeRangeSizeMb === 'number')\n    ret[kCodeRangeSizeMb] = obj.codeRangeSizeMb;\n  if (typeof obj.stackSizeMb === 'number')\n    ret[kStackSizeMb] = obj.stackSizeMb;\n  return ret;\n}\n\nfunction makeResourceLimits(float64arr) {\n  return {\n    maxYoungGenerationSizeMb: float64arr[kMaxYoungGenerationSizeMb]\x2C\n    maxOldGenerationSizeMb: float64arr[kMaxOldGenerationSizeMb]\x2C\n    codeRangeSizeMb: float64arr[kCodeRangeSizeMb]\x2C\n    stackSizeMb: float64arr[kStackSizeMb]\x2C\n  };\n}\n\nfunction eventLoopUtilization(util1\x2C util2) {\n  // TODO(trevnorris): Works to solve the thread-safe read/write issue of\n  // loopTime\x2C but has the drawback that it can't be set until the event loop\n  // has had a chance to turn. So it will be impossible to read the ELU of\n  // a worker thread immediately after it's been created.\n  if (!this[kIsOnline] || !this[kHandle]) {\n    return { idle: 0\x2C active: 0\x2C utilization: 0 };\n  }\n\n  // Cache loopStart\x2C since it's only written to once.\n  if (this[kLoopStartTime] === -1) {\n    this[kLoopStartTime] = this[kHandle].loopStartTime();\n    if (this[kLoopStartTime] === -1)\n      return { idle: 0\x2C active: 0\x2C utilization: 0 };\n  }\n\n  return internalEventLoopUtilization(\n    this[kLoopStartTime]\x2C\n    this[kHandle].loopIdleTime()\x2C\n    util1\x2C\n    util2\x2C\n  );\n}\n\nmodule.exports = {\n  ownsProcessState\x2C\n  kIsOnline\x2C\n  isMainThread\x2C\n  SHARE_ENV\x2C\n  resourceLimits:\n    !isMainThread ? makeResourceLimits(resourceLimitsRaw) : {}\x2C\n  setEnvironmentData\x2C\n  getEnvironmentData\x2C\n  assignEnvironmentData\x2C\n  threadId\x2C\n  InternalWorker\x2C\n  Worker\x2C\n};\n
code-source-info,0x31e6f25d8b9e,89,0,16395,C0O0C4O16395,,
code-creation,JS,10,88539,0x31e6f25da176,1343, node:internal/worker:1:1,0x31e6f25d8b18,~
code-source-info,0x31e6f25da176,89,0,16395,C0O0C262O25C268O50C274O71C280O93C285O109C291O134C297O151C303O162C309O179C315O190C321O208C327O224C333O247C339O268C344O279C350O289C356O312C361O322C366O335C372O362C377O389C383O391C389O400C394O460C402O460C407O494C415O494C419O494C421O535C429O535C433O535C435O596C443O596C449O562C455O665C463O665C469O691C473O665C475O872C479O709C485O735C491O754C497O789C503O821C509O845C515O911C523O911C529O892C535O958C543O958C547O958C549O1230C553O999C559O1019C565O1043C571O1061C577O1077C583O1086C589O1108C595O1127C601O1158C607O1182C613O1205C619O1269C627O1269C633O1248C639O1351C647O1351C653O1311C659O1326C665O1333C671O1401C679O1401C685O1384C691O1469C699O1469C705O1435C711O1450C717O1540C725O1540C731O1511C737O1820C741O1820C747O1591C752O1611C757O1643C762O1664C768O1684C774O1698C780O1727C786O1754C792O1774C798O1790C803O1864C807O1864C811O1864C813O1903C817O1903C821O1903C823O1943C827O1943C831O1943C833O1979C837O1979C841O1979C843O2017C847O2017C851O2017C853O2071C857O2071C861O2071C863O2130C867O2130C871O2130C873O2182C877O2182C881O2182C883O2233C887O2233C891O2233C893O2279C897O2279C901O2279C903O2320C907O2320C911O2320C913O2360C917O2360C921O2360C923O2418C931O2418C937O2451C953O2452C959O2418C961O2511C969O2511C974O2575C984O2575C989O2572C991O2607C992O2607C994O2644C996O2644C1001O2644C1003O2789C1015O2852C1022O2871C1028O2900C1037O2884C1042O2882C1046O2951C1052O2959C1056O2951C1058O2968C1068O2982C1074O3464C1084O9226C1094O9862C1104O9962C1114O10135C1124O11032C1208O13838C1238O14366C1240O14366C1245O14366C1247O16120C1255O16141C1261O16161C1267O16174C1273O16190C1282O16224C1288O16239C1301O16285C1307O16307C1313O16329C1319O16354C1325O16366C1331O16384C1337O16135C1342O16394,,
tick,0x10c6e4514,88690,1,0x10c1e6120,3,0x10c41e000,0x112583f26,0x112583ca1,0x31e6f25d7289,0x112583feb,0x31e6f25d6c7a,0x31e6f25d6880,0x31e6f6b607cb,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f25d543c,0x31e6f6b7a501,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
tick,0x7ff8092cbace,88733,1,0x10c1e6120,3,0x10c41e000,0x112583f26,0x112583ca1,0x31e6f25d7289,0x112583feb,0x31e6f25d6c7a,0x31e6f25d6880,0x31e6f6b607cb,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f25d543c,0x31e6f6b7a501,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,Eval,10,88891,0x31e6f25dc0fe,5, node:internal/perf/event_loop_utilization:1:1,0x31e6f25dbf68,~
script-source,90,node:internal/perf/event_loop_utilization,'use strict';\n\nconst {\n  constants: {\n    NODE_PERFORMANCE_MILESTONE_LOOP_START\x2C\n  }\x2C\n  loopIdleTime\x2C\n  milestones\x2C\n} = internalBinding('performance');\n\nfunction eventLoopUtilization(util1\x2C util2) {\n  // Get the original milestone timestamps that calculated from the beginning\n  // of the process.\n  return internalEventLoopUtilization(\n    milestones[NODE_PERFORMANCE_MILESTONE_LOOP_START] / 1e6\x2C\n    loopIdleTime()\x2C\n    util1\x2C\n    util2\x2C\n  );\n}\n\nfunction internalEventLoopUtilization(loopStart\x2C loopIdleTime\x2C util1\x2C util2) {\n  if (loopStart <= 0) {\n    return { idle: 0\x2C active: 0\x2C utilization: 0 };\n  }\n\n  if (util2) {\n    const idle = util1.idle - util2.idle;\n    const active = util1.active - util2.active;\n    return { idle\x2C active\x2C utilization: active / (idle + active) };\n  }\n\n  // Using process.hrtime() to get the time from the beginning of the process\x2C\n  // and offset it by the loopStart time (which is also calculated from the\n  // beginning of the process).\n  const now = process.hrtime();\n  const active = now[0] * 1e3 + now[1] / 1e6 - loopStart - loopIdleTime;\n\n  if (!util1) {\n    return {\n      idle: loopIdleTime\x2C\n      active\x2C\n      utilization: active / (loopIdleTime + active)\x2C\n    };\n  }\n\n  const idleDelta = loopIdleTime - util1.idle;\n  const activeDelta = active - util1.active;\n  const utilization = activeDelta / (idleDelta + activeDelta);\n  return {\n    idle: idleDelta\x2C\n    active: activeDelta\x2C\n    utilization\x2C\n  };\n}\n\nmodule.exports = {\n  internalEventLoopUtilization\x2C\n  eventLoopUtilization\x2C\n};\n
code-source-info,0x31e6f25dc0fe,90,0,1527,C0O0C4O1527,,
code-creation,JS,10,89052,0x31e6f25dc2ae,85, node:internal/perf/event_loop_utilization:1:1,0x31e6f25dc078,~
code-source-info,0x31e6f25dc2ae,90,0,1527,C0O0C29O120C32O120C37O36C42O42C48O88C54O104C60O1449C67O1470C73O1502C79O1464C84O1526,,
code-creation,Eval,10,89621,0x31e6f25dd35e,5, node:internal/worker/io:1:1,0x31e6f25dced8,~
script-source,91,node:internal/worker/io,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  ObjectAssign\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectGetOwnPropertyDescriptors\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  ObjectValues\x2C\n  ReflectApply\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n} = primordials;\n\nconst {\n  kEmptyObject\x2C\n  kEnumerableProperty\x2C\n  setOwnProperty\x2C\n} = require('internal/util');\n\nconst {\n  handle_onclose: handleOnCloseSymbol\x2C\n  oninit: onInitSymbol\x2C\n  no_message_symbol: noMessageSymbol\x2C\n} = internalBinding('symbols');\nconst {\n  MessagePort\x2C\n  MessageChannel\x2C\n  broadcastChannel\x2C\n  drainMessagePort\x2C\n  moveMessagePortToContext\x2C\n  receiveMessageOnPort: receiveMessageOnPort_\x2C\n  stopMessagePort\x2C\n  checkMessagePort\x2C\n  DOMException\x2C\n} = internalBinding('messaging');\nconst {\n  getEnvMessagePort\x2C\n} = internalBinding('worker');\n\nconst { Readable\x2C Writable } = require('stream');\nconst {\n  Event\x2C\n  EventTarget\x2C\n  NodeEventTarget\x2C\n  defineEventHandler\x2C\n  initNodeEventTarget\x2C\n  kCreateEvent\x2C\n  kNewListener\x2C\n  kRemoveListener\x2C\n} = require('internal/event_target');\nconst { inspect } = require('internal/util/inspect');\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_THIS\x2C\n    ERR_MISSING_ARGS\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst kData = Symbol('kData');\nconst kHandle = Symbol('kHandle');\nconst kIncrementsPortRef = Symbol('kIncrementsPortRef');\nconst kLastEventId = Symbol('kLastEventId');\nconst kName = Symbol('kName');\nconst kOrigin = Symbol('kOrigin');\nconst kOnMessage = Symbol('kOnMessage');\nconst kOnMessageError = Symbol('kOnMessageError');\nconst kPort = Symbol('kPort');\nconst kPorts = Symbol('kPorts');\nconst kWaitingStreams = Symbol('kWaitingStreams');\nconst kWritableCallbacks = Symbol('kWritableCallbacks');\nconst kSource = Symbol('kSource');\nconst kStartedReading = Symbol('kStartedReading');\nconst kStdioWantsMoreDataCallback = Symbol('kStdioWantsMoreDataCallback');\nconst kCurrentlyReceivingPorts =\n  SymbolFor('nodejs.internal.kCurrentlyReceivingPorts');\nconst kType = Symbol('kType');\n\nconst messageTypes = {\n  UP_AND_RUNNING: 'upAndRunning'\x2C\n  COULD_NOT_SERIALIZE_ERROR: 'couldNotSerializeError'\x2C\n  ERROR_MESSAGE: 'errorMessage'\x2C\n  STDIO_PAYLOAD: 'stdioPayload'\x2C\n  STDIO_WANTS_MORE_DATA: 'stdioWantsMoreData'\x2C\n  LOAD_SCRIPT: 'loadScript'\x2C\n};\n\n// We have to mess with the MessagePort prototype a bit\x2C so that a) we can make\n// it inherit from NodeEventTarget\x2C even though it is a C++ class\x2C and b) we do\n// not provide methods that are not present in the Browser and not documented\n// on our side (e.g. stopMessagePort).\nconst messagePortPrototypePropertyDescriptors = ObjectGetOwnPropertyDescriptors(MessagePort.prototype);\nconst propertiesValues = ObjectValues(messagePortPrototypePropertyDescriptors);\nfor (let i = 0; i < propertiesValues.length; i++) {\n  // We want to use null-prototype objects to not rely on globally mutable\n  // %Object.prototype%.\n  ObjectSetPrototypeOf(propertiesValues[i]\x2C null);\n}\n// Save a copy of the original set of methods as a shallow clone.\nconst MessagePortPrototype = ObjectCreate(\n  ObjectGetPrototypeOf(MessagePort.prototype)\x2C\n  messagePortPrototypePropertyDescriptors);\n// Set up the new inheritance chain.\nObjectSetPrototypeOf(MessagePort\x2C NodeEventTarget);\nObjectSetPrototypeOf(MessagePort.prototype\x2C NodeEventTarget.prototype);\n// Copy methods that are inherited from HandleWrap\x2C because\n// changing the prototype of MessagePort.prototype implicitly removed them.\nMessagePort.prototype.ref = MessagePortPrototype.ref;\nMessagePort.prototype.unref = MessagePortPrototype.unref;\nMessagePort.prototype.hasRef = function() {\n  return !!FunctionPrototypeCall(MessagePortPrototype.hasRef\x2C this);\n};\n\nfunction validateMessagePort(port\x2C name) {\n  if (!checkMessagePort(port))\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'MessagePort'\x2C port);\n}\n\nfunction isMessageEvent(value) {\n  return value != null && kData in value;\n}\n\nclass MessageEvent extends Event {\n  constructor(type\x2C {\n    data = null\x2C\n    origin = ''\x2C\n    lastEventId = ''\x2C\n    source = null\x2C\n    ports = []\x2C\n  } = kEmptyObject) {\n    super(type);\n    this[kData] = data;\n    this[kOrigin] = `${origin}`;\n    this[kLastEventId] = `${lastEventId}`;\n    this[kSource] = source;\n    this[kPorts] = [...ports];\n\n    if (this[kSource] !== null)\n      validateMessagePort(this[kSource]\x2C 'init.source');\n    for (let i = 0; i < this[kPorts].length; i++)\n      validateMessagePort(this[kPorts][i]\x2C `init.ports[${i}]`);\n  }\n}\n\nObjectDefineProperties(MessageEvent.prototype\x2C {\n  data: {\n    __proto__: null\x2C\n    get() {\n      if (!isMessageEvent(this))\n        throw new ERR_INVALID_THIS('MessageEvent');\n      return this[kData];\n    }\x2C\n    enumerable: true\x2C\n    configurable: true\x2C\n    set: undefined\x2C\n  }\x2C\n  origin: {\n    __proto__: null\x2C\n    get() {\n      if (!isMessageEvent(this))\n        throw new ERR_INVALID_THIS('MessageEvent');\n      return this[kOrigin];\n    }\x2C\n    enumerable: true\x2C\n    configurable: true\x2C\n    set: undefined\x2C\n  }\x2C\n  lastEventId: {\n    __proto__: null\x2C\n    get() {\n      if (!isMessageEvent(this))\n        throw new ERR_INVALID_THIS('MessageEvent');\n      return this[kLastEventId];\n    }\x2C\n    enumerable: true\x2C\n    configurable: true\x2C\n    set: undefined\x2C\n  }\x2C\n  source: {\n    __proto__: null\x2C\n    get() {\n      if (!isMessageEvent(this))\n        throw new ERR_INVALID_THIS('MessageEvent');\n      return this[kSource];\n    }\x2C\n    enumerable: true\x2C\n    configurable: true\x2C\n    set: undefined\x2C\n  }\x2C\n  ports: {\n    __proto__: null\x2C\n    get() {\n      if (!isMessageEvent(this))\n        throw new ERR_INVALID_THIS('MessageEvent');\n      return this[kPorts];\n    }\x2C\n    enumerable: true\x2C\n    configurable: true\x2C\n    set: undefined\x2C\n  }\x2C\n});\n\nconst originalCreateEvent = EventTarget.prototype[kCreateEvent];\nObjectDefineProperty(\n  MessagePort.prototype\x2C\n  kCreateEvent\x2C\n  {\n    __proto__: null\x2C\n    value: function(data\x2C type) {\n      if (type !== 'message' && type !== 'messageerror') {\n        return ReflectApply(originalCreateEvent\x2C this\x2C arguments);\n      }\n      const ports = this[kCurrentlyReceivingPorts];\n      this[kCurrentlyReceivingPorts] = undefined;\n      return new MessageEvent(type\x2C { data\x2C ports });\n    }\x2C\n    configurable: false\x2C\n    writable: false\x2C\n    enumerable: false\x2C\n  });\n\n// This is called from inside the `MessagePort` constructor.\nfunction oninit() {\n  initNodeEventTarget(this);\n  setupPortReferencing(this\x2C this\x2C 'message');\n  this[kCurrentlyReceivingPorts] = undefined;\n}\n\ndefineEventHandler(MessagePort.prototype\x2C 'message');\ndefineEventHandler(MessagePort.prototype\x2C 'messageerror');\n\nObjectDefineProperty(MessagePort.prototype\x2C onInitSymbol\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  writable: false\x2C\n  value: oninit\x2C\n});\n\nclass MessagePortCloseEvent extends Event {\n  constructor() {\n    super('close');\n  }\n}\n\n// This is called after the underlying `uv_async_t` has been closed.\nfunction onclose() {\n  this.dispatchEvent(new MessagePortCloseEvent());\n}\n\nObjectDefineProperty(MessagePort.prototype\x2C handleOnCloseSymbol\x2C {\n  __proto__: null\x2C\n  enumerable: false\x2C\n  writable: false\x2C\n  value: onclose\x2C\n});\n\nMessagePort.prototype.close = function(cb) {\n  if (typeof cb === 'function')\n    this.once('close'\x2C cb);\n  FunctionPrototypeCall(MessagePortPrototype.close\x2C this);\n};\n\nObjectDefineProperty(MessagePort.prototype\x2C inspect.custom\x2C {\n  __proto__: null\x2C\n  enumerable: false\x2C\n  writable: false\x2C\n  value: function inspect() {  // eslint-disable-line func-name-matching\n    let ref;\n    try {\n      // This may throw when `this` does not refer to a native object\x2C\n      // e.g. when accessing the prototype directly.\n      ref = FunctionPrototypeCall(MessagePortPrototype.hasRef\x2C this);\n    } catch { return this; }\n    return ObjectAssign({ __proto__: MessagePort.prototype }\x2C\n                        ref === undefined ? {\n                          active: false\x2C\n                        } : {\n                          active: true\x2C\n                          refed: ref\x2C\n                        }\x2C\n                        this);\n  }\x2C\n});\n\nfunction setupPortReferencing(port\x2C eventEmitter\x2C eventName) {\n  // Keep track of whether there are any workerMessage listeners:\n  // If there are some\x2C ref() the channel so it keeps the event loop alive.\n  // If there are none or all are removed\x2C unref() the channel so the worker\n  // can shutdown gracefully.\n  port.unref();\n  eventEmitter.on('newListener'\x2C function(name) {\n    if (name === eventName) newListener(eventEmitter.listenerCount(name));\n  });\n  eventEmitter.on('removeListener'\x2C function(name) {\n    if (name === eventName) removeListener(eventEmitter.listenerCount(name));\n  });\n  const origNewListener = eventEmitter[kNewListener];\n  setOwnProperty(eventEmitter\x2C kNewListener\x2C function(size\x2C type\x2C ...args) {\n    if (type === eventName) newListener(size - 1);\n    return ReflectApply(origNewListener\x2C this\x2C arguments);\n  });\n  const origRemoveListener = eventEmitter[kRemoveListener];\n  setOwnProperty(eventEmitter\x2C kRemoveListener\x2C function(size\x2C type\x2C ...args) {\n    if (type === eventName) removeListener(size);\n    return ReflectApply(origRemoveListener\x2C this\x2C arguments);\n  });\n\n  function newListener(size) {\n    if (size === 0) {\n      port.ref();\n      FunctionPrototypeCall(MessagePortPrototype.start\x2C port);\n    }\n  }\n\n  function removeListener(size) {\n    if (size === 0) {\n      stopMessagePort(port);\n      port.unref();\n    }\n  }\n}\n\n\nclass ReadableWorkerStdio extends Readable {\n  constructor(port\x2C name) {\n    super();\n    this[kPort] = port;\n    this[kName] = name;\n    this[kIncrementsPortRef] = true;\n    this[kStartedReading] = false;\n    this.on('end'\x2C () => {\n      if (this[kStartedReading] && this[kIncrementsPortRef]) {\n        if (--this[kPort][kWaitingStreams] === 0)\n          this[kPort].unref();\n      }\n    });\n  }\n\n  _read() {\n    if (!this[kStartedReading] && this[kIncrementsPortRef]) {\n      this[kStartedReading] = true;\n      if (this[kPort][kWaitingStreams]++ === 0)\n        this[kPort].ref();\n    }\n\n    this[kPort].postMessage({\n      type: messageTypes.STDIO_WANTS_MORE_DATA\x2C\n      stream: this[kName]\x2C\n    });\n  }\n}\n\nclass WritableWorkerStdio extends Writable {\n  constructor(port\x2C name) {\n    super({ decodeStrings: false });\n    this[kPort] = port;\n    this[kName] = name;\n    this[kWritableCallbacks] = [];\n  }\n\n  _writev(chunks\x2C cb) {\n    this[kPort].postMessage({\n      type: messageTypes.STDIO_PAYLOAD\x2C\n      stream: this[kName]\x2C\n      chunks: ArrayPrototypeMap(chunks\x2C\n                                ({ chunk\x2C encoding }) => ({ chunk\x2C encoding }))\x2C\n    });\n    ArrayPrototypePush(this[kWritableCallbacks]\x2C cb);\n    if (this[kPort][kWaitingStreams]++ === 0)\n      this[kPort].ref();\n  }\n\n  _final(cb) {\n    this[kPort].postMessage({\n      type: messageTypes.STDIO_PAYLOAD\x2C\n      stream: this[kName]\x2C\n      chunks: [ { chunk: null\x2C encoding: '' } ]\x2C\n    });\n    cb();\n  }\n\n  [kStdioWantsMoreDataCallback]() {\n    const cbs = this[kWritableCallbacks];\n    this[kWritableCallbacks] = [];\n    ArrayPrototypeForEach(cbs\x2C (cb) => cb());\n    if ((this[kPort][kWaitingStreams] -= cbs.length) === 0)\n      this[kPort].unref();\n  }\n}\n\nfunction createWorkerStdio() {\n  const port = getEnvMessagePort();\n  port[kWaitingStreams] = 0;\n  return {\n    stdin: new ReadableWorkerStdio(port\x2C 'stdin')\x2C\n    stdout: new WritableWorkerStdio(port\x2C 'stdout')\x2C\n    stderr: new WritableWorkerStdio(port\x2C 'stderr')\x2C\n  };\n}\n\nfunction receiveMessageOnPort(port) {\n  const message = receiveMessageOnPort_(port?.[kHandle] ?? port);\n  if (message === noMessageSymbol) return undefined;\n  return { message };\n}\n\nfunction onMessageEvent(type\x2C data) {\n  this.dispatchEvent(new MessageEvent(type\x2C { data }));\n}\n\nfunction isBroadcastChannel(value) {\n  return value?.[kType] === 'BroadcastChannel';\n}\n\nclass BroadcastChannel extends EventTarget {\n  /**\n   * @param {string} name\n   */\n  constructor(name) {\n    if (arguments.length === 0)\n      throw new ERR_MISSING_ARGS('name');\n    super();\n    this[kType] = 'BroadcastChannel';\n    this[kName] = `${name}`;\n    this[kHandle] = broadcastChannel(this[kName]);\n    this[kOnMessage] = FunctionPrototypeBind(onMessageEvent\x2C this\x2C 'message');\n    this[kOnMessageError] =\n      FunctionPrototypeBind(onMessageEvent\x2C this\x2C 'messageerror');\n    this[kHandle].on('message'\x2C this[kOnMessage]);\n    this[kHandle].on('messageerror'\x2C this[kOnMessageError]);\n  }\n\n  [inspect.custom](depth\x2C options) {\n    if (!isBroadcastChannel(this))\n      throw new ERR_INVALID_THIS('BroadcastChannel');\n    if (depth < 0)\n      return 'BroadcastChannel';\n\n    const opts = {\n      ...options\x2C\n      depth: options.depth == null ? null : options.depth - 1\x2C\n    };\n\n    return `BroadcastChannel ${inspect({\n      name: this[kName]\x2C\n      active: this[kHandle] !== undefined\x2C\n    }\x2C opts)}`;\n  }\n\n  /**\n   * @type {string}\n   */\n  get name() {\n    if (!isBroadcastChannel(this))\n      throw new ERR_INVALID_THIS('BroadcastChannel');\n    return this[kName];\n  }\n\n  /**\n   * @returns {void}\n   */\n  close() {\n    if (!isBroadcastChannel(this))\n      throw new ERR_INVALID_THIS('BroadcastChannel');\n    if (this[kHandle] === undefined)\n      return;\n    this[kHandle].off('message'\x2C this[kOnMessage]);\n    this[kHandle].off('messageerror'\x2C this[kOnMessageError]);\n    this[kOnMessage] = undefined;\n    this[kOnMessageError] = undefined;\n    this[kHandle].close();\n    this[kHandle] = undefined;\n  }\n\n  /**\n   *\n   * @param {any} message\n   * @returns {void}\n   */\n  postMessage(message) {\n    if (!isBroadcastChannel(this))\n      throw new ERR_INVALID_THIS('BroadcastChannel');\n    if (arguments.length === 0)\n      throw new ERR_MISSING_ARGS('message');\n    if (this[kHandle] === undefined)\n      throw new DOMException('BroadcastChannel is closed.');\n    if (this[kHandle].postMessage(message) === undefined)\n      throw new DOMException('Message could not be posted.');\n  }\n\n  // The ref() method is Node.js specific and not part of the standard\n  // BroadcastChannel API definition. Typically we shouldn't extend Web\n  // Platform APIs with Node.js specific methods but ref and unref\n  // are a bit special.\n  /**\n   * @returns {BroadcastChannel}\n   */\n  ref() {\n    if (!isBroadcastChannel(this))\n      throw new ERR_INVALID_THIS('BroadcastChannel');\n    if (this[kHandle])\n      this[kHandle].ref();\n    return this;\n  }\n\n  // The unref() method is Node.js specific and not part of the standard\n  // BroadcastChannel API definition. Typically we shouldn't extend Web\n  // Platform APIs with Node.js specific methods but ref and unref\n  // are a bit special.\n  /**\n   * @returns {BroadcastChannel}\n   */\n  unref() {\n    if (!isBroadcastChannel(this))\n      throw new ERR_INVALID_THIS('BroadcastChannel');\n    if (this[kHandle])\n      this[kHandle].unref();\n    return this;\n  }\n}\n\nObjectDefineProperties(BroadcastChannel.prototype\x2C {\n  name: kEnumerableProperty\x2C\n  close: kEnumerableProperty\x2C\n  postMessage: kEnumerableProperty\x2C\n});\n\ndefineEventHandler(BroadcastChannel.prototype\x2C 'message');\ndefineEventHandler(BroadcastChannel.prototype\x2C 'messageerror');\n\nmodule.exports = {\n  drainMessagePort\x2C\n  messageTypes\x2C\n  kPort\x2C\n  kIncrementsPortRef\x2C\n  kWaitingStreams\x2C\n  kStdioWantsMoreDataCallback\x2C\n  moveMessagePortToContext\x2C\n  MessagePort\x2C\n  MessageChannel\x2C\n  MessageEvent\x2C\n  receiveMessageOnPort\x2C\n  setupPortReferencing\x2C\n  ReadableWorkerStdio\x2C\n  WritableWorkerStdio\x2C\n  createWorkerStdio\x2C\n  BroadcastChannel\x2C\n};\n
code-source-info,0x31e6f25dd35e,91,0,15479,C0O0C4O15479,,
code-creation,JS,10,90590,0x31e6f25df306,1709, node:internal/worker/io:1:1,0x31e6f25dd2d8,~
code-source-info,0x31e6f25df306,91,0,15479,C0O0C200O25C206O50C212O71C218O93C224O118C230O143C236O159C241O175C246O199C251O225C256O260C261O284C266O308C271O324C277O340C282O350C287O448C291O448C297O389C303O405C308O428C314O588C318O588C324O501C329O532C334O567C340O831C344O831C350O626C356O641C361O659C367O679C372O699C377O749C383O774C389O793C395O813C401O894C405O894C411O871C417O953C421O953C427O930C432O940C438O1123C442O1123C448O982C454O991C460O1006C466O1025C472O1047C478O1070C484O1086C490O1102C496O1177C500O1177C506O1165C512O1309C516O1309C522O1228C528O1234C534O1260C540O1282C546O1352C550O1352C554O1352C556O1385C560O1385C564O1385C566O1431C570O1431C574O1431C576O1482C580O1482C584O1482C586O1520C590O1520C594O1520C596O1553C600O1553C604O1553C606O1591C610O1591C614O1591C616O1637C620O1637C624O1637C626O1678C630O1678C634O1678C636O1710C640O1710C644O1710C646O1752C650O1752C654O1752C656O1806C660O1806C664O1806C666O1852C670O1852C674O1852C676O1895C680O1895C684O1895C686O1958C690O1958C696O2032C700O2032C704O2032C706O2101C710O2101C714O2101C716O2140C720O2140C722O2702C726O2746C732O2702C738O2783C744O2851C747O2875C751O2856C756O2992C758O3029C766O2992C771O2884C777O2838C781O3138C785O3187C791O3154C797O3138C802O3138C804O3280C808O3280C813O3332C817O3365C823O3392C829O3332C834O3540C838O3552C848O3589C852O3566C856O3594C860O3606C870O3645C874O3622C878O3652C882O3664C892O3681C896O4014C919O3987C921O4544C925O4580C937O4601C943O4628C952O4809C962O4835C968O4862C977O5045C987O5076C993O5103C1002O5291C1012O5317C1018O5344C1027O5527C1037O5552C1043O5579C1052O5761C1062O4544C1067O5822C1075O5831C1078O5810C1080O5847C1084O5883C1090O5896C1096O5946C1107O5847C1112O6548C1116O6579C1126O6548C1131O6602C1135O6633C1145O6602C1150O6662C1154O6695C1160O6706C1168O6789C1175O6662C1180O6838C1203O6802C1205O7035C1209O7068C1215O7079C1223O7170C1230O7035C1235O7184C1239O7196C1249O7212C1253O7352C1257O7385C1267O7404C1279O7482C1287O7352C1292O9517C1321O9483C1323O10227C1343O10958C1368O10193C1370O11878C1380O12459C1384O12459C1440O14891C1454O14912C1460O14942C1470O14978C1478O14851C1488O15040C1498O15004C1508O15099C1518O15063C1528O15128C1539O15149C1549O15169C1559O15185C1569O15194C1579O15216C1589O15235C1599O15266C1609O15294C1619O15309C1629O15327C1639O15343C1649O15367C1659O15391C1669O15414C1679O15437C1689O15458C1699O15143C1708O15478,,
tick,0x7ff809303aef,90714,1,0x10c1e6120,3,0x10c41e000,0x112583f26,0x112583ca1,0x31e6f25da395,0x112583feb,0x112583ca1,0x31e6f25d7289,0x112583feb,0x31e6f25d6c7a,0x31e6f25d6880,0x31e6f6b607cb,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f25d543c,0x31e6f6b7a501,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
tick,0x10c8fa430,91004,1,0x10c1e6120,3,0x10c41e000,0x112583f26,0x112583ca1,0x31e6f25df4ab,0x112583feb,0x112583ca1,0x31e6f25da395,0x112583feb,0x112583ca1,0x31e6f25d7289,0x112583feb,0x31e6f25d6c7a,0x31e6f25d6880,0x31e6f6b607cb,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f25d543c,0x31e6f6b7a501,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,Eval,10,91041,0x31e6f25e1b66,5, node:stream:1:1,0x31e6f25e1960,~
script-source,92,node:stream,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ObjectDefineProperty\x2C\n  ObjectKeys\x2C\n  ReflectApply\x2C\n} = primordials;\n\nconst {\n  promisify: { custom: customPromisify }\x2C\n} = require('internal/util');\n\nconst {\n  streamReturningOperators\x2C\n  promiseReturningOperators\x2C\n} = require('internal/streams/operators');\n\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR\x2C\n  }\x2C\n} = require('internal/errors');\nconst compose = require('internal/streams/compose');\nconst { setDefaultHighWaterMark\x2C getDefaultHighWaterMark } = require('internal/streams/state');\nconst { pipeline } = require('internal/streams/pipeline');\nconst { destroyer } = require('internal/streams/destroy');\nconst eos = require('internal/streams/end-of-stream');\nconst internalBuffer = require('internal/buffer');\n\nconst promises = require('stream/promises');\nconst utils = require('internal/streams/utils');\n\nconst Stream = module.exports = require('internal/streams/legacy').Stream;\n\nStream.isDestroyed = utils.isDestroyed;\nStream.isDisturbed = utils.isDisturbed;\nStream.isErrored = utils.isErrored;\nStream.isReadable = utils.isReadable;\nStream.isWritable = utils.isWritable;\n\nStream.Readable = require('internal/streams/readable');\nfor (const key of ObjectKeys(streamReturningOperators)) {\n  const op = streamReturningOperators[key];\n  function fn(...args) {\n    if (new.target) {\n      throw new ERR_ILLEGAL_CONSTRUCTOR();\n    }\n    return Stream.Readable.from(ReflectApply(op\x2C this\x2C args));\n  }\n  ObjectDefineProperty(fn\x2C 'name'\x2C { __proto__: null\x2C value: op.name });\n  ObjectDefineProperty(fn\x2C 'length'\x2C { __proto__: null\x2C value: op.length });\n  ObjectDefineProperty(Stream.Readable.prototype\x2C key\x2C {\n    __proto__: null\x2C\n    value: fn\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    writable: true\x2C\n  });\n}\nfor (const key of ObjectKeys(promiseReturningOperators)) {\n  const op = promiseReturningOperators[key];\n  function fn(...args) {\n    if (new.target) {\n      throw new ERR_ILLEGAL_CONSTRUCTOR();\n    }\n    return ReflectApply(op\x2C this\x2C args);\n  }\n  ObjectDefineProperty(fn\x2C 'name'\x2C { __proto__: null\x2C value: op.name });\n  ObjectDefineProperty(fn\x2C 'length'\x2C { __proto__: null\x2C value: op.length });\n  ObjectDefineProperty(Stream.Readable.prototype\x2C key\x2C {\n    __proto__: null\x2C\n    value: fn\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    writable: true\x2C\n  });\n}\nStream.Writable = require('internal/streams/writable');\nStream.Duplex = require('internal/streams/duplex');\nStream.Transform = require('internal/streams/transform');\nStream.PassThrough = require('internal/streams/passthrough');\nStream.pipeline = pipeline;\nconst { addAbortSignal } = require('internal/streams/add-abort-signal');\nStream.addAbortSignal = addAbortSignal;\nStream.finished = eos;\nStream.destroy = destroyer;\nStream.compose = compose;\nStream.setDefaultHighWaterMark = setDefaultHighWaterMark;\nStream.getDefaultHighWaterMark = getDefaultHighWaterMark;\n\nObjectDefineProperty(Stream\x2C 'promises'\x2C {\n  __proto__: null\x2C\n  configurable: true\x2C\n  enumerable: true\x2C\n  get() {\n    return promises;\n  }\x2C\n});\n\nObjectDefineProperty(pipeline\x2C customPromisify\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  get() {\n    return promises.pipeline;\n  }\x2C\n});\n\nObjectDefineProperty(eos\x2C customPromisify\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  get() {\n    return promises.finished;\n  }\x2C\n});\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\nStream._isUint8Array = require('internal/util/types').isUint8Array;\nStream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {\n  return new internalBuffer.FastBuffer(chunk.buffer\x2C\n                                       chunk.byteOffset\x2C\n                                       chunk.byteLength);\n};\n
code-source-info,0x31e6f25e1b66,92,0,4792,C0O0C4O4792,,
code-creation,JS,10,91433,0x31e6f25e2286,1072, node:stream:1:1,0x31e6f25e1ae0,~
code-source-info,0x31e6f25e2286,92,0,4792,C0O0C20O1159C25O1183C30O1197C36O1283C40O1283C46O1250C52O1260C57O1379C61O1379C67O1320C72O1348C77O1476C81O1476C87O1436C93O1442C99O1520C103O1520C108O1618C112O1618C118O1565C123O1590C128O1674C132O1674C138O1661C143O1734C147O1734C153O1720C158O1783C162O1783C167O1849C171O1849C175O1849C177O1895C181O1895C185O1895C187O1937C191O1937C196O1988C200O2005C206O2039C212O2003C218O1988C220O2049C224O2076C228O2068C232O2089C236O2116C240O2108C244O2129C248O2154C252O2146C256O2165C260O2191C264O2183C268O2203C272O2229C276O2221C280O2242C288O2260C292O2258C296O2316C323O2309C354O2309C357O2309C370O2369C372O2393C375O2369C377O2565C381O2586C391O2627C402O2565C407O2638C411O2659C421O2702C432O2638C437O2715C443O2743C449O2752C455O2763C463O2802C470O2715C477O2298C549O2899C576O2892C607O2892C610O2892C623O2953C625O2978C628O2953C630O3128C634O3149C644O3190C655O3128C660O3201C664O3222C674O3265C685O3201C690O3278C696O3306C702O3315C708O3326C716O3365C723O3278C730O2881C802O3444C810O3462C814O3460C818O3500C826O3516C830O3514C834O3552C842O3571C846O3569C850O3610C858O3631C862O3629C866O3672C872O3688C876O3727C880O3727C886O3708C891O3773C897O3795C901O3813C907O3829C911O3836C917O3851C921O3864C927O3879C931O3890C937O3921C941O3948C947O3979C951O4007C959O4028C965O4113C973O4007C978O4183C984O4243C998O4152C1003O4317C1009O4377C1023O4291C1028O4461C1032O4475C1036O4486C1044O4509C1050O4539C1054O4507C1058O4554C1066O4581C1071O4791,,
code-creation,Eval,10,91869,0x31e6f25e3716,5, node:internal/streams/operators:1:1,0x31e6f25e33d0,~
script-source,93,node:internal/streams/operators,'use strict';\n\nconst { AbortController\x2C AbortSignal } = require('internal/abort_controller');\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_OUT_OF_RANGE\x2C\n  }\x2C\n  AbortError\x2C\n} = require('internal/errors');\nconst {\n  validateAbortSignal\x2C\n  validateInteger\x2C\n  validateObject\x2C\n} = require('internal/validators');\nconst { kWeakHandler\x2C kResistStopPropagation } = require('internal/event_target');\nconst { finished } = require('internal/streams/end-of-stream');\nconst staticCompose = require('internal/streams/compose');\nconst {\n  addAbortSignalNoValidate\x2C\n} = require('internal/streams/add-abort-signal');\nconst { isWritable\x2C isNodeStream } = require('internal/streams/utils');\nconst { deprecate } = require('internal/util');\n\nconst {\n  ArrayPrototypePush\x2C\n  Boolean\x2C\n  MathFloor\x2C\n  Number\x2C\n  NumberIsNaN\x2C\n  Promise\x2C\n  PromiseReject\x2C\n  PromiseResolve\x2C\n  PromisePrototypeThen\x2C\n  Symbol\x2C\n} = primordials;\n\nconst kEmpty = Symbol('kEmpty');\nconst kEof = Symbol('kEof');\n\nfunction compose(stream\x2C options) {\n  if (options != null) {\n    validateObject(options\x2C 'options');\n  }\n  if (options?.signal != null) {\n    validateAbortSignal(options.signal\x2C 'options.signal');\n  }\n\n  if (isNodeStream(stream) && !isWritable(stream)) {\n    throw new ERR_INVALID_ARG_VALUE('stream'\x2C stream\x2C 'must be writable');\n  }\n\n  const composedStream = staticCompose(this\x2C stream);\n\n  if (options?.signal) {\n    // Not validating as we already validated before\n    addAbortSignalNoValidate(\n      options.signal\x2C\n      composedStream\x2C\n    );\n  }\n\n  return composedStream;\n}\n\nfunction map(fn\x2C options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE(\n      'fn'\x2C ['Function'\x2C 'AsyncFunction']\x2C fn);\n  }\n  if (options != null) {\n    validateObject(options\x2C 'options');\n  }\n  if (options?.signal != null) {\n    validateAbortSignal(options.signal\x2C 'options.signal');\n  }\n\n  let concurrency = 1;\n  if (options?.concurrency != null) {\n    concurrency = MathFloor(options.concurrency);\n  }\n\n  let highWaterMark = concurrency - 1;\n  if (options?.highWaterMark != null) {\n    highWaterMark = MathFloor(options.highWaterMark);\n  }\n\n  validateInteger(concurrency\x2C 'options.concurrency'\x2C 1);\n  validateInteger(highWaterMark\x2C 'options.highWaterMark'\x2C 0);\n\n  highWaterMark += concurrency;\n\n  return async function* map() {\n    const signal = AbortSignal.any([options?.signal].filter(Boolean));\n    const stream = this;\n    const queue = [];\n    const signalOpt = { signal };\n\n    let next;\n    let resume;\n    let done = false;\n    let cnt = 0;\n\n    function onCatch() {\n      done = true;\n      afterItemProcessed();\n    }\n\n    function afterItemProcessed() {\n      cnt -= 1;\n      maybeResume();\n    }\n\n    function maybeResume() {\n      if (\n        resume &&\n        !done &&\n        cnt < concurrency &&\n        queue.length < highWaterMark\n      ) {\n        resume();\n        resume = null;\n      }\n    }\n\n    async function pump() {\n      try {\n        for await (let val of stream) {\n          if (done) {\n            return;\n          }\n\n          if (signal.aborted) {\n            throw new AbortError();\n          }\n\n          try {\n            val = fn(val\x2C signalOpt);\n\n            if (val === kEmpty) {\n              continue;\n            }\n\n            val = PromiseResolve(val);\n          } catch (err) {\n            val = PromiseReject(err);\n          }\n\n          cnt += 1;\n\n          PromisePrototypeThen(val\x2C afterItemProcessed\x2C onCatch);\n\n          queue.push(val);\n          if (next) {\n            next();\n            next = null;\n          }\n\n          if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {\n            await new Promise((resolve) => {\n              resume = resolve;\n            });\n          }\n        }\n        queue.push(kEof);\n      } catch (err) {\n        const val = PromiseReject(err);\n        PromisePrototypeThen(val\x2C afterItemProcessed\x2C onCatch);\n        queue.push(val);\n      } finally {\n        done = true;\n        if (next) {\n          next();\n          next = null;\n        }\n      }\n    }\n\n    pump();\n\n    try {\n      while (true) {\n        while (queue.length > 0) {\n          const val = await queue[0];\n\n          if (val === kEof) {\n            return;\n          }\n\n          if (signal.aborted) {\n            throw new AbortError();\n          }\n\n          if (val !== kEmpty) {\n            yield val;\n          }\n\n          queue.shift();\n          maybeResume();\n        }\n\n        await new Promise((resolve) => {\n          next = resolve;\n        });\n      }\n    } finally {\n      done = true;\n      if (resume) {\n        resume();\n        resume = null;\n      }\n    }\n  }.call(this);\n}\n\nfunction asIndexedPairs(options = undefined) {\n  if (options != null) {\n    validateObject(options\x2C 'options');\n  }\n  if (options?.signal != null) {\n    validateAbortSignal(options.signal\x2C 'options.signal');\n  }\n\n  return async function* asIndexedPairs() {\n    let index = 0;\n    for await (const val of this) {\n      if (options?.signal?.aborted) {\n        throw new AbortError({ cause: options.signal.reason });\n      }\n      yield [index++\x2C val];\n    }\n  }.call(this);\n}\n\nasync function some(fn\x2C options = undefined) {\n  for await (const unused of filter.call(this\x2C fn\x2C options)) {\n    return true;\n  }\n  return false;\n}\n\nasync function every(fn\x2C options = undefined) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE(\n      'fn'\x2C ['Function'\x2C 'AsyncFunction']\x2C fn);\n  }\n  // https://en.wikipedia.org/wiki/De_Morgan%27s_laws\n  return !(await some.call(this\x2C async (...args) => {\n    return !(await fn(...args));\n  }\x2C options));\n}\n\nasync function find(fn\x2C options) {\n  for await (const result of filter.call(this\x2C fn\x2C options)) {\n    return result;\n  }\n  return undefined;\n}\n\nasync function forEach(fn\x2C options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE(\n      'fn'\x2C ['Function'\x2C 'AsyncFunction']\x2C fn);\n  }\n  async function forEachFn(value\x2C options) {\n    await fn(value\x2C options);\n    return kEmpty;\n  }\n  // eslint-disable-next-line no-unused-vars\n  for await (const unused of map.call(this\x2C forEachFn\x2C options));\n}\n\nfunction filter(fn\x2C options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE(\n      'fn'\x2C ['Function'\x2C 'AsyncFunction']\x2C fn);\n  }\n  async function filterFn(value\x2C options) {\n    if (await fn(value\x2C options)) {\n      return value;\n    }\n    return kEmpty;\n  }\n  return map.call(this\x2C filterFn\x2C options);\n}\n\n// Specific to provide better error to reduce since the argument is only\n// missing if the stream has no items in it - but the code is still appropriate\nclass ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {\n  constructor() {\n    super('reduce');\n    this.message = 'Reduce of an empty stream requires an initial value';\n  }\n}\n\nasync function reduce(reducer\x2C initialValue\x2C options) {\n  if (typeof reducer !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE(\n      'reducer'\x2C ['Function'\x2C 'AsyncFunction']\x2C reducer);\n  }\n  if (options != null) {\n    validateObject(options\x2C 'options');\n  }\n  if (options?.signal != null) {\n    validateAbortSignal(options.signal\x2C 'options.signal');\n  }\n\n  let hasInitialValue = arguments.length > 1;\n  if (options?.signal?.aborted) {\n    const err = new AbortError(undefined\x2C { cause: options.signal.reason });\n    this.once('error'\x2C () => {}); // The error is already propagated\n    await finished(this.destroy(err));\n    throw err;\n  }\n  const ac = new AbortController();\n  const signal = ac.signal;\n  if (options?.signal) {\n    const opts = { once: true\x2C [kWeakHandler]: this\x2C [kResistStopPropagation]: true };\n    options.signal.addEventListener('abort'\x2C () => ac.abort()\x2C opts);\n  }\n  let gotAnyItemFromStream = false;\n  try {\n    for await (const value of this) {\n      gotAnyItemFromStream = true;\n      if (options?.signal?.aborted) {\n        throw new AbortError();\n      }\n      if (!hasInitialValue) {\n        initialValue = value;\n        hasInitialValue = true;\n      } else {\n        initialValue = await reducer(initialValue\x2C value\x2C { signal });\n      }\n    }\n    if (!gotAnyItemFromStream && !hasInitialValue) {\n      throw new ReduceAwareErrMissingArgs();\n    }\n  } finally {\n    ac.abort();\n  }\n  return initialValue;\n}\n\nasync function toArray(options) {\n  if (options != null) {\n    validateObject(options\x2C 'options');\n  }\n  if (options?.signal != null) {\n    validateAbortSignal(options.signal\x2C 'options.signal');\n  }\n\n  const result = [];\n  for await (const val of this) {\n    if (options?.signal?.aborted) {\n      throw new AbortError(undefined\x2C { cause: options.signal.reason });\n    }\n    ArrayPrototypePush(result\x2C val);\n  }\n  return result;\n}\n\nfunction flatMap(fn\x2C options) {\n  const values = map.call(this\x2C fn\x2C options);\n  return async function* flatMap() {\n    for await (const val of values) {\n      yield* val;\n    }\n  }.call(this);\n}\n\nfunction toIntegerOrInfinity(number) {\n  // We coerce here to align with the spec\n  // https://github.com/tc39/proposal-iterator-helpers/issues/169\n  number = Number(number);\n  if (NumberIsNaN(number)) {\n    return 0;\n  }\n  if (number < 0) {\n    throw new ERR_OUT_OF_RANGE('number'\x2C '>= 0'\x2C number);\n  }\n  return number;\n}\n\nfunction drop(number\x2C options = undefined) {\n  if (options != null) {\n    validateObject(options\x2C 'options');\n  }\n  if (options?.signal != null) {\n    validateAbortSignal(options.signal\x2C 'options.signal');\n  }\n\n  number = toIntegerOrInfinity(number);\n  return async function* drop() {\n    if (options?.signal?.aborted) {\n      throw new AbortError();\n    }\n    for await (const val of this) {\n      if (options?.signal?.aborted) {\n        throw new AbortError();\n      }\n      if (number-- <= 0) {\n        yield val;\n      }\n    }\n  }.call(this);\n}\n\nfunction take(number\x2C options = undefined) {\n  if (options != null) {\n    validateObject(options\x2C 'options');\n  }\n  if (options?.signal != null) {\n    validateAbortSignal(options.signal\x2C 'options.signal');\n  }\n\n  number = toIntegerOrInfinity(number);\n  return async function* take() {\n    if (options?.signal?.aborted) {\n      throw new AbortError();\n    }\n    for await (const val of this) {\n      if (options?.signal?.aborted) {\n        throw new AbortError();\n      }\n      if (number-- > 0) {\n        yield val;\n      }\n\n      // Don't get another item from iterator in case we reached the end\n      if (number <= 0) {\n        return;\n      }\n    }\n  }.call(this);\n}\n\nmodule.exports.streamReturningOperators = {\n  asIndexedPairs: deprecate(asIndexedPairs\x2C 'readable.asIndexedPairs will be removed in a future version.')\x2C\n  drop\x2C\n  filter\x2C\n  flatMap\x2C\n  map\x2C\n  take\x2C\n  compose\x2C\n};\n\nmodule.exports.promiseReturningOperators = {\n  every\x2C\n  forEach\x2C\n  reduce\x2C\n  toArray\x2C\n  some\x2C\n  find\x2C\n};\n
code-source-info,0x31e6f25e3716,93,0,10772,C0O0C4O10772,,
code-creation,JS,10,92631,0x31e6f25e4226,560, node:internal/streams/operators:1:1,0x31e6f25e3690,~
code-source-info,0x31e6f25e4226,93,0,10772,C0O0C163O56C166O56C171O23C177O40C183O234C186O234C191O112C196O118C202O145C208O171C213O193C219O218C225O334C228O334C233O272C239O295C245O314C251O415C254O415C259O374C265O388C271O470C274O470C279O457C285O535C288O535C292O535C294O612C297O612C302O582C308O695C311O695C316O666C322O678C328O752C331O752C336O738C341O789C347O811C353O822C359O835C365O845C371O860C377O871C383O888C389O906C395O930C400O971C403O971C407O971C409O1002C412O1002C416O1002C418O6699C439O6659C441O10462C455O10517C466O10610C472O10618C478O10628C484O10639C490O10646C496O10654C502O10495C506O10674C518O10714C524O10723C530O10734C536O10744C542O10755C548O10763C554O10708C559O10771,,
tick,0x10c1658ea,92682,1,0x10c1e6120,3,0x10c41e000,0x112583f26,0x112583ca1,0x31e6f25e22c3,0x112583feb,0x112583ca1,0x31e6f25df4ab,0x112583feb,0x112583ca1,0x31e6f25da395,0x112583feb,0x112583ca1,0x31e6f25d7289,0x112583feb,0x31e6f25d6c7a,0x31e6f25d6880,0x31e6f6b607cb,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f25d543c,0x31e6f6b7a501,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,Eval,10,93005,0x31e6f25e6156,5, node:internal/abort_controller:1:1,0x31e6f25e5c00,~
script-source,94,node:internal/abort_controller,'use strict';\n\n// Modeled very closely on the AbortController implementation\n// in https://github.com/mysticatea/abort-controller (MIT license)\n\nconst {\n  ObjectAssign\x2C\n  ObjectDefineProperties\x2C\n  ObjectSetPrototypeOf\x2C\n  ObjectDefineProperty\x2C\n  PromiseResolve\x2C\n  SafeFinalizationRegistry\x2C\n  SafeSet\x2C\n  Symbol\x2C\n  SymbolToStringTag\x2C\n  WeakRef\x2C\n} = primordials;\n\nconst {\n  defineEventHandler\x2C\n  EventTarget\x2C\n  Event\x2C\n  kTrustEvent\x2C\n  kNewListener\x2C\n  kRemoveListener\x2C\n  kResistStopPropagation\x2C\n  kWeakHandler\x2C\n} = require('internal/event_target');\nconst {\n  createDeferredPromise\x2C\n  customInspectSymbol\x2C\n  kEmptyObject\x2C\n  kEnumerableProperty\x2C\n} = require('internal/util');\nconst { inspect } = require('internal/util/inspect');\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_THIS\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  validateAbortSignal\x2C\n  validateAbortSignalArray\x2C\n  validateObject\x2C\n  validateUint32\x2C\n  kValidateObjectAllowArray\x2C\n  kValidateObjectAllowFunction\x2C\n} = require('internal/validators');\n\nconst {\n  DOMException\x2C\n} = internalBinding('messaging');\n\nconst {\n  clearTimeout\x2C\n  setTimeout\x2C\n} = require('timers');\nconst assert = require('internal/assert');\n\nconst {\n  messaging_deserialize_symbol: kDeserialize\x2C\n  messaging_transfer_symbol: kTransfer\x2C\n  messaging_transfer_list_symbol: kTransferList\x2C\n} = internalBinding('symbols');\n\nlet _MessageChannel;\nlet makeTransferable;\n\n// Loading the MessageChannel and makeTransferable have to be done lazily\n// because otherwise we'll end up with a require cycle that ends up with\n// an incomplete initialization of abort_controller.\n\nfunction lazyMessageChannel() {\n  _MessageChannel ??= require('internal/worker/io').MessageChannel;\n  return new _MessageChannel();\n}\n\nfunction lazyMakeTransferable(obj) {\n  makeTransferable ??=\n    require('internal/worker/js_transferable').makeTransferable;\n  return makeTransferable(obj);\n}\n\nconst clearTimeoutRegistry = new SafeFinalizationRegistry(clearTimeout);\nconst gcPersistentSignals = new SafeSet();\n\nconst kAborted = Symbol('kAborted');\nconst kReason = Symbol('kReason');\nconst kCloneData = Symbol('kCloneData');\nconst kTimeout = Symbol('kTimeout');\nconst kMakeTransferable = Symbol('kMakeTransferable');\nconst kComposite = Symbol('kComposite');\nconst kSourceSignals = Symbol('kSourceSignals');\nconst kDependantSignals = Symbol('kDependantSignals');\n\nfunction customInspect(self\x2C obj\x2C depth\x2C options) {\n  if (depth < 0)\n    return self;\n\n  const opts = ObjectAssign({}\x2C options\x2C {\n    depth: options.depth === null ? null : options.depth - 1\x2C\n  });\n\n  return `${self.constructor.name} ${inspect(obj\x2C opts)}`;\n}\n\nfunction validateThisAbortSignal(obj) {\n  if (obj?.[kAborted] === undefined)\n    throw new ERR_INVALID_THIS('AbortSignal');\n}\n\n// Because the AbortSignal timeout cannot be canceled\x2C we don't want the\n// presence of the timer alone to keep the AbortSignal from being garbage\n// collected if it otherwise no longer accessible. We also don't want the\n// timer to keep the Node.js process open on it's own. Therefore\x2C we wrap\n// the AbortSignal in a WeakRef and have the setTimeout callback close\n// over the WeakRef rather than directly over the AbortSignal\x2C and we unref\n// the created timer object. Separately\x2C we add the signal to a\n// FinalizerRegistry that will clear the timeout when the signal is gc'd.\nfunction setWeakAbortSignalTimeout(weakRef\x2C delay) {\n  const timeout = setTimeout(() => {\n    const signal = weakRef.deref();\n    if (signal !== undefined) {\n      gcPersistentSignals.delete(signal);\n      abortSignal(\n        signal\x2C\n        new DOMException(\n          'The operation was aborted due to timeout'\x2C\n          'TimeoutError'));\n    }\n  }\x2C delay);\n  timeout.unref();\n  return timeout;\n}\n\nclass AbortSignal extends EventTarget {\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get aborted() {\n    validateThisAbortSignal(this);\n    return !!this[kAborted];\n  }\n\n  /**\n   * @type {any}\n   */\n  get reason() {\n    validateThisAbortSignal(this);\n    return this[kReason];\n  }\n\n  throwIfAborted() {\n    validateThisAbortSignal(this);\n    if (this[kAborted]) {\n      throw this[kReason];\n    }\n  }\n\n  [customInspectSymbol](depth\x2C options) {\n    return customInspect(this\x2C {\n      aborted: this.aborted\x2C\n    }\x2C depth\x2C options);\n  }\n\n  /**\n   * @param {any} [reason]\n   * @returns {AbortSignal}\n   */\n  static abort(\n    reason = new DOMException('This operation was aborted'\x2C 'AbortError')) {\n    return createAbortSignal({ aborted: true\x2C reason });\n  }\n\n  /**\n   * @param {number} delay\n   * @returns {AbortSignal}\n   */\n  static timeout(delay) {\n    validateUint32(delay\x2C 'delay'\x2C false);\n    const signal = createAbortSignal();\n    signal[kTimeout] = true;\n    clearTimeoutRegistry.register(\n      signal\x2C\n      setWeakAbortSignalTimeout(new WeakRef(signal)\x2C delay));\n    return signal;\n  }\n\n  /**\n   * @param {AbortSignal[]} signals\n   * @returns {AbortSignal}\n   */\n  static any(signals) {\n    validateAbortSignalArray(signals\x2C 'signals');\n    const resultSignal = createAbortSignal({ composite: true });\n    if (!signals.length) {\n      return resultSignal;\n    }\n    const resultSignalWeakRef = new WeakRef(resultSignal);\n    resultSignal[kSourceSignals] = new SafeSet();\n    for (let i = 0; i < signals.length; i++) {\n      const signal = signals[i];\n      if (signal.aborted) {\n        abortSignal(resultSignal\x2C signal.reason);\n        return resultSignal;\n      }\n      signal[kDependantSignals] ??= new SafeSet();\n      if (!signal[kComposite]) {\n        resultSignal[kSourceSignals].add(new WeakRef(signal));\n        signal[kDependantSignals].add(resultSignalWeakRef);\n      } else if (!signal[kSourceSignals]) {\n        continue;\n      } else {\n        for (const sourceSignal of signal[kSourceSignals]) {\n          const sourceSignalRef = sourceSignal.deref();\n          if (!sourceSignalRef) {\n            continue;\n          }\n          assert(!sourceSignalRef.aborted);\n          assert(!sourceSignalRef[kComposite]);\n\n          if (resultSignal[kSourceSignals].has(sourceSignal)) {\n            continue;\n          }\n          resultSignal[kSourceSignals].add(sourceSignal);\n          sourceSignalRef[kDependantSignals].add(resultSignalWeakRef);\n        }\n      }\n    }\n    return resultSignal;\n  }\n\n  [kNewListener](size\x2C type\x2C listener\x2C once\x2C capture\x2C passive\x2C weak) {\n    super[kNewListener](size\x2C type\x2C listener\x2C once\x2C capture\x2C passive\x2C weak);\n    const isTimeoutOrNonEmptyCompositeSignal = this[kTimeout] || (this[kComposite] && this[kSourceSignals]?.size);\n    if (isTimeoutOrNonEmptyCompositeSignal &&\n        type === 'abort' &&\n        !this.aborted &&\n        !weak &&\n        size === 1) {\n      // If this is a timeout signal\x2C or a non-empty composite signal\x2C and we're adding a non-weak abort\n      // listener\x2C then we don't want it to be gc'd while the listener\n      // is attached and the timer still hasn't fired. So\x2C we retain a\n      // strong ref that is held for as long as the listener is registered.\n      gcPersistentSignals.add(this);\n    }\n  }\n\n  [kRemoveListener](size\x2C type\x2C listener\x2C capture) {\n    super[kRemoveListener](size\x2C type\x2C listener\x2C capture);\n    const isTimeoutOrNonEmptyCompositeSignal = this[kTimeout] || (this[kComposite] && this[kSourceSignals]?.size);\n    if (isTimeoutOrNonEmptyCompositeSignal && type === 'abort' && size === 0) {\n      gcPersistentSignals.delete(this);\n    }\n  }\n\n  [kTransfer]() {\n    validateThisAbortSignal(this);\n    const aborted = this.aborted;\n    if (aborted) {\n      const reason = this.reason;\n      return {\n        data: { aborted\x2C reason }\x2C\n        deserializeInfo: 'internal/abort_controller:ClonedAbortSignal'\x2C\n      };\n    }\n\n    const { port1\x2C port2 } = this[kCloneData];\n    this[kCloneData] = undefined;\n\n    this.addEventListener('abort'\x2C () => {\n      port1.postMessage(this.reason);\n      port1.close();\n    }\x2C { once: true });\n\n    return {\n      data: { port: port2 }\x2C\n      deserializeInfo: 'internal/abort_controller:ClonedAbortSignal'\x2C\n    };\n  }\n\n  [kTransferList]() {\n    if (!this.aborted) {\n      const { port1\x2C port2 } = lazyMessageChannel();\n      port1.unref();\n      port2.unref();\n      this[kCloneData] = {\n        port1\x2C\n        port2\x2C\n      };\n      return [port2];\n    }\n    return [];\n  }\n\n  [kDeserialize]({ aborted\x2C reason\x2C port }) {\n    if (aborted) {\n      this[kAborted] = aborted;\n      this[kReason] = reason;\n      return;\n    }\n\n    port.onmessage = ({ data }) => {\n      abortSignal(this\x2C data);\n      port.close();\n      port.onmessage = undefined;\n    };\n    // The receiving port\x2C by itself\x2C should never keep the event loop open.\n    // The unref() has to be called *after* setting the onmessage handler.\n    port.unref();\n  }\n}\n\nfunction ClonedAbortSignal() {\n  return createAbortSignal({ transferable: true });\n}\nClonedAbortSignal.prototype[kDeserialize] = () => {};\n\nObjectDefineProperties(AbortSignal.prototype\x2C {\n  aborted: kEnumerableProperty\x2C\n});\n\nObjectDefineProperty(AbortSignal.prototype\x2C SymbolToStringTag\x2C {\n  __proto__: null\x2C\n  writable: false\x2C\n  enumerable: false\x2C\n  configurable: true\x2C\n  value: 'AbortSignal'\x2C\n});\n\ndefineEventHandler(AbortSignal.prototype\x2C 'abort');\n\n/**\n * @param {{\n *   aborted? : boolean\x2C\n *   reason? : any\x2C\n *   transferable? : boolean\x2C\n *   composite? : boolean\x2C\n * }} [init]\n * @returns {AbortSignal}\n */\nfunction createAbortSignal(init = kEmptyObject) {\n  const {\n    aborted = false\x2C\n    reason = undefined\x2C\n    transferable = false\x2C\n    composite = false\x2C\n  } = init;\n  const signal = new EventTarget();\n  ObjectSetPrototypeOf(signal\x2C AbortSignal.prototype);\n  signal[kAborted] = aborted;\n  signal[kReason] = reason;\n  signal[kComposite] = composite;\n  return transferable ? lazyMakeTransferable(signal) : signal;\n}\n\nfunction abortSignal(signal\x2C reason) {\n  if (signal[kAborted]) return;\n  signal[kAborted] = true;\n  signal[kReason] = reason;\n  const event = new Event('abort'\x2C {\n    [kTrustEvent]: true\x2C\n  });\n  signal.dispatchEvent(event);\n  signal[kDependantSignals]?.forEach((s) => {\n    const signalRef = s.deref();\n    if (signalRef) abortSignal(signalRef\x2C reason);\n  });\n}\n\nclass AbortController {\n  #signal;\n\n  /**\n   * @type {AbortSignal}\n   */\n  get signal() {\n    this.#signal ??= createAbortSignal();\n    return this.#signal;\n  }\n\n  /**\n   * @param {any} [reason]\n   */\n  abort(reason = new DOMException('This operation was aborted'\x2C 'AbortError')) {\n    abortSignal(this.#signal ??= createAbortSignal()\x2C reason);\n  }\n\n  [customInspectSymbol](depth\x2C options) {\n    return customInspect(this\x2C {\n      signal: this.signal\x2C\n    }\x2C depth\x2C options);\n  }\n\n  static [kMakeTransferable]() {\n    const controller = new AbortController();\n    controller.#signal = createAbortSignal({ transferable: true });\n    return controller;\n  }\n}\n\n/**\n * Enables the AbortSignal to be transferable using structuredClone/postMessage.\n * @param {AbortSignal} signal\n * @returns {AbortSignal}\n */\nfunction transferableAbortSignal(signal) {\n  if (signal?.[kAborted] === undefined)\n    throw new ERR_INVALID_ARG_TYPE('signal'\x2C 'AbortSignal'\x2C signal);\n  return lazyMakeTransferable(signal);\n}\n\n/**\n * Creates an AbortController with a transferable AbortSignal\n */\nfunction transferableAbortController() {\n  return AbortController[kMakeTransferable]();\n}\n\n/**\n * @param {AbortSignal} signal\n * @param {any} resource\n * @returns {Promise<void>}\n */\nasync function aborted(signal\x2C resource) {\n  if (signal === undefined) {\n    throw new ERR_INVALID_ARG_TYPE('signal'\x2C 'AbortSignal'\x2C signal);\n  }\n  validateAbortSignal(signal\x2C 'signal');\n  validateObject(resource\x2C 'resource'\x2C kValidateObjectAllowArray | kValidateObjectAllowFunction);\n  if (signal.aborted)\n    return PromiseResolve();\n  const abortPromise = createDeferredPromise();\n  const opts = { __proto__: null\x2C [kWeakHandler]: resource\x2C once: true\x2C [kResistStopPropagation]: true };\n  signal.addEventListener('abort'\x2C abortPromise.resolve\x2C opts);\n  return abortPromise.promise;\n}\n\nObjectDefineProperties(AbortController.prototype\x2C {\n  signal: kEnumerableProperty\x2C\n  abort: kEnumerableProperty\x2C\n});\n\nObjectDefineProperty(AbortController.prototype\x2C SymbolToStringTag\x2C {\n  __proto__: null\x2C\n  writable: false\x2C\n  enumerable: false\x2C\n  configurable: true\x2C\n  value: 'AbortController'\x2C\n});\n\nmodule.exports = {\n  AbortController\x2C\n  AbortSignal\x2C\n  ClonedAbortSignal\x2C\n  aborted\x2C\n  transferableAbortSignal\x2C\n  transferableAbortController\x2C\n};\n
code-source-info,0x31e6f25e6156,94,0,12472,C0O0C4O12472,,
code-creation,JS,10,93730,0x31e6f25e7aae,1076, node:internal/abort_controller:1:1,0x31e6f25e60d0,~
code-source-info,0x31e6f25e7aae,94,0,12472,C0O0C194O155C200O171C205O197C211O221C216O245C222O263C227O291C233O302C238O312C243O333C249O510C257O510C263O370C268O392C274O407C280O416C286O431C292O447C298O466C304O492C310O643C318O643C324O554C330O579C335O602C341O618C346O689C354O689C360O677C366O828C374O828C380O740C386O746C392O775C398O801C404O1017C412O1017C418O867C424O890C430O918C436O936C442O954C448O983C454O1078C458O1078C464O1060C470O1151C478O1151C484O1119C489O1135C495O1185C503O1185C507O1185C509O1361C513O1361C519O1254C524O1297C529O1342C534O1394C535O1394C537O1415C538O1415C540O1959C542O1959C547O1959C549O2031C553O2031C558O2031C560O2064C564O2064C568O2064C570O2100C574O2100C578O2100C580O2138C584O2138C588O2138C590O2177C594O2177C598O2177C600O2223C604O2223C608O2223C610O2271C614O2271C618O2271C620O2316C624O2316C628O2316C630O2368C634O2368C638O2368C650O3794C676O4227C706O6344C718O7116C728O7474C738O8085C748O8341C776O3768C778O8895C784O8905C788O8919C792O8932C796O8967C810O8991C814O8932C819O9017C823O9050C829O9061C838O9017C843O9192C847O9223C857O9192C907O10539C919O10677C967O10186C969O12025C973O12064C987O12087C993O12117C997O12025C1002O12143C1006O12180C1012O12191C1021O12143C1026O12326C1034O12347C1040O12366C1046O12381C1052O12402C1058O12413C1064O12440C1070O12341C1075O12471,,
code-creation,JS,10,93801,0x31e6f25e80fe,11,<instance_members_initializer> node:internal/abort_controller:378:1,0x31e6f25e6b88,~
code-source-info,0x31e6f25e80fe,94,10186,10842,C4O10212C10O10842,,
tick,0x7ff809303ab9,93822,1,0x10c1e6120,3,0x10c41e000,0x112583f26,0x112583ca1,0x31e6f25e42cc,0x112583feb,0x112583ca1,0x31e6f25e22c3,0x112583feb,0x112583ca1,0x31e6f25df4ab,0x112583feb,0x112583ca1,0x31e6f25da395,0x112583feb,0x112583ca1,0x31e6f25d7289,0x112583feb,0x31e6f25d6c7a,0x31e6f25d6880,0x31e6f6b607cb,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f25d543c,0x31e6f6b7a501,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,93912,0x31e6f25e949e,43,SafeFinalizationRegistry node:internal/per_context/primordials:440:16,0x31e6931b5018,~
code-source-info,0x31e6f25e949e,6,12756,12801,C3O12776C27O12776C42O12800,,
code-creation,JS,10,94063,0x31e6f25e9ae6,155,defineEventHandler node:internal/event_target:1116:28,0x31e647c66fb8,~
script-source,47,node:internal/event_target,'use strict';\n\nconst {\n  ArrayFrom\x2C\n  ArrayPrototypeReduce\x2C\n  Boolean\x2C\n  Error\x2C\n  FunctionPrototypeCall\x2C\n  NumberIsInteger\x2C\n  ObjectAssign\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyDescriptors\x2C\n  ObjectSetPrototypeOf\x2C\n  ObjectValues\x2C\n  ReflectApply\x2C\n  SafeArrayIterator\x2C\n  SafeFinalizationRegistry\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  SafeWeakRef\x2C\n  SafeWeakSet\x2C\n  String\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  SymbolToStringTag\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_EVENT_RECURSION\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_INVALID_THIS\x2C\n  }\x2C\n} = require('internal/errors');\nconst {\n  validateAbortSignal\x2C\n  validateObject\x2C\n  validateString\x2C\n  validateInternalField\x2C\n  kValidateObjectAllowArray\x2C\n  kValidateObjectAllowFunction\x2C\n} = require('internal/validators');\n\nconst {\n  customInspectSymbol\x2C\n  kEmptyObject\x2C\n  kEnumerableProperty\x2C\n} = require('internal/util');\nconst { inspect } = require('util');\nconst webidl = require('internal/webidl');\n\nconst kIsEventTarget = SymbolFor('nodejs.event_target');\nconst kIsNodeEventTarget = Symbol('kIsNodeEventTarget');\n\nconst EventEmitter = require('events');\nconst {\n  kMaxEventTargetListeners\x2C\n  kMaxEventTargetListenersWarned\x2C\n} = EventEmitter;\n\nconst kEvents = Symbol('kEvents');\nconst kIsBeingDispatched = Symbol('kIsBeingDispatched');\nconst kStop = Symbol('kStop');\nconst kTarget = Symbol('kTarget');\nconst kHandlers = Symbol('kHandlers');\nconst kWeakHandler = Symbol('kWeak');\nconst kResistStopPropagation = Symbol('kResistStopPropagation');\n\nconst kHybridDispatch = SymbolFor('nodejs.internal.kHybridDispatch');\nconst kRemoveWeakListenerHelper = Symbol('nodejs.internal.removeWeakListenerHelper');\nconst kCreateEvent = Symbol('kCreateEvent');\nconst kNewListener = Symbol('kNewListener');\nconst kRemoveListener = Symbol('kRemoveListener');\nconst kIsNodeStyleListener = Symbol('kIsNodeStyleListener');\nconst kTrustEvent = Symbol('kTrustEvent');\n\nconst { now } = require('internal/perf/utils');\n\nconst kType = Symbol('type');\nconst kDetail = Symbol('detail');\n\nconst isTrustedSet = new SafeWeakSet();\nconst isTrusted = ObjectGetOwnPropertyDescriptor({\n  get isTrusted() {\n    return isTrustedSet.has(this);\n  }\x2C\n}\x2C 'isTrusted').get;\n\nconst isTrustedDescriptor = {\n  __proto__: null\x2C\n  configurable: false\x2C\n  enumerable: true\x2C\n  get: isTrusted\x2C\n};\n\nfunction isEvent(value) {\n  return typeof value?.[kType] === 'string';\n}\n\nclass Event {\n  #cancelable = false;\n  #bubbles = false;\n  #composed = false;\n  #defaultPrevented = false;\n  #timestamp = now();\n  #propagationStopped = false;\n\n  /**\n   * @param {string} type\n   * @param {{\n   *   bubbles?: boolean\x2C\n   *   cancelable?: boolean\x2C\n   *   composed?: boolean\x2C\n   * }} [options]\n   */\n  constructor(type\x2C options = kEmptyObject) {\n    if (arguments.length === 0)\n      throw new ERR_MISSING_ARGS('type');\n    validateObject(options\x2C 'options');\n    const { bubbles\x2C cancelable\x2C composed } = options;\n    this.#cancelable = !!cancelable;\n    this.#bubbles = !!bubbles;\n    this.#composed = !!composed;\n\n    this[kType] = `${type}`;\n    if (options?.[kTrustEvent]) {\n      isTrustedSet.add(this);\n    }\n\n    this[kTarget] = null;\n    this[kIsBeingDispatched] = false;\n  }\n\n  /**\n   * @param {string} type\n   * @param {boolean} [bubbles]\n   * @param {boolean} [cancelable]\n   */\n  initEvent(type\x2C bubbles = false\x2C cancelable = false) {\n    if (arguments.length === 0)\n      throw new ERR_MISSING_ARGS('type');\n\n    if (this[kIsBeingDispatched]) {\n      return;\n    }\n    this[kType] = `${type}`;\n    this.#bubbles = !!bubbles;\n    this.#cancelable = !!cancelable;\n  }\n\n  [customInspectSymbol](depth\x2C options) {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    const name = this.constructor.name;\n    if (depth < 0)\n      return name;\n\n    const opts = ObjectAssign({}\x2C options\x2C {\n      depth: NumberIsInteger(options.depth) ? options.depth - 1 : options.depth\x2C\n    });\n\n    return `${name} ${inspect({\n      type: this[kType]\x2C\n      defaultPrevented: this.#defaultPrevented\x2C\n      cancelable: this.#cancelable\x2C\n      timeStamp: this.#timestamp\x2C\n    }\x2C opts)}`;\n  }\n\n  stopImmediatePropagation() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this[kStop] = true;\n  }\n\n  preventDefault() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this.#defaultPrevented = true;\n  }\n\n  /**\n   * @type {EventTarget}\n   */\n  get target() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  /**\n   * @type {EventTarget}\n   */\n  get currentTarget() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  /**\n   * @type {EventTarget}\n   */\n  get srcElement() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  /**\n   * @type {string}\n   */\n  get type() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kType];\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get cancelable() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this.#cancelable;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get defaultPrevented() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this.#cancelable && this.#defaultPrevented;\n  }\n\n  /**\n   * @type {number}\n   */\n  get timeStamp() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this.#timestamp;\n  }\n\n\n  // The following are non-op and unused properties/methods from Web API Event.\n  // These are not supported in Node.js and are provided purely for\n  // API completeness.\n  /**\n   * @returns {EventTarget[]}\n   */\n  composedPath() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kIsBeingDispatched] ? [this[kTarget]] : [];\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get returnValue() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return !this.#cancelable || !this.#defaultPrevented;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get bubbles() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this.#bubbles;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get composed() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this.#composed;\n  }\n\n  /**\n   * @type {number}\n   */\n  get eventPhase() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kIsBeingDispatched] ? Event.AT_TARGET : Event.NONE;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get cancelBubble() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this.#propagationStopped;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  set cancelBubble(value) {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    if (value) {\n      this.stopPropagation();\n    }\n  }\n\n  stopPropagation() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this.#propagationStopped = true;\n  }\n}\n\nObjectDefineProperties(\n  Event.prototype\x2C {\n    [SymbolToStringTag]: {\n      __proto__: null\x2C\n      writable: false\x2C\n      enumerable: false\x2C\n      configurable: true\x2C\n      value: 'Event'\x2C\n    }\x2C\n    initEvent: kEnumerableProperty\x2C\n    stopImmediatePropagation: kEnumerableProperty\x2C\n    preventDefault: kEnumerableProperty\x2C\n    target: kEnumerableProperty\x2C\n    currentTarget: kEnumerableProperty\x2C\n    srcElement: kEnumerableProperty\x2C\n    type: kEnumerableProperty\x2C\n    cancelable: kEnumerableProperty\x2C\n    defaultPrevented: kEnumerableProperty\x2C\n    timeStamp: kEnumerableProperty\x2C\n    composedPath: kEnumerableProperty\x2C\n    returnValue: kEnumerableProperty\x2C\n    bubbles: kEnumerableProperty\x2C\n    composed: kEnumerableProperty\x2C\n    eventPhase: kEnumerableProperty\x2C\n    cancelBubble: kEnumerableProperty\x2C\n    stopPropagation: kEnumerableProperty\x2C\n    // Don't conform to the spec with isTrusted. The spec defines it as\n    // LegacyUnforgeable but defining it in the constructor has a big\n    // performance impact and the property doesn't seem to be useful outside of\n    // browsers.\n    isTrusted: isTrustedDescriptor\x2C\n  });\n\nconst staticProps = ['NONE'\x2C 'CAPTURING_PHASE'\x2C 'AT_TARGET'\x2C 'BUBBLING_PHASE'];\n\nObjectDefineProperties(\n  Event\x2C\n  ArrayPrototypeReduce(staticProps\x2C (result\x2C staticProp\x2C index = 0) => {\n    result[staticProp] = {\n      __proto__: null\x2C\n      writable: false\x2C\n      configurable: false\x2C\n      enumerable: true\x2C\n      value: index\x2C\n    };\n    return result;\n  }\x2C {})\x2C\n);\n\nfunction isCustomEvent(value) {\n  return isEvent(value) && (value?.[kDetail] !== undefined);\n}\n\nclass CustomEvent extends Event {\n  /**\n   * @constructor\n   * @param {string} type\n   * @param {{\n   *   bubbles?: boolean\x2C\n   *   cancelable?: boolean\x2C\n   *   composed?: boolean\x2C\n   *   detail?: any\x2C\n   * }} [options]\n   */\n  constructor(type\x2C options = kEmptyObject) {\n    if (arguments.length === 0)\n      throw new ERR_MISSING_ARGS('type');\n    super(type\x2C options);\n    this[kDetail] = options?.detail ?? null;\n  }\n\n  /**\n   * @type {any}\n   */\n  get detail() {\n    if (!isCustomEvent(this))\n      throw new ERR_INVALID_THIS('CustomEvent');\n    return this[kDetail];\n  }\n}\n\nObjectDefineProperties(CustomEvent.prototype\x2C {\n  [SymbolToStringTag]: {\n    __proto__: null\x2C\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: 'CustomEvent'\x2C\n  }\x2C\n  detail: kEnumerableProperty\x2C\n});\n\nclass NodeCustomEvent extends Event {\n  constructor(type\x2C options) {\n    super(type\x2C options);\n    if (options?.detail) {\n      this.detail = options.detail;\n    }\n  }\n}\n\n// Weak listener cleanup\n// This has to be lazy for snapshots to work\nlet weakListenersState = null;\n// The resource needs to retain the callback so that it doesn't\n// get garbage collected now that it's weak.\nlet objectToWeakListenerMap = null;\nfunction weakListeners() {\n  weakListenersState ??= new SafeFinalizationRegistry(\n    ({ eventTarget\x2C listener\x2C eventType }) => eventTarget.deref()?.[kRemoveWeakListenerHelper](eventType\x2C listener)\x2C\n  );\n  objectToWeakListenerMap ??= new SafeWeakMap();\n  return { registry: weakListenersState\x2C map: objectToWeakListenerMap };\n}\n\nconst kFlagOnce = 1 << 0;\nconst kFlagCapture = 1 << 1;\nconst kFlagPassive = 1 << 2;\nconst kFlagNodeStyle = 1 << 3;\nconst kFlagWeak = 1 << 4;\nconst kFlagRemoved = 1 << 5;\nconst kFlagResistStopPropagation = 1 << 6;\n\n// The listeners for an EventTarget are maintained as a linked list.\n// Unfortunately\x2C the way EventTarget is defined\x2C listeners are accounted\n// using the tuple [handler\x2Ccapture]\x2C and even if we don't actually make\n// use of capture or bubbling\x2C in order to be spec compliant we have to\n// take on the additional complexity of supporting it. Fortunately\x2C using\n// the linked list makes dispatching faster\x2C even if adding/removing is\n// slower.\nclass Listener {\n  constructor(eventTarget\x2C eventType\x2C previous\x2C listener\x2C once\x2C capture\x2C passive\x2C\n              isNodeStyleListener\x2C weak\x2C resistStopPropagation) {\n    this.next = undefined;\n    if (previous !== undefined)\n      previous.next = this;\n    this.previous = previous;\n    this.listener = listener;\n\n    let flags = 0b0;\n    if (once)\n      flags |= kFlagOnce;\n    if (capture)\n      flags |= kFlagCapture;\n    if (passive)\n      flags |= kFlagPassive;\n    if (isNodeStyleListener)\n      flags |= kFlagNodeStyle;\n    if (weak)\n      flags |= kFlagWeak;\n    if (resistStopPropagation)\n      flags |= kFlagResistStopPropagation;\n    this.flags = flags;\n\n    this.removed = false;\n\n    if (this.weak) {\n      this.callback = new SafeWeakRef(listener);\n      weakListeners().registry.register(listener\x2C {\n        __proto__: null\x2C\n        // Weak ref so the listener won't hold the eventTarget alive\n        eventTarget: new SafeWeakRef(eventTarget)\x2C\n        listener: this\x2C\n        eventType\x2C\n      }\x2C this);\n      // Make the retainer retain the listener in a WeakMap\n      weakListeners().map.set(weak\x2C listener);\n      this.listener = this.callback;\n    } else if (typeof listener === 'function') {\n      this.callback = listener;\n      this.listener = listener;\n    } else {\n      this.callback = async (...args) => {\n        if (listener.handleEvent)\n          await ReflectApply(listener.handleEvent\x2C listener\x2C args);\n      };\n      this.listener = listener;\n    }\n  }\n\n  get once() {\n    return Boolean(this.flags & kFlagOnce);\n  }\n  get capture() {\n    return Boolean(this.flags & kFlagCapture);\n  }\n  get passive() {\n    return Boolean(this.flags & kFlagPassive);\n  }\n  get isNodeStyleListener() {\n    return Boolean(this.flags & kFlagNodeStyle);\n  }\n  get weak() {\n    return Boolean(this.flags & kFlagWeak);\n  }\n  get resistStopPropagation() {\n    return Boolean(this.flags & kFlagResistStopPropagation);\n  }\n  get removed() {\n    return Boolean(this.flags & kFlagRemoved);\n  }\n  set removed(value) {\n    if (value)\n      this.flags |= kFlagRemoved;\n    else\n      this.flags &= ~kFlagRemoved;\n  }\n\n  same(listener\x2C capture) {\n    const myListener = this.weak ? this.listener.deref() : this.listener;\n    return myListener === listener && this.capture === capture;\n  }\n\n  remove() {\n    if (this.previous !== undefined)\n      this.previous.next = this.next;\n    if (this.next !== undefined)\n      this.next.previous = this.previous;\n    this.removed = true;\n    if (this.weak)\n      weakListeners().registry.unregister(this);\n  }\n}\n\nfunction initEventTarget(self) {\n  self[kEvents] = new SafeMap();\n  self[kMaxEventTargetListeners] = EventEmitter.defaultMaxListeners;\n  self[kMaxEventTargetListenersWarned] = false;\n  self[kHandlers] = new SafeMap();\n}\n\nclass EventTarget {\n  // Used in checking whether an object is an EventTarget. This is a well-known\n  // symbol as EventTarget may be used cross-realm.\n  // Ref: https://github.com/nodejs/node/pull/33661\n  static [kIsEventTarget] = true;\n\n  constructor() {\n    initEventTarget(this);\n  }\n\n  [kNewListener](size\x2C type\x2C listener\x2C once\x2C capture\x2C passive\x2C weak) {\n    if (this[kMaxEventTargetListeners] > 0 &&\n        size > this[kMaxEventTargetListeners] &&\n        !this[kMaxEventTargetListenersWarned]) {\n      this[kMaxEventTargetListenersWarned] = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error('Possible EventTarget memory leak detected. ' +\n                          `${size} ${type} listeners ` +\n                          `added to ${inspect(this\x2C { depth: -1 })}. Use ` +\n                          'events.setMaxListeners() to increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.target = this;\n      w.type = type;\n      w.count = size;\n      process.emitWarning(w);\n    }\n  }\n  [kRemoveListener](size\x2C type\x2C listener\x2C capture) {}\n\n  /**\n   * @callback EventTargetCallback\n   * @param {Event} event\n   */\n\n  /**\n   * @typedef {{ handleEvent: EventTargetCallback }} EventListener\n   */\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @param {{\n   *   capture?: boolean\x2C\n   *   once?: boolean\x2C\n   *   passive?: boolean\x2C\n   *   signal?: AbortSignal\n   * }} [options]\n   */\n  addEventListener(type\x2C listener\x2C options = kEmptyObject) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    if (arguments.length < 2)\n      throw new ERR_MISSING_ARGS('type'\x2C 'listener');\n\n    // We validateOptions before the validateListener check because the spec\n    // requires us to hit getters.\n    const {\n      once\x2C\n      capture\x2C\n      passive\x2C\n      signal\x2C\n      isNodeStyleListener\x2C\n      weak\x2C\n      resistStopPropagation\x2C\n    } = validateEventListenerOptions(options);\n\n    validateAbortSignal(signal\x2C 'options.signal');\n\n    if (!validateEventListener(listener)) {\n      // The DOM silently allows passing undefined as a second argument\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error(`addEventListener called with ${listener}` +\n                          ' which has no effect.');\n      w.name = 'AddEventListenerArgumentTypeWarning';\n      w.target = this;\n      w.type = type;\n      process.emitWarning(w);\n      return;\n    }\n    type = webidl.converters.DOMString(type);\n\n    if (signal) {\n      if (signal.aborted) {\n        return;\n      }\n      // TODO(benjamingr) make this weak somehow? ideally the signal would\n      // not prevent the event target from GC.\n      signal.addEventListener('abort'\x2C () => {\n        this.removeEventListener(type\x2C listener\x2C options);\n      }\x2C { __proto__: null\x2C once: true\x2C [kWeakHandler]: this\x2C [kResistStopPropagation]: true });\n    }\n\n    let root = this[kEvents].get(type);\n\n    if (root === undefined) {\n      root = { size: 1\x2C next: undefined\x2C resistStopPropagation: Boolean(resistStopPropagation) };\n      // This is the first handler in our linked list.\n      new Listener(this\x2C type\x2C root\x2C listener\x2C once\x2C capture\x2C passive\x2C\n                   isNodeStyleListener\x2C weak\x2C resistStopPropagation);\n      this[kNewListener](\n        root.size\x2C\n        type\x2C\n        listener\x2C\n        once\x2C\n        capture\x2C\n        passive\x2C\n        weak);\n      this[kEvents].set(type\x2C root);\n      return;\n    }\n\n    let handler = root.next;\n    let previous = root;\n\n    // We have to walk the linked list to see if we have a match\n    while (handler !== undefined && !handler.same(listener\x2C capture)) {\n      previous = handler;\n      handler = handler.next;\n    }\n\n    if (handler !== undefined) { // Duplicate! Ignore\n      return;\n    }\n\n    new Listener(this\x2C type\x2C previous\x2C listener\x2C once\x2C capture\x2C passive\x2C\n                 isNodeStyleListener\x2C weak\x2C resistStopPropagation);\n    root.size++;\n    root.resistStopPropagation ||= Boolean(resistStopPropagation);\n    this[kNewListener](root.size\x2C type\x2C listener\x2C once\x2C capture\x2C passive\x2C weak);\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @param {{\n   *   capture?: boolean\x2C\n   * }} [options]\n   */\n  removeEventListener(type\x2C listener\x2C options = kEmptyObject) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    if (arguments.length < 2)\n      throw new ERR_MISSING_ARGS('type'\x2C 'listener');\n    if (!validateEventListener(listener))\n      return;\n\n    type = webidl.converters.DOMString(type);\n    const capture = options?.capture === true;\n\n    const root = this[kEvents].get(type);\n    if (root === undefined || root.next === undefined)\n      return;\n\n    let handler = root.next;\n    while (handler !== undefined) {\n      if (handler.same(listener\x2C capture)) {\n        handler.remove();\n        root.size--;\n        if (root.size === 0)\n          this[kEvents].delete(type);\n        this[kRemoveListener](root.size\x2C type\x2C listener\x2C capture);\n        break;\n      }\n      handler = handler.next;\n    }\n  }\n\n  [kRemoveWeakListenerHelper](type\x2C listener) {\n    const root = this[kEvents].get(type);\n    if (root === undefined || root.next === undefined)\n      return;\n\n    const capture = listener.capture === true;\n\n    let handler = root.next;\n    while (handler !== undefined) {\n      if (handler === listener) {\n        handler.remove();\n        root.size--;\n        if (root.size === 0)\n          this[kEvents].delete(type);\n        // Undefined is passed as the listener as the listener was GCed\n        this[kRemoveListener](root.size\x2C type\x2C undefined\x2C capture);\n        break;\n      }\n      handler = handler.next;\n    }\n  }\n\n  /**\n   * @param {Event} event\n   */\n  dispatchEvent(event) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    if (arguments.length < 1)\n      throw new ERR_MISSING_ARGS('event');\n\n    if (!(event instanceof Event))\n      throw new ERR_INVALID_ARG_TYPE('event'\x2C 'Event'\x2C event);\n\n    if (event[kIsBeingDispatched])\n      throw new ERR_EVENT_RECURSION(event.type);\n\n    this[kHybridDispatch](event\x2C event.type\x2C event);\n\n    return event.defaultPrevented !== true;\n  }\n\n  [kHybridDispatch](nodeValue\x2C type\x2C event) {\n    const createEvent = () => {\n      if (event === undefined) {\n        event = this[kCreateEvent](nodeValue\x2C type);\n        event[kTarget] = this;\n        event[kIsBeingDispatched] = true;\n      }\n      return event;\n    };\n    if (event !== undefined) {\n      event[kTarget] = this;\n      event[kIsBeingDispatched] = true;\n    }\n\n    const root = this[kEvents].get(type);\n    if (root === undefined || root.next === undefined) {\n      if (event !== undefined)\n        event[kIsBeingDispatched] = false;\n      return true;\n    }\n\n    let handler = root.next;\n    let next;\n\n    const iterationCondition = () => {\n      if (handler === undefined) {\n        return false;\n      }\n      return root.resistStopPropagation || handler.passive || event?.[kStop] !== true;\n    };\n    while (iterationCondition()) {\n      // Cache the next item in case this iteration removes the current one\n      next = handler.next;\n\n      if (handler.removed || (event?.[kStop] === true && !handler.resistStopPropagation)) {\n        // Deal with the case an event is removed while event handlers are\n        // Being processed (removeEventListener called from a listener)\n        // And the case of event.stopImmediatePropagation() being called\n        // For events not flagged as resistStopPropagation\n        handler = next;\n        continue;\n      }\n      if (handler.once) {\n        handler.remove();\n        root.size--;\n        const { listener\x2C capture } = handler;\n        this[kRemoveListener](root.size\x2C type\x2C listener\x2C capture);\n      }\n\n      try {\n        let arg;\n        if (handler.isNodeStyleListener) {\n          arg = nodeValue;\n        } else {\n          arg = createEvent();\n        }\n        const callback = handler.weak ?\n          handler.callback.deref() : handler.callback;\n        let result;\n        if (callback) {\n          result = FunctionPrototypeCall(callback\x2C this\x2C arg);\n          if (!handler.isNodeStyleListener) {\n            arg[kIsBeingDispatched] = false;\n          }\n        }\n        if (result !== undefined && result !== null)\n          addCatch(result);\n      } catch (err) {\n        emitUncaughtException(err);\n      }\n\n      handler = next;\n    }\n\n    if (event !== undefined)\n      event[kIsBeingDispatched] = false;\n  }\n\n  [kCreateEvent](nodeValue\x2C type) {\n    return new NodeCustomEvent(type\x2C { detail: nodeValue });\n  }\n  [customInspectSymbol](depth\x2C options) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    const name = this.constructor.name;\n    if (depth < 0)\n      return name;\n\n    const opts = ObjectAssign({}\x2C options\x2C {\n      depth: NumberIsInteger(options.depth) ? options.depth - 1 : options.depth\x2C\n    });\n\n    return `${name} ${inspect({}\x2C opts)}`;\n  }\n}\n\nObjectDefineProperties(EventTarget.prototype\x2C {\n  addEventListener: kEnumerableProperty\x2C\n  removeEventListener: kEnumerableProperty\x2C\n  dispatchEvent: kEnumerableProperty\x2C\n  [SymbolToStringTag]: {\n    __proto__: null\x2C\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: 'EventTarget'\x2C\n  }\x2C\n});\n\nfunction initNodeEventTarget(self) {\n  initEventTarget(self);\n}\n\nclass NodeEventTarget extends EventTarget {\n  static [kIsNodeEventTarget] = true;\n  static defaultMaxListeners = 10;\n\n  constructor() {\n    super();\n    initNodeEventTarget(this);\n  }\n\n  /**\n   * @param {number} n\n   */\n  setMaxListeners(n) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    EventEmitter.setMaxListeners(n\x2C this);\n  }\n\n  /**\n   * @returns {number}\n   */\n  getMaxListeners() {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    return this[kMaxEventTargetListeners];\n  }\n\n  /**\n   * @returns {string[]}\n   */\n  eventNames() {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    return ArrayFrom(this[kEvents].keys());\n  }\n\n  /**\n   * @param {string} type\n   * @returns {number}\n   */\n  listenerCount(type) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    const root = this[kEvents].get(String(type));\n    return root !== undefined ? root.size : 0;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @param {{\n   *   capture?: boolean\x2C\n   * }} [options]\n   * @returns {NodeEventTarget}\n   */\n  off(type\x2C listener\x2C options) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.removeEventListener(type\x2C listener\x2C options);\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @param {{\n   *   capture?: boolean\x2C\n   * }} [options]\n   * @returns {NodeEventTarget}\n   */\n  removeListener(type\x2C listener\x2C options) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.removeEventListener(type\x2C listener\x2C options);\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @returns {NodeEventTarget}\n   */\n  on(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C { [kIsNodeStyleListener]: true });\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @returns {NodeEventTarget}\n   */\n  addListener(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C { [kIsNodeStyleListener]: true });\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @param {any} arg\n   * @returns {boolean}\n   */\n  emit(type\x2C arg) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    validateString(type\x2C 'type');\n    const hadListeners = this.listenerCount(type) > 0;\n    this[kHybridDispatch](arg\x2C type);\n    return hadListeners;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @returns {NodeEventTarget}\n   */\n  once(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C\n                          { once: true\x2C [kIsNodeStyleListener]: true });\n    return this;\n  }\n\n  /**\n   * @param {string} [type]\n   * @returns {NodeEventTarget}\n   */\n  removeAllListeners(type) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    if (type !== undefined) {\n      this[kEvents].delete(String(type));\n    } else {\n      this[kEvents].clear();\n    }\n\n    return this;\n  }\n}\n\nObjectDefineProperties(NodeEventTarget.prototype\x2C {\n  setMaxListeners: kEnumerableProperty\x2C\n  getMaxListeners: kEnumerableProperty\x2C\n  eventNames: kEnumerableProperty\x2C\n  listenerCount: kEnumerableProperty\x2C\n  off: kEnumerableProperty\x2C\n  removeListener: kEnumerableProperty\x2C\n  on: kEnumerableProperty\x2C\n  addListener: kEnumerableProperty\x2C\n  once: kEnumerableProperty\x2C\n  emit: kEnumerableProperty\x2C\n  removeAllListeners: kEnumerableProperty\x2C\n});\n\n// EventTarget API\n\nfunction validateEventListener(listener) {\n  if (typeof listener === 'function' ||\n      typeof listener?.handleEvent === 'function') {\n    return true;\n  }\n\n  if (listener == null)\n    return false;\n\n  if (typeof listener === 'object') {\n    // Require `handleEvent` lazily.\n    return true;\n  }\n\n  throw new ERR_INVALID_ARG_TYPE('listener'\x2C 'EventListener'\x2C listener);\n}\n\nfunction validateEventListenerOptions(options) {\n  if (typeof options === 'boolean')\n    return { capture: options };\n\n  if (options === null)\n    return kEmptyObject;\n  validateObject(options\x2C 'options'\x2C kValidateObjectAllowArray | kValidateObjectAllowFunction);\n  return {\n    once: Boolean(options.once)\x2C\n    capture: Boolean(options.capture)\x2C\n    passive: Boolean(options.passive)\x2C\n    signal: options.signal\x2C\n    weak: options[kWeakHandler]\x2C\n    resistStopPropagation: options[kResistStopPropagation] ?? false\x2C\n    isNodeStyleListener: Boolean(options[kIsNodeStyleListener])\x2C\n  };\n}\n\n// Test whether the argument is an event object. This is far from a fool-proof\n// test\x2C for example this input will result in a false positive:\n// > isEventTarget({ constructor: EventTarget })\n// It stands in its current implementation as a compromise.\n// Ref: https://github.com/nodejs/node/pull/33661\nfunction isEventTarget(obj) {\n  return obj?.constructor?.[kIsEventTarget];\n}\n\nfunction isNodeEventTarget(obj) {\n  return obj?.constructor?.[kIsNodeEventTarget];\n}\n\nfunction addCatch(promise) {\n  const then = promise.then;\n  if (typeof then === 'function') {\n    FunctionPrototypeCall(then\x2C promise\x2C undefined\x2C function(err) {\n      // The callback is called with nextTick to avoid a follow-up\n      // rejection from this promise.\n      emitUncaughtException(err);\n    });\n  }\n}\n\nfunction emitUncaughtException(err) {\n  process.nextTick(() => { throw err; });\n}\n\nfunction makeEventHandler(handler) {\n  // Event handlers are dispatched in the order they were first set\n  // See https://github.com/nodejs/node/pull/35949#issuecomment-722496598\n  function eventHandler(...args) {\n    if (typeof eventHandler.handler !== 'function') {\n      return;\n    }\n    return ReflectApply(eventHandler.handler\x2C this\x2C args);\n  }\n  eventHandler.handler = handler;\n  return eventHandler;\n}\n\nfunction defineEventHandler(emitter\x2C name\x2C event = name) {\n  // 8.1.5.1 Event handlers - basically `on[eventName]` attributes\n  const propName = `on${name}`;\n  function get() {\n    validateInternalField(this\x2C kHandlers\x2C 'EventTarget');\n    return this[kHandlers]?.get(event)?.handler ?? null;\n  }\n  ObjectDefineProperty(get\x2C 'name'\x2C {\n    __proto__: null\x2C\n    value: `get ${propName}`\x2C\n  });\n\n  function set(value) {\n    validateInternalField(this\x2C kHandlers\x2C 'EventTarget');\n    let wrappedHandler = this[kHandlers]?.get(event);\n    if (wrappedHandler) {\n      if (typeof wrappedHandler.handler === 'function') {\n        this[kEvents].get(event).size--;\n        const size = this[kEvents].get(event).size;\n        this[kRemoveListener](size\x2C event\x2C wrappedHandler.handler\x2C false);\n      }\n      wrappedHandler.handler = value;\n      if (typeof wrappedHandler.handler === 'function') {\n        this[kEvents].get(event).size++;\n        const size = this[kEvents].get(event).size;\n        this[kNewListener](size\x2C event\x2C value\x2C false\x2C false\x2C false\x2C false);\n      }\n    } else {\n      wrappedHandler = makeEventHandler(value);\n      this.addEventListener(event\x2C wrappedHandler);\n    }\n    this[kHandlers].set(event\x2C wrappedHandler);\n  }\n  ObjectDefineProperty(set\x2C 'name'\x2C {\n    __proto__: null\x2C\n    value: `set ${propName}`\x2C\n  });\n\n  ObjectDefineProperty(emitter\x2C propName\x2C {\n    __proto__: null\x2C\n    get\x2C\n    set\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n  });\n}\n\nconst EventEmitterMixin = (Superclass) => {\n  class MixedEventEmitter extends Superclass {\n    constructor(...args) {\n      args = new SafeArrayIterator(args);\n      super(...args);\n      FunctionPrototypeCall(EventEmitter\x2C this);\n    }\n  }\n  const protoProps = ObjectGetOwnPropertyDescriptors(EventEmitter.prototype);\n  delete protoProps.constructor;\n  const propertiesValues = ObjectValues(protoProps);\n  for (let i = 0; i < propertiesValues.length; i++) {\n    // We want to use null-prototype objects to not rely on globally mutable\n    // %Object.prototype%.\n    ObjectSetPrototypeOf(propertiesValues[i]\x2C null);\n  }\n  ObjectDefineProperties(MixedEventEmitter.prototype\x2C protoProps);\n  return MixedEventEmitter;\n};\n\nmodule.exports = {\n  Event\x2C\n  CustomEvent\x2C\n  EventEmitterMixin\x2C\n  EventTarget\x2C\n  NodeEventTarget\x2C\n  defineEventHandler\x2C\n  initEventTarget\x2C\n  initNodeEventTarget\x2C\n  kCreateEvent\x2C\n  kNewListener\x2C\n  kTrustEvent\x2C\n  kRemoveListener\x2C\n  kEvents\x2C\n  kWeakHandler\x2C\n  kResistStopPropagation\x2C\n  isEventTarget\x2C\n};\n
code-source-info,0x31e6f25e9ae6,47,29454,30893,C0O29454C24O29478C36O29572C41O29577C46O29726C56O29747C66O29801C77O29726C82O30663C92O30684C102O30738C113O30663C118O30759C125O30789C132O30826C138O30835C148O30759C154O30892,,
tick,0x7ff8092c91c3,95915,0,0x0,3,0x10c9f09d0,0x31e6f25e7e07,0x112583feb,0x112583ca1,0x31e6f25e42cc,0x112583feb,0x112583ca1,0x31e6f25e22c3,0x112583feb,0x112583ca1,0x31e6f25df4ab,0x112583feb,0x112583ca1,0x31e6f25da395,0x112583feb,0x112583ca1,0x31e6f25d7289,0x112583feb,0x31e6f25d6c7a,0x31e6f25d6880,0x31e6f6b607cb,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f25d543c,0x31e6f6b7a501,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
tick,0x10c964b3f,96056,1,0x10c1e6120,2,0x10c41e000,0x112583f26,0x112583ca1,0x31e6f25e4338,0x112583feb,0x112583ca1,0x31e6f25e22c3,0x112583feb,0x112583ca1,0x31e6f25df4ab,0x112583feb,0x112583ca1,0x31e6f25da395,0x112583feb,0x112583ca1,0x31e6f25d7289,0x112583feb,0x31e6f25d6c7a,0x31e6f25d6880,0x31e6f6b607cb,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f25d543c,0x31e6f6b7a501,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,Eval,10,96133,0x31e6f25ecee6,5, node:internal/streams/end-of-stream:1:1,0x31e6f25ecb90,~
script-source,95,node:internal/streams/end-of-stream,// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author\x2C Mathias Buus (@mafintosh).\n\n'use strict';\n\nconst {\n  AbortError\x2C\n  codes\x2C\n} = require('internal/errors');\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_STREAM_PREMATURE_CLOSE\x2C\n} = codes;\nconst {\n  kEmptyObject\x2C\n  once\x2C\n} = require('internal/util');\nconst {\n  validateAbortSignal\x2C\n  validateFunction\x2C\n  validateObject\x2C\n  validateBoolean\x2C\n} = require('internal/validators');\n\nconst {\n  Promise\x2C\n  PromisePrototypeThen\x2C\n  SymbolDispose\x2C\n} = primordials;\n\nconst {\n  isClosed\x2C\n  isReadable\x2C\n  isReadableNodeStream\x2C\n  isReadableStream\x2C\n  isReadableFinished\x2C\n  isReadableErrored\x2C\n  isWritable\x2C\n  isWritableNodeStream\x2C\n  isWritableStream\x2C\n  isWritableFinished\x2C\n  isWritableErrored\x2C\n  isNodeStream\x2C\n  willEmitClose: _willEmitClose\x2C\n  kIsClosedPromise\x2C\n} = require('internal/streams/utils');\nlet addAbortListener;\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nconst nop = () => {};\n\nfunction eos(stream\x2C options\x2C callback) {\n  if (arguments.length === 2) {\n    callback = options;\n    options = kEmptyObject;\n  } else if (options == null) {\n    options = kEmptyObject;\n  } else {\n    validateObject(options\x2C 'options');\n  }\n  validateFunction(callback\x2C 'callback');\n  validateAbortSignal(options.signal\x2C 'options.signal');\n\n  callback = once(callback);\n\n  if (isReadableStream(stream) || isWritableStream(stream)) {\n    return eosWeb(stream\x2C options\x2C callback);\n  }\n\n  if (!isNodeStream(stream)) {\n    throw new ERR_INVALID_ARG_TYPE('stream'\x2C ['ReadableStream'\x2C 'WritableStream'\x2C 'Stream']\x2C stream);\n  }\n\n  const readable = options.readable ?? isReadableNodeStream(stream);\n  const writable = options.writable ?? isWritableNodeStream(stream);\n\n  const wState = stream._writableState;\n  const rState = stream._readableState;\n\n  const onlegacyfinish = () => {\n    if (!stream.writable) {\n      onfinish();\n    }\n  };\n\n  // TODO (ronag): Improve soft detection to include core modules and\n  // common ecosystem modules that do properly emit 'close' but fail\n  // this generic check.\n  let willEmitClose = (\n    _willEmitClose(stream) &&\n    isReadableNodeStream(stream) === readable &&\n    isWritableNodeStream(stream) === writable\n  );\n\n  let writableFinished = isWritableFinished(stream\x2C false);\n  const onfinish = () => {\n    writableFinished = true;\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false;\n    }\n\n    if (willEmitClose && (!stream.readable || readable)) {\n      return;\n    }\n\n    if (!readable || readableFinished) {\n      callback.call(stream);\n    }\n  };\n\n  let readableFinished = isReadableFinished(stream\x2C false);\n  const onend = () => {\n    readableFinished = true;\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false;\n    }\n\n    if (willEmitClose && (!stream.writable || writable)) {\n      return;\n    }\n\n    if (!writable || writableFinished) {\n      callback.call(stream);\n    }\n  };\n\n  const onerror = (err) => {\n    callback.call(stream\x2C err);\n  };\n\n  let closed = isClosed(stream);\n\n  const onclose = () => {\n    closed = true;\n\n    const errored = isWritableErrored(stream) || isReadableErrored(stream);\n\n    if (errored && typeof errored !== 'boolean') {\n      return callback.call(stream\x2C errored);\n    }\n\n    if (readable && !readableFinished && isReadableNodeStream(stream\x2C true)) {\n      if (!isReadableFinished(stream\x2C false))\n        return callback.call(stream\x2C\n                             new ERR_STREAM_PREMATURE_CLOSE());\n    }\n    if (writable && !writableFinished) {\n      if (!isWritableFinished(stream\x2C false))\n        return callback.call(stream\x2C\n                             new ERR_STREAM_PREMATURE_CLOSE());\n    }\n\n    callback.call(stream);\n  };\n\n  const onclosed = () => {\n    closed = true;\n\n    const errored = isWritableErrored(stream) || isReadableErrored(stream);\n\n    if (errored && typeof errored !== 'boolean') {\n      return callback.call(stream\x2C errored);\n    }\n\n    callback.call(stream);\n  };\n\n  const onrequest = () => {\n    stream.req.on('finish'\x2C onfinish);\n  };\n\n  if (isRequest(stream)) {\n    stream.on('complete'\x2C onfinish);\n    if (!willEmitClose) {\n      stream.on('abort'\x2C onclose);\n    }\n    if (stream.req) {\n      onrequest();\n    } else {\n      stream.on('request'\x2C onrequest);\n    }\n  } else if (writable && !wState) { // legacy streams\n    stream.on('end'\x2C onlegacyfinish);\n    stream.on('close'\x2C onlegacyfinish);\n  }\n\n  // Not all streams will emit 'close' after 'aborted'.\n  if (!willEmitClose && typeof stream.aborted === 'boolean') {\n    stream.on('aborted'\x2C onclose);\n  }\n\n  stream.on('end'\x2C onend);\n  stream.on('finish'\x2C onfinish);\n  if (options.error !== false) {\n    stream.on('error'\x2C onerror);\n  }\n  stream.on('close'\x2C onclose);\n\n  if (closed) {\n    process.nextTick(onclose);\n  } else if (wState?.errorEmitted || rState?.errorEmitted) {\n    if (!willEmitClose) {\n      process.nextTick(onclosed);\n    }\n  } else if (\n    !readable &&\n    (!willEmitClose || isReadable(stream)) &&\n    (writableFinished || isWritable(stream) === false)\n  ) {\n    process.nextTick(onclosed);\n  } else if (\n    !writable &&\n    (!willEmitClose || isWritable(stream)) &&\n    (readableFinished || isReadable(stream) === false)\n  ) {\n    process.nextTick(onclosed);\n  } else if ((rState && stream.req && stream.aborted)) {\n    process.nextTick(onclosed);\n  }\n\n  const cleanup = () => {\n    callback = nop;\n    stream.removeListener('aborted'\x2C onclose);\n    stream.removeListener('complete'\x2C onfinish);\n    stream.removeListener('abort'\x2C onclose);\n    stream.removeListener('request'\x2C onrequest);\n    if (stream.req) stream.req.removeListener('finish'\x2C onfinish);\n    stream.removeListener('end'\x2C onlegacyfinish);\n    stream.removeListener('close'\x2C onlegacyfinish);\n    stream.removeListener('finish'\x2C onfinish);\n    stream.removeListener('end'\x2C onend);\n    stream.removeListener('error'\x2C onerror);\n    stream.removeListener('close'\x2C onclose);\n  };\n\n  if (options.signal && !closed) {\n    const abort = () => {\n      // Keep it because cleanup removes it.\n      const endCallback = callback;\n      cleanup();\n      endCallback.call(\n        stream\x2C\n        new AbortError(undefined\x2C { cause: options.signal.reason }));\n    };\n    if (options.signal.aborted) {\n      process.nextTick(abort);\n    } else {\n      addAbortListener ??= require('events').addAbortListener;\n      const disposable = addAbortListener(options.signal\x2C abort);\n      const originalCallback = callback;\n      callback = once((...args) => {\n        disposable[SymbolDispose]();\n        originalCallback.apply(stream\x2C args);\n      });\n    }\n  }\n\n  return cleanup;\n}\n\nfunction eosWeb(stream\x2C options\x2C callback) {\n  let isAborted = false;\n  let abort = nop;\n  if (options.signal) {\n    abort = () => {\n      isAborted = true;\n      callback.call(stream\x2C new AbortError(undefined\x2C { cause: options.signal.reason }));\n    };\n    if (options.signal.aborted) {\n      process.nextTick(abort);\n    } else {\n      addAbortListener ??= require('events').addAbortListener;\n      const disposable = addAbortListener(options.signal\x2C abort);\n      const originalCallback = callback;\n      callback = once((...args) => {\n        disposable[SymbolDispose]();\n        originalCallback.apply(stream\x2C args);\n      });\n    }\n  }\n  const resolverFn = (...args) => {\n    if (!isAborted) {\n      process.nextTick(() => callback.apply(stream\x2C args));\n    }\n  };\n  PromisePrototypeThen(\n    stream[kIsClosedPromise].promise\x2C\n    resolverFn\x2C\n    resolverFn\x2C\n  );\n  return nop;\n}\n\nfunction finished(stream\x2C opts) {\n  let autoCleanup = false;\n  if (opts === null) {\n    opts = kEmptyObject;\n  }\n  if (opts?.cleanup) {\n    validateBoolean(opts.cleanup\x2C 'cleanup');\n    autoCleanup = opts.cleanup;\n  }\n  return new Promise((resolve\x2C reject) => {\n    const cleanup = eos(stream\x2C opts\x2C (err) => {\n      if (autoCleanup) {\n        cleanup();\n      }\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nmodule.exports = eos;\nmodule.exports.finished = finished;\n
code-source-info,0x31e6f25ecee6,95,0,8360,C0O0C4O8360,,
code-creation,JS,10,96654,0x31e6f25ed226,353, node:internal/streams/end-of-stream:1:1,0x31e6f25ece60,~
code-source-info,0x31e6f25ed226,95,0,8360,C0O0C120O172C126O172C131O147C137O161C142O210C148O234C154O309C160O309C165O283C171O299C177O427C183O427C188O345C194O368C200O388C206O406C212O470C218O481C224O505C230O833C236O833C241O548C247O560C253O574C259O598C265O618C271O640C277O661C283O675C289O699C295O719C301O741C307O762C313O793C319O811C325O872C326O872C328O1000C332O1000C334O8302C336O8317C340O8331C347O8348C352O8359,,
code-creation,Eval,10,96902,0x31e6f25ee7ee,5, node:internal/streams/utils:1:1,0x31e6f25ee568,~
script-source,96,node:internal/streams/utils,'use strict';\n\nconst {\n  SymbolAsyncIterator\x2C\n  SymbolIterator\x2C\n  SymbolFor\x2C\n  Symbol\x2C\n} = primordials;\n\n// We need to use SymbolFor to make these globally available\n// for interopt with readable-stream\x2C i.e. readable-stream\n// and node core needs to be able to read/write private state\n// from each other for proper interoperability.\nconst kIsDestroyed = SymbolFor('nodejs.stream.destroyed');\nconst kIsErrored = SymbolFor('nodejs.stream.errored');\nconst kIsReadable = SymbolFor('nodejs.stream.readable');\nconst kIsWritable = SymbolFor('nodejs.stream.writable');\nconst kIsDisturbed = SymbolFor('nodejs.stream.disturbed');\n\nconst kOnConstructed = Symbol('kOnConstructed');\n\nconst kIsClosedPromise = SymbolFor('nodejs.webstream.isClosedPromise');\nconst kControllerErrorFunction = SymbolFor('nodejs.webstream.controllerErrorFunction');\n\nconst kState = Symbol('kState');\nconst kObjectMode = 1 << 0;\nconst kErrorEmitted = 1 << 1;\nconst kAutoDestroy = 1 << 2;\nconst kEmitClose = 1 << 3;\nconst kDestroyed = 1 << 4;\nconst kClosed = 1 << 5;\nconst kCloseEmitted = 1 << 6;\nconst kErrored = 1 << 7;\nconst kConstructed = 1 << 8;\n\nfunction isReadableNodeStream(obj\x2C strict = false) {\n  return !!(\n    obj &&\n    typeof obj.pipe === 'function' &&\n    typeof obj.on === 'function' &&\n    (\n      !strict ||\n      (typeof obj.pause === 'function' && typeof obj.resume === 'function')\n    ) &&\n    (!obj._writableState || obj._readableState?.readable !== false) && // Duplex\n    (!obj._writableState || obj._readableState) // Writable has .pipe.\n  );\n}\n\nfunction isWritableNodeStream(obj) {\n  return !!(\n    obj &&\n    typeof obj.write === 'function' &&\n    typeof obj.on === 'function' &&\n    (!obj._readableState || obj._writableState?.writable !== false) // Duplex\n  );\n}\n\nfunction isDuplexNodeStream(obj) {\n  return !!(\n    obj &&\n    (typeof obj.pipe === 'function' && obj._readableState) &&\n    typeof obj.on === 'function' &&\n    typeof obj.write === 'function'\n  );\n}\n\nfunction isNodeStream(obj) {\n  return (\n    obj &&\n    (\n      obj._readableState ||\n      obj._writableState ||\n      (typeof obj.write === 'function' && typeof obj.on === 'function') ||\n      (typeof obj.pipe === 'function' && typeof obj.on === 'function')\n    )\n  );\n}\n\nfunction isReadableStream(obj) {\n  return !!(\n    obj &&\n    !isNodeStream(obj) &&\n    typeof obj.pipeThrough === 'function' &&\n    typeof obj.getReader === 'function' &&\n    typeof obj.cancel === 'function'\n  );\n}\n\nfunction isWritableStream(obj) {\n  return !!(\n    obj &&\n    !isNodeStream(obj) &&\n    typeof obj.getWriter === 'function' &&\n    typeof obj.abort === 'function'\n  );\n}\n\nfunction isTransformStream(obj) {\n  return !!(\n    obj &&\n    !isNodeStream(obj) &&\n    typeof obj.readable === 'object' &&\n    typeof obj.writable === 'object'\n  );\n}\n\nfunction isWebStream(obj) {\n  return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);\n}\n\nfunction isIterable(obj\x2C isAsync) {\n  if (obj == null) return false;\n  if (isAsync === true) return typeof obj[SymbolAsyncIterator] === 'function';\n  if (isAsync === false) return typeof obj[SymbolIterator] === 'function';\n  return typeof obj[SymbolAsyncIterator] === 'function' ||\n    typeof obj[SymbolIterator] === 'function';\n}\n\nfunction isDestroyed(stream) {\n  if (!isNodeStream(stream)) return null;\n  const wState = stream._writableState;\n  const rState = stream._readableState;\n  const state = wState || rState;\n  return !!(stream.destroyed || stream[kIsDestroyed] || state?.destroyed);\n}\n\n// Have been end():d.\nfunction isWritableEnded(stream) {\n  if (!isWritableNodeStream(stream)) return null;\n  if (stream.writableEnded === true) return true;\n  const wState = stream._writableState;\n  if (wState?.errored) return false;\n  if (typeof wState?.ended !== 'boolean') return null;\n  return wState.ended;\n}\n\n// Have emitted 'finish'.\nfunction isWritableFinished(stream\x2C strict) {\n  if (!isWritableNodeStream(stream)) return null;\n  if (stream.writableFinished === true) return true;\n  const wState = stream._writableState;\n  if (wState?.errored) return false;\n  if (typeof wState?.finished !== 'boolean') return null;\n  return !!(\n    wState.finished ||\n    (strict === false && wState.ended === true && wState.length === 0)\n  );\n}\n\n// Have been push(null):d.\nfunction isReadableEnded(stream) {\n  if (!isReadableNodeStream(stream)) return null;\n  if (stream.readableEnded === true) return true;\n  const rState = stream._readableState;\n  if (!rState || rState.errored) return false;\n  if (typeof rState?.ended !== 'boolean') return null;\n  return rState.ended;\n}\n\n// Have emitted 'end'.\nfunction isReadableFinished(stream\x2C strict) {\n  if (!isReadableNodeStream(stream)) return null;\n  const rState = stream._readableState;\n  if (rState?.errored) return false;\n  if (typeof rState?.endEmitted !== 'boolean') return null;\n  return !!(\n    rState.endEmitted ||\n    (strict === false && rState.ended === true && rState.length === 0)\n  );\n}\n\nfunction isReadable(stream) {\n  if (stream && stream[kIsReadable] != null) return stream[kIsReadable];\n  if (typeof stream?.readable !== 'boolean') return null;\n  if (isDestroyed(stream)) return false;\n  return isReadableNodeStream(stream) &&\n    stream.readable &&\n    !isReadableFinished(stream);\n}\n\nfunction isWritable(stream) {\n  if (stream && stream[kIsWritable] != null) return stream[kIsWritable];\n  if (typeof stream?.writable !== 'boolean') return null;\n  if (isDestroyed(stream)) return false;\n  return isWritableNodeStream(stream) &&\n    stream.writable &&\n    !isWritableEnded(stream);\n}\n\nfunction isFinished(stream\x2C opts) {\n  if (!isNodeStream(stream)) {\n    return null;\n  }\n\n  if (isDestroyed(stream)) {\n    return true;\n  }\n\n  if (opts?.readable !== false && isReadable(stream)) {\n    return false;\n  }\n\n  if (opts?.writable !== false && isWritable(stream)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isWritableErrored(stream) {\n  if (!isNodeStream(stream)) {\n    return null;\n  }\n\n  if (stream.writableErrored) {\n    return stream.writableErrored;\n  }\n\n  return stream._writableState?.errored ?? null;\n}\n\nfunction isReadableErrored(stream) {\n  if (!isNodeStream(stream)) {\n    return null;\n  }\n\n  if (stream.readableErrored) {\n    return stream.readableErrored;\n  }\n\n  return stream._readableState?.errored ?? null;\n}\n\nfunction isClosed(stream) {\n  if (!isNodeStream(stream)) {\n    return null;\n  }\n\n  if (typeof stream.closed === 'boolean') {\n    return stream.closed;\n  }\n\n  const wState = stream._writableState;\n  const rState = stream._readableState;\n\n  if (\n    typeof wState?.closed === 'boolean' ||\n    typeof rState?.closed === 'boolean'\n  ) {\n    return wState?.closed || rState?.closed;\n  }\n\n  if (typeof stream._closed === 'boolean' && isOutgoingMessage(stream)) {\n    return stream._closed;\n  }\n\n  return null;\n}\n\nfunction isOutgoingMessage(stream) {\n  return (\n    typeof stream._closed === 'boolean' &&\n    typeof stream._defaultKeepAlive === 'boolean' &&\n    typeof stream._removedConnection === 'boolean' &&\n    typeof stream._removedContLen === 'boolean'\n  );\n}\n\nfunction isServerResponse(stream) {\n  return (\n    typeof stream._sent100 === 'boolean' &&\n    isOutgoingMessage(stream)\n  );\n}\n\nfunction isServerRequest(stream) {\n  return (\n    typeof stream._consuming === 'boolean' &&\n    typeof stream._dumped === 'boolean' &&\n    stream.req?.upgradeOrConnect === undefined\n  );\n}\n\nfunction willEmitClose(stream) {\n  if (!isNodeStream(stream)) return null;\n\n  const wState = stream._writableState;\n  const rState = stream._readableState;\n  const state = wState || rState;\n\n  return (!state && isServerResponse(stream)) || !!(\n    state &&\n    state.autoDestroy &&\n    state.emitClose &&\n    state.closed === false\n  );\n}\n\nfunction isDisturbed(stream) {\n  return !!(stream && (\n    stream[kIsDisturbed] ??\n    (stream.readableDidRead || stream.readableAborted)\n  ));\n}\n\nfunction isErrored(stream) {\n  return !!(stream && (\n    stream[kIsErrored] ??\n    stream.readableErrored ??\n    stream.writableErrored ??\n    stream._readableState?.errorEmitted ??\n    stream._writableState?.errorEmitted ??\n    stream._readableState?.errored ??\n    stream._writableState?.errored\n  ));\n}\n\nmodule.exports = {\n  kOnConstructed\x2C\n  isDestroyed\x2C\n  kIsDestroyed\x2C\n  isDisturbed\x2C\n  kIsDisturbed\x2C\n  isErrored\x2C\n  kIsErrored\x2C\n  isReadable\x2C\n  kIsReadable\x2C\n  kIsClosedPromise\x2C\n  kControllerErrorFunction\x2C\n  kIsWritable\x2C\n  isClosed\x2C\n  isDuplexNodeStream\x2C\n  isFinished\x2C\n  isIterable\x2C\n  isReadableNodeStream\x2C\n  isReadableStream\x2C\n  isReadableEnded\x2C\n  isReadableFinished\x2C\n  isReadableErrored\x2C\n  isNodeStream\x2C\n  isWebStream\x2C\n  isWritable\x2C\n  isWritableNodeStream\x2C\n  isWritableStream\x2C\n  isWritableEnded\x2C\n  isWritableFinished\x2C\n  isWritableErrored\x2C\n  isServerRequest\x2C\n  isServerResponse\x2C\n  willEmitClose\x2C\n  isTransformStream\x2C\n  kState\x2C\n  // bitfields\n  kObjectMode\x2C\n  kErrorEmitted\x2C\n  kAutoDestroy\x2C\n  kEmitClose\x2C\n  kDestroyed\x2C\n  kClosed\x2C\n  kCloseEmitted\x2C\n  kErrored\x2C\n  kConstructed\x2C\n};\n
code-source-info,0x31e6f25ee7ee,96,0,8934,C0O0C4O8934,,
code-creation,JS,10,97498,0x31e6f25ef5e6,592, node:internal/streams/utils:1:1,0x31e6f25ee768,~
code-source-info,0x31e6f25ef5e6,96,0,8934,C0O0C181O25C187O48C193O66C198O79C203O356C207O356C211O356C213O413C217O413C221O413C223O469C227O469C231O469C233O526C237O526C241O526C243O584C247O584C251O584C253O646C257O646C262O698C266O698C271O778C275O778C280O849C284O849C289O887C292O917C295O946C298O973C301O1000C304O1024C307O1054C310O1079C315O1108C320O8160C328O8181C334O8199C340O8214C346O8230C352O8245C358O8261C364O8274C370O8288C376O8302C382O8317C388O8337C394O8365C400O8380C406O8392C412O8414C418O8428C424O8442C430O8466C436O8486C442O8505C448O8527C454O8548C460O8564C466O8579C472O8593C478O8617C484O8637C490O8656C496O8678C502O8699C508O8718C514O8738C520O8755C526O8776C532O8801C538O8816C544O8833C550O8849C556O8863C562O8877C568O8888C574O8905C580O8917C586O8175C591O8933,,
tick,0x10c42f59b,97552,1,0x10c1e6120,3,0x10c41e000,0x112583f26,0x112583ca1,0x31e6f25ed312,0x112583feb,0x112583ca1,0x31e6f25e4338,0x112583feb,0x112583ca1,0x31e6f25e22c3,0x112583feb,0x112583ca1,0x31e6f25df4ab,0x112583feb,0x112583ca1,0x31e6f25da395,0x112583feb,0x112583ca1,0x31e6f25d7289,0x112583feb,0x31e6f25d6c7a,0x31e6f25d6880,0x31e6f6b607cb,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f25d543c,0x31e6f6b7a501,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,Eval,10,97815,0x31e6f25f1a36,5, node:internal/streams/compose:1:1,0x31e6f25f1810,~
script-source,97,node:internal/streams/compose,'use strict';\n\nconst { pipeline } = require('internal/streams/pipeline');\nconst Duplex = require('internal/streams/duplex');\nconst { destroyer } = require('internal/streams/destroy');\nconst {\n  isNodeStream\x2C\n  isReadable\x2C\n  isWritable\x2C\n  isWebStream\x2C\n  isTransformStream\x2C\n  isWritableStream\x2C\n  isReadableStream\x2C\n} = require('internal/streams/utils');\nconst {\n  AbortError\x2C\n  codes: {\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_MISSING_ARGS\x2C\n  }\x2C\n} = require('internal/errors');\nconst eos = require('internal/streams/end-of-stream');\n\nmodule.exports = function compose(...streams) {\n  if (streams.length === 0) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n\n  if (streams.length === 1) {\n    return Duplex.from(streams[0]);\n  }\n\n  const orgStreams = [...streams];\n\n  if (typeof streams[0] === 'function') {\n    streams[0] = Duplex.from(streams[0]);\n  }\n\n  if (typeof streams[streams.length - 1] === 'function') {\n    const idx = streams.length - 1;\n    streams[idx] = Duplex.from(streams[idx]);\n  }\n\n  for (let n = 0; n < streams.length; ++n) {\n    if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {\n      // TODO(ronag): Add checks for non streams.\n      continue;\n    }\n    if (\n      n < streams.length - 1 &&\n      !(\n        isReadable(streams[n]) ||\n        isReadableStream(streams[n]) ||\n        isTransformStream(streams[n])\n      )\n    ) {\n      throw new ERR_INVALID_ARG_VALUE(\n        `streams[${n}]`\x2C\n        orgStreams[n]\x2C\n        'must be readable'\x2C\n      );\n    }\n    if (\n      n > 0 &&\n      !(\n        isWritable(streams[n]) ||\n        isWritableStream(streams[n]) ||\n        isTransformStream(streams[n])\n      )\n    ) {\n      throw new ERR_INVALID_ARG_VALUE(\n        `streams[${n}]`\x2C\n        orgStreams[n]\x2C\n        'must be writable'\x2C\n      );\n    }\n  }\n\n  let ondrain;\n  let onfinish;\n  let onreadable;\n  let onclose;\n  let d;\n\n  function onfinished(err) {\n    const cb = onclose;\n    onclose = null;\n\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      d.destroy(err);\n    } else if (!readable && !writable) {\n      d.destroy();\n    }\n  }\n\n  const head = streams[0];\n  const tail = pipeline(streams\x2C onfinished);\n\n  const writable = !!(\n    isWritable(head) ||\n    isWritableStream(head) ||\n    isTransformStream(head)\n  );\n  const readable = !!(\n    isReadable(tail) ||\n    isReadableStream(tail) ||\n    isTransformStream(tail)\n  );\n\n  // TODO(ronag): Avoid double buffering.\n  // Implement Writable/Readable/Duplex traits.\n  // See\x2C https://github.com/nodejs/node/pull/33515.\n  d = new Duplex({\n    // TODO (ronag): highWaterMark?\n    writableObjectMode: !!head?.writableObjectMode\x2C\n    readableObjectMode: !!tail?.readableObjectMode\x2C\n    writable\x2C\n    readable\x2C\n  });\n\n  if (writable) {\n    if (isNodeStream(head)) {\n      d._write = function(chunk\x2C encoding\x2C callback) {\n        if (head.write(chunk\x2C encoding)) {\n          callback();\n        } else {\n          ondrain = callback;\n        }\n      };\n\n      d._final = function(callback) {\n        head.end();\n        onfinish = callback;\n      };\n\n      head.on('drain'\x2C function() {\n        if (ondrain) {\n          const cb = ondrain;\n          ondrain = null;\n          cb();\n        }\n      });\n    } else if (isWebStream(head)) {\n      const writable = isTransformStream(head) ? head.writable : head;\n      const writer = writable.getWriter();\n\n      d._write = async function(chunk\x2C encoding\x2C callback) {\n        try {\n          await writer.ready;\n          writer.write(chunk).catch(() => {});\n          callback();\n        } catch (err) {\n          callback(err);\n        }\n      };\n\n      d._final = async function(callback) {\n        try {\n          await writer.ready;\n          writer.close().catch(() => {});\n          onfinish = callback;\n        } catch (err) {\n          callback(err);\n        }\n      };\n    }\n\n    const toRead = isTransformStream(tail) ? tail.readable : tail;\n\n    eos(toRead\x2C () => {\n      if (onfinish) {\n        const cb = onfinish;\n        onfinish = null;\n        cb();\n      }\n    });\n  }\n\n  if (readable) {\n    if (isNodeStream(tail)) {\n      tail.on('readable'\x2C function() {\n        if (onreadable) {\n          const cb = onreadable;\n          onreadable = null;\n          cb();\n        }\n      });\n\n      tail.on('end'\x2C function() {\n        d.push(null);\n      });\n\n      d._read = function() {\n        while (true) {\n          const buf = tail.read();\n          if (buf === null) {\n            onreadable = d._read;\n            return;\n          }\n\n          if (!d.push(buf)) {\n            return;\n          }\n        }\n      };\n    } else if (isWebStream(tail)) {\n      const readable = isTransformStream(tail) ? tail.readable : tail;\n      const reader = readable.getReader();\n      d._read = async function() {\n        while (true) {\n          try {\n            const { value\x2C done } = await reader.read();\n\n            if (!d.push(value)) {\n              return;\n            }\n\n            if (done) {\n              d.push(null);\n              return;\n            }\n          } catch {\n            return;\n          }\n        }\n      };\n    }\n  }\n\n  d._destroy = function(err\x2C callback) {\n    if (!err && onclose !== null) {\n      err = new AbortError();\n    }\n\n    onreadable = null;\n    ondrain = null;\n    onfinish = null;\n\n    if (onclose === null) {\n      callback(err);\n    } else {\n      onclose = callback;\n      if (isNodeStream(tail)) {\n        destroyer(tail\x2C err);\n      }\n    }\n  };\n\n  return d;\n};\n
code-source-info,0x31e6f25f1a36,97,0,5451,C0O0C4O5451,,
code-creation,JS,10,98146,0x31e6f25f1c2e,184, node:internal/streams/compose:1:1,0x31e6f25f19b0,~
code-source-info,0x31e6f25f1c2e,97,0,5451,C0O0C47O36C50O36C55O23C61O89C64O89C68O89C70O147C73O147C78O133C84O316C87O316C92O194C98O210C104O224C110O238C116O253C122O274C128O294C134O442C137O442C142O361C148O382C153O388C159O415C165O482C168O482C172O482C174O526C178O541C183O5450,,
code-creation,Eval,10,98418,0x31e6f25f2dbe,5, node:internal/streams/pipeline:1:1,0x31e6f25f2a08,~
script-source,98,node:internal/streams/pipeline,// Ported from https://github.com/mafintosh/pump with\n// permission from the author\x2C Mathias Buus (@mafintosh).\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  Promise\x2C\n  SymbolAsyncIterator\x2C\n  SymbolDispose\x2C\n} = primordials;\n\nconst eos = require('internal/streams/end-of-stream');\nconst { once } = require('internal/util');\nconst destroyImpl = require('internal/streams/destroy');\nconst Duplex = require('internal/streams/duplex');\nconst {\n  aggregateTwoErrors\x2C\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_RETURN_VALUE\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_STREAM_DESTROYED\x2C\n    ERR_STREAM_PREMATURE_CLOSE\x2C\n  }\x2C\n  AbortError\x2C\n} = require('internal/errors');\n\nconst {\n  validateFunction\x2C\n  validateAbortSignal\x2C\n} = require('internal/validators');\n\nconst {\n  isIterable\x2C\n  isReadable\x2C\n  isReadableNodeStream\x2C\n  isNodeStream\x2C\n  isTransformStream\x2C\n  isWebStream\x2C\n  isReadableStream\x2C\n  isReadableFinished\x2C\n} = require('internal/streams/utils');\nconst { AbortController } = require('internal/abort_controller');\n\nlet PassThrough;\nlet Readable;\nlet addAbortListener;\n\nfunction destroyer(stream\x2C reading\x2C writing) {\n  let finished = false;\n  stream.on('close'\x2C () => {\n    finished = true;\n  });\n\n  const cleanup = eos(stream\x2C { readable: reading\x2C writable: writing }\x2C (err) => {\n    finished = !err;\n  });\n\n  return {\n    destroy: (err) => {\n      if (finished) return;\n      finished = true;\n      destroyImpl.destroyer(stream\x2C err || new ERR_STREAM_DESTROYED('pipe'));\n    }\x2C\n    cleanup\x2C\n  };\n}\n\nfunction popCallback(streams) {\n  // Streams should never be an empty array. It should always contain at least\n  // a single stream. Therefore optimize for the average case instead of\n  // checking for length === 0 as well.\n  validateFunction(streams[streams.length - 1]\x2C 'streams[stream.length - 1]');\n  return streams.pop();\n}\n\nfunction makeAsyncIterable(val) {\n  if (isIterable(val)) {\n    return val;\n  } else if (isReadableNodeStream(val)) {\n    // Legacy streams are not Iterable.\n    return fromReadable(val);\n  }\n  throw new ERR_INVALID_ARG_TYPE(\n    'val'\x2C ['Readable'\x2C 'Iterable'\x2C 'AsyncIterable']\x2C val);\n}\n\nasync function* fromReadable(val) {\n  if (!Readable) {\n    Readable = require('internal/streams/readable');\n  }\n\n  yield* Readable.prototype[SymbolAsyncIterator].call(val);\n}\n\nasync function pumpToNode(iterable\x2C writable\x2C finish\x2C { end }) {\n  let error;\n  let onresolve = null;\n\n  const resume = (err) => {\n    if (err) {\n      error = err;\n    }\n\n    if (onresolve) {\n      const callback = onresolve;\n      onresolve = null;\n      callback();\n    }\n  };\n\n  const wait = () => new Promise((resolve\x2C reject) => {\n    if (error) {\n      reject(error);\n    } else {\n      onresolve = () => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      };\n    }\n  });\n\n  writable.on('drain'\x2C resume);\n  const cleanup = eos(writable\x2C { readable: false }\x2C resume);\n\n  try {\n    if (writable.writableNeedDrain) {\n      await wait();\n    }\n\n    for await (const chunk of iterable) {\n      if (!writable.write(chunk)) {\n        await wait();\n      }\n    }\n\n    if (end) {\n      writable.end();\n      await wait();\n    }\n\n    finish();\n  } catch (err) {\n    finish(error !== err ? aggregateTwoErrors(error\x2C err) : err);\n  } finally {\n    cleanup();\n    writable.off('drain'\x2C resume);\n  }\n}\n\nasync function pumpToWeb(readable\x2C writable\x2C finish\x2C { end }) {\n  if (isTransformStream(writable)) {\n    writable = writable.writable;\n  }\n  // https://streams.spec.whatwg.org/#example-manual-write-with-backpressure\n  const writer = writable.getWriter();\n  try {\n    for await (const chunk of readable) {\n      await writer.ready;\n      writer.write(chunk).catch(() => {});\n    }\n\n    await writer.ready;\n\n    if (end) {\n      await writer.close();\n    }\n\n    finish();\n  } catch (err) {\n    try {\n      await writer.abort(err);\n      finish(err);\n    } catch (err) {\n      finish(err);\n    }\n  }\n}\n\nfunction pipeline(...streams) {\n  return pipelineImpl(streams\x2C once(popCallback(streams)));\n}\n\nfunction pipelineImpl(streams\x2C callback\x2C opts) {\n  if (streams.length === 1 && ArrayIsArray(streams[0])) {\n    streams = streams[0];\n  }\n\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n\n  const ac = new AbortController();\n  const signal = ac.signal;\n  const outerSignal = opts?.signal;\n\n  // Need to cleanup event listeners if last stream is readable\n  // https://github.com/nodejs/node/issues/35452\n  const lastStreamCleanup = [];\n\n  validateAbortSignal(outerSignal\x2C 'options.signal');\n\n  function abort() {\n    finishImpl(new AbortError());\n  }\n\n  addAbortListener ??= require('events').addAbortListener;\n  let disposable;\n  if (outerSignal) {\n    disposable = addAbortListener(outerSignal\x2C abort);\n  }\n\n  let error;\n  let value;\n  const destroys = [];\n\n  let finishCount = 0;\n\n  function finish(err) {\n    finishImpl(err\x2C --finishCount === 0);\n  }\n\n  function finishImpl(err\x2C final) {\n    if (err && (!error || error.code === 'ERR_STREAM_PREMATURE_CLOSE')) {\n      error = err;\n    }\n\n    if (!error && !final) {\n      return;\n    }\n\n    while (destroys.length) {\n      destroys.shift()(error);\n    }\n\n    disposable?.[SymbolDispose]();\n    ac.abort();\n\n    if (final) {\n      if (!error) {\n        lastStreamCleanup.forEach((fn) => fn());\n      }\n      process.nextTick(callback\x2C error\x2C value);\n    }\n  }\n\n  let ret;\n  for (let i = 0; i < streams.length; i++) {\n    const stream = streams[i];\n    const reading = i < streams.length - 1;\n    const writing = i > 0;\n    const end = reading || opts?.end !== false;\n    const isLastStream = i === streams.length - 1;\n\n    if (isNodeStream(stream)) {\n      if (end) {\n        const { destroy\x2C cleanup } = destroyer(stream\x2C reading\x2C writing);\n        destroys.push(destroy);\n\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup);\n        }\n      }\n\n      // Catch stream errors that occur after pipe/pump has completed.\n      function onError(err) {\n        if (\n          err &&\n          err.name !== 'AbortError' &&\n          err.code !== 'ERR_STREAM_PREMATURE_CLOSE'\n        ) {\n          finish(err);\n        }\n      }\n      stream.on('error'\x2C onError);\n      if (isReadable(stream) && isLastStream) {\n        lastStreamCleanup.push(() => {\n          stream.removeListener('error'\x2C onError);\n        });\n      }\n    }\n\n    if (i === 0) {\n      if (typeof stream === 'function') {\n        ret = stream({ signal });\n        if (!isIterable(ret)) {\n          throw new ERR_INVALID_RETURN_VALUE(\n            'Iterable\x2C AsyncIterable or Stream'\x2C 'source'\x2C ret);\n        }\n      } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {\n        ret = stream;\n      } else {\n        ret = Duplex.from(stream);\n      }\n    } else if (typeof stream === 'function') {\n      if (isTransformStream(ret)) {\n        ret = makeAsyncIterable(ret?.readable);\n      } else {\n        ret = makeAsyncIterable(ret);\n      }\n      ret = stream(ret\x2C { signal });\n\n      if (reading) {\n        if (!isIterable(ret\x2C true)) {\n          throw new ERR_INVALID_RETURN_VALUE(\n            'AsyncIterable'\x2C `transform[${i - 1}]`\x2C ret);\n        }\n      } else {\n        if (!PassThrough) {\n          PassThrough = require('internal/streams/passthrough');\n        }\n\n        // If the last argument to pipeline is not a stream\n        // we must create a proxy stream so that pipeline(...)\n        // always returns a stream which can be further\n        // composed through `.pipe(stream)`.\n\n        const pt = new PassThrough({\n          objectMode: true\x2C\n        });\n\n        // Handle Promises/A+ spec\x2C `then` could be a getter that throws on\n        // second use.\n        const then = ret?.then;\n        if (typeof then === 'function') {\n          finishCount++;\n          then.call(ret\x2C\n                    (val) => {\n                      value = val;\n                      if (val != null) {\n                        pt.write(val);\n                      }\n                      if (end) {\n                        pt.end();\n                      }\n                      process.nextTick(finish);\n                    }\x2C (err) => {\n                      pt.destroy(err);\n                      process.nextTick(finish\x2C err);\n                    }\x2C\n          );\n        } else if (isIterable(ret\x2C true)) {\n          finishCount++;\n          pumpToNode(ret\x2C pt\x2C finish\x2C { end });\n        } else if (isReadableStream(ret) || isTransformStream(ret)) {\n          const toRead = ret.readable || ret;\n          finishCount++;\n          pumpToNode(toRead\x2C pt\x2C finish\x2C { end });\n        } else {\n          throw new ERR_INVALID_RETURN_VALUE(\n            'AsyncIterable or Promise'\x2C 'destination'\x2C ret);\n        }\n\n        ret = pt;\n\n        const { destroy\x2C cleanup } = destroyer(ret\x2C false\x2C true);\n        destroys.push(destroy);\n        if (isLastStream) {\n          lastStreamCleanup.push(cleanup);\n        }\n      }\n    } else if (isNodeStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount += 2;\n        const cleanup = pipe(ret\x2C stream\x2C finish\x2C { end });\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup);\n        }\n      } else if (isTransformStream(ret) || isReadableStream(ret)) {\n        const toRead = ret.readable || ret;\n        finishCount++;\n        pumpToNode(toRead\x2C stream\x2C finish\x2C { end });\n      } else if (isIterable(ret)) {\n        finishCount++;\n        pumpToNode(ret\x2C stream\x2C finish\x2C { end });\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\n          'val'\x2C ['Readable'\x2C 'Iterable'\x2C 'AsyncIterable'\x2C 'ReadableStream'\x2C 'TransformStream']\x2C ret);\n      }\n      ret = stream;\n    } else if (isWebStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount++;\n        pumpToWeb(makeAsyncIterable(ret)\x2C stream\x2C finish\x2C { end });\n      } else if (isReadableStream(ret) || isIterable(ret)) {\n        finishCount++;\n        pumpToWeb(ret\x2C stream\x2C finish\x2C { end });\n      } else if (isTransformStream(ret)) {\n        finishCount++;\n        pumpToWeb(ret.readable\x2C stream\x2C finish\x2C { end });\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\n          'val'\x2C ['Readable'\x2C 'Iterable'\x2C 'AsyncIterable'\x2C 'ReadableStream'\x2C 'TransformStream']\x2C ret);\n      }\n      ret = stream;\n    } else {\n      ret = Duplex.from(stream);\n    }\n  }\n\n  if (signal?.aborted || outerSignal?.aborted) {\n    process.nextTick(abort);\n  }\n\n  return ret;\n}\n\nfunction pipe(src\x2C dst\x2C finish\x2C { end }) {\n  let ended = false;\n  dst.on('close'\x2C () => {\n    if (!ended) {\n      // Finish if the destination closes before the source has completed.\n      finish(new ERR_STREAM_PREMATURE_CLOSE());\n    }\n  });\n\n  src.pipe(dst\x2C { end: false }); // If end is true we already will have a listener to end dst.\n\n  if (end) {\n    // Compat. Before node v10.12.0 stdio used to throw an error so\n    // pipe() did/does not end() stdio destinations.\n    // Now they allow it but "secretly" don't close the underlying fd.\n\n    function endFn() {\n      ended = true;\n      dst.end();\n    }\n\n    if (isReadableFinished(src)) { // End the destination if the source has already ended.\n      process.nextTick(endFn);\n    } else {\n      src.once('end'\x2C endFn);\n    }\n  } else {\n    finish();\n  }\n\n  eos(src\x2C { readable: true\x2C writable: false }\x2C (err) => {\n    const rState = src._readableState;\n    if (\n      err &&\n      err.code === 'ERR_STREAM_PREMATURE_CLOSE' &&\n      (rState && rState.ended && !rState.errored && !rState.errorEmitted)\n    ) {\n      // Some readable streams will emit 'close' before 'end'. However\x2C since\n      // this is on the readable side 'end' should still be emitted if the\n      // stream has been ended and no error emitted. This should be allowed in\n      // favor of backwards compatibility. Since the stream is piped to a\n      // destination this should not result in any observable difference.\n      // We don't need to check if this is a writable premature close since\n      // eos will only fail with premature close on the reading side for\n      // duplex streams.\n      src\n        .once('end'\x2C finish)\n        .once('error'\x2C finish);\n    } else {\n      finish(err);\n    }\n  });\n  return eos(dst\x2C { readable: false\x2C writable: true }\x2C finish);\n}\n\nmodule.exports = { pipelineImpl\x2C pipeline };\n
code-source-info,0x31e6f25f2dbe,98,0,12326,C0O0C4O12326,,
code-creation,JS,10,99131,0x31e6f25f3336,421, node:internal/streams/pipeline:1:1,0x31e6f25f2d38,~
code-source-info,0x31e6f25f3336,98,0,12326,C0O0C153O138C159O154C165O165C171O188C177O233C183O233C187O233C189O293C195O293C200O284C206O339C212O339C216O339C218O391C224O391C228O391C230O627C236O627C241O437C247O466C252O472C258O498C264O528C270O550C276O576C282O611C288O711C294O711C299O666C305O686C311O902C317O902C322O754C328O768C334O782C340O806C346O822C352O843C358O858C364O878C370O965C376O965C381O945C387O1008C388O1008C390O1025C391O1025C393O1039C394O1039C396O12281C403O12300C409O12314C415O12296C420O12325,,
tick,0x7ff80925103e,99188,1,0x10c1e6120,3,0x10c41e000,0x112583f26,0x112583ca1,0x31e6f25f1c60,0x112583feb,0x112583ca1,0x31e6f25e4346,0x112583feb,0x112583ca1,0x31e6f25e22c3,0x112583feb,0x112583ca1,0x31e6f25df4ab,0x112583feb,0x112583ca1,0x31e6f25da395,0x112583feb,0x112583ca1,0x31e6f25d7289,0x112583feb,0x31e6f25d6c7a,0x31e6f25d6880,0x31e6f6b607cb,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f25d543c,0x31e6f6b7a501,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,Eval,10,99358,0x31e6f25f4c2e,5, node:internal/streams/destroy:1:1,0x31e6f25f4908,~
script-source,99,node:internal/streams/destroy,'use strict';\n\nconst {\n  aggregateTwoErrors\x2C\n  codes: {\n    ERR_MULTIPLE_CALLBACK\x2C\n  }\x2C\n  AbortError\x2C\n} = require('internal/errors');\nconst {\n  Symbol\x2C\n} = primordials;\nconst {\n  kIsDestroyed\x2C\n  isDestroyed\x2C\n  isFinished\x2C\n  isServerRequest\x2C\n  kState\x2C\n  kErrorEmitted\x2C\n  kEmitClose\x2C\n  kClosed\x2C\n  kCloseEmitted\x2C\n  kConstructed\x2C\n  kDestroyed\x2C\n  kAutoDestroy\x2C\n  kErrored\x2C\n} = require('internal/streams/utils');\n\nconst kDestroy = Symbol('kDestroy');\nconst kConstruct = Symbol('kConstruct');\n\nfunction checkError(err\x2C w\x2C r) {\n  if (err) {\n    // Avoid V8 leak\x2C https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    err.stack; // eslint-disable-line no-unused-expressions\n\n    if (w && !w.errored) {\n      w.errored = err;\n    }\n    if (r && !r.errored) {\n      r.errored = err;\n    }\n  }\n}\n\n// Backwards compat. cb() is undocumented and unused in core but\n// unfortunately might be used by modules.\nfunction destroy(err\x2C cb) {\n  const r = this._readableState;\n  const w = this._writableState;\n  // With duplex streams we use the writable side for state.\n  const s = w || r;\n\n  if (\n    (w && (w[kState] & kDestroyed) !== 0) ||\n    (r && (r[kState] & kDestroyed) !== 0)\n  ) {\n    if (typeof cb === 'function') {\n      cb();\n    }\n\n    return this;\n  }\n\n\n  // We set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n  checkError(err\x2C w\x2C r);\n\n  if (w) {\n    w[kState] |= kDestroyed;\n  }\n  if (r) {\n    r[kState] |= kDestroyed;\n  }\n\n  // If still constructing then defer calling _destroy.\n  if ((s[kState] & kConstructed) === 0) {\n    this.once(kDestroy\x2C function(er) {\n      _destroy(this\x2C aggregateTwoErrors(er\x2C err)\x2C cb);\n    });\n  } else {\n    _destroy(this\x2C err\x2C cb);\n  }\n\n  return this;\n}\n\nfunction _destroy(self\x2C err\x2C cb) {\n  let called = false;\n\n  function onDestroy(err) {\n    if (called) {\n      return;\n    }\n    called = true;\n\n    const r = self._readableState;\n    const w = self._writableState;\n\n    checkError(err\x2C w\x2C r);\n\n    if (w) {\n      w[kState] |= kClosed;\n    }\n    if (r) {\n      r[kState] |= kClosed;\n    }\n\n    if (typeof cb === 'function') {\n      cb(err);\n    }\n\n    if (err) {\n      process.nextTick(emitErrorCloseNT\x2C self\x2C err);\n    } else {\n      process.nextTick(emitCloseNT\x2C self);\n    }\n  }\n  try {\n    self._destroy(err || null\x2C onDestroy);\n  } catch (err) {\n    onDestroy(err);\n  }\n}\n\nfunction emitErrorCloseNT(self\x2C err) {\n  emitErrorNT(self\x2C err);\n  emitCloseNT(self);\n}\n\nfunction emitCloseNT(self) {\n  const r = self._readableState;\n  const w = self._writableState;\n\n  if (w) {\n    w[kState] |= kCloseEmitted;\n  }\n  if (r) {\n    r[kState] |= kCloseEmitted;\n  }\n\n  if (\n    (w && (w[kState] & kEmitClose) !== 0) ||\n    (r && (r[kState] & kEmitClose) !== 0)\n  ) {\n    self.emit('close');\n  }\n}\n\nfunction emitErrorNT(self\x2C err) {\n  const r = self._readableState;\n  const w = self._writableState;\n\n  if (\n    (w && (w[kState] & kErrorEmitted) !== 0) ||\n    (r && (r[kState] & kErrorEmitted) !== 0)\n  ) {\n    return;\n  }\n\n  if (w) {\n    w[kState] |= kErrorEmitted;\n  }\n  if (r) {\n    r[kState] |= kErrorEmitted;\n  }\n\n  self.emit('error'\x2C err);\n}\n\nfunction undestroy() {\n  const r = this._readableState;\n  const w = this._writableState;\n\n  if (r) {\n    r.constructed = true;\n    r.closed = false;\n    r.closeEmitted = false;\n    r.destroyed = false;\n    r.errored = null;\n    r.errorEmitted = false;\n    r.reading = false;\n    r.ended = r.readable === false;\n    r.endEmitted = r.readable === false;\n  }\n\n  if (w) {\n    w.constructed = true;\n    w.destroyed = false;\n    w.closed = false;\n    w.closeEmitted = false;\n    w.errored = null;\n    w.errorEmitted = false;\n    w.finalCalled = false;\n    w.prefinished = false;\n    w.ended = w.writable === false;\n    w.ending = w.writable === false;\n    w.finished = w.writable === false;\n  }\n}\n\nfunction errorOrDestroy(stream\x2C err\x2C sync) {\n  // We have tests that rely on errors being emitted\n  // in the same tick\x2C so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n\n  const r = stream._readableState;\n  const w = stream._writableState;\n\n  if (\n    (w && (w[kState] ? (w[kState] & kDestroyed) !== 0 : w.destroyed)) ||\n    (r && (r[kState] ? (r[kState] & kDestroyed) !== 0 : r.destroyed))\n  ) {\n    return this;\n  }\n\n  if (\n    (r && (r[kState] & kAutoDestroy) !== 0) ||\n    (w && (w[kState] & kAutoDestroy) !== 0)\n  ) {\n    stream.destroy(err);\n  } else if (err) {\n    // Avoid V8 leak\x2C https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    err.stack; // eslint-disable-line no-unused-expressions\n\n    if (w && (w[kState] & kErrored) === 0) {\n      w.errored = err;\n    }\n    if (r && (r[kState] & kErrored) === 0) {\n      r.errored = err;\n    }\n    if (sync) {\n      process.nextTick(emitErrorNT\x2C stream\x2C err);\n    } else {\n      emitErrorNT(stream\x2C err);\n    }\n  }\n}\n\nfunction construct(stream\x2C cb) {\n  if (typeof stream._construct !== 'function') {\n    return;\n  }\n\n  const r = stream._readableState;\n  const w = stream._writableState;\n\n  if (r) {\n    r[kState] &= ~kConstructed;\n  }\n  if (w) {\n    w[kState] &= ~kConstructed;\n  }\n\n  stream.once(kConstruct\x2C cb);\n\n  if (stream.listenerCount(kConstruct) > 1) {\n    // Duplex\n    return;\n  }\n\n  process.nextTick(constructNT\x2C stream);\n}\n\nfunction constructNT(stream) {\n  let called = false;\n\n  function onConstruct(err) {\n    if (called) {\n      errorOrDestroy(stream\x2C err ?? new ERR_MULTIPLE_CALLBACK());\n      return;\n    }\n    called = true;\n\n    const r = stream._readableState;\n    const w = stream._writableState;\n    const s = w || r;\n\n    if (r) {\n      r[kState] |= kConstructed;\n    }\n    if (w) {\n      w[kState] |= kConstructed;\n    }\n\n    if (s.destroyed) {\n      stream.emit(kDestroy\x2C err);\n    } else if (err) {\n      errorOrDestroy(stream\x2C err\x2C true);\n    } else {\n      process.nextTick(emitConstructNT\x2C stream);\n    }\n  }\n\n  try {\n    stream._construct((err) => {\n      process.nextTick(onConstruct\x2C err);\n    });\n  } catch (err) {\n    process.nextTick(onConstruct\x2C err);\n  }\n}\n\nfunction emitConstructNT(stream) {\n  stream.emit(kConstruct);\n}\n\nfunction isRequest(stream) {\n  return stream?.setHeader && typeof stream.abort === 'function';\n}\n\nfunction emitCloseLegacy(stream) {\n  stream.emit('close');\n}\n\nfunction emitErrorCloseLegacy(stream\x2C err) {\n  stream.emit('error'\x2C err);\n  process.nextTick(emitCloseLegacy\x2C stream);\n}\n\n// Normalize destroy for legacy.\nfunction destroyer(stream\x2C err) {\n  if (!stream || isDestroyed(stream)) {\n    return;\n  }\n\n  if (!err && !isFinished(stream)) {\n    err = new AbortError();\n  }\n\n  // TODO: Remove isRequest branches.\n  if (isServerRequest(stream)) {\n    stream.socket = null;\n    stream.destroy(err);\n  } else if (isRequest(stream)) {\n    stream.abort();\n  } else if (isRequest(stream.req)) {\n    stream.req.abort();\n  } else if (typeof stream.destroy === 'function') {\n    stream.destroy(err);\n  } else if (typeof stream.close === 'function') {\n    // TODO: Don't lose err?\n    stream.close();\n  } else if (err) {\n    process.nextTick(emitErrorCloseLegacy\x2C stream\x2C err);\n  } else {\n    process.nextTick(emitCloseLegacy\x2C stream);\n  }\n\n  if (!stream.destroyed) {\n    stream[kIsDestroyed] = true;\n  }\n}\n\nmodule.exports = {\n  construct\x2C\n  destroyer\x2C\n  destroy\x2C\n  undestroy\x2C\n  errorOrDestroy\x2C\n};\n
code-source-info,0x31e6f25f4c2e,99,0,7437,C0O0C4O7437,,
code-creation,JS,10,99815,0x31e6f25f539e,332, node:internal/streams/destroy:1:1,0x31e6f25f4ba8,~
code-source-info,0x31e6f25f539e,99,0,7437,C0O0C149O106C152O106C157O25C163O54C168O60C174O90C180O144C185O372C188O372C193O179C199O195C205O210C211O224C217O243C223O253C229O270C235O284C241O295C247O312C253O328C259O342C265O358C271O425C274O425C278O425C280O464C283O464C287O464C289O7347C296O7368C302O7381C308O7394C314O7405C320O7418C326O7362C331O7436,,
tick,0x10c88f2e0,99917,0,0x0,0,0x10c66acb0,0x31e6f25f54c6,0x112583feb,0x112583ca1,0x31e6f25f340a,0x112583feb,0x112583ca1,0x31e6f25f1c60,0x112583feb,0x112583ca1,0x31e6f25e4346,0x112583feb,0x112583ca1,0x31e6f25e22c3,0x112583feb,0x112583ca1,0x31e6f25df4ab,0x112583feb,0x112583ca1,0x31e6f25da395,0x112583feb,0x112583ca1,0x31e6f25d7289,0x112583feb,0x31e6f25d6c7a,0x31e6f25d6880,0x31e6f6b607cb,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f25d543c,0x31e6f6b7a501,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,Eval,10,100052,0x31e6f25f69ee,5, node:internal/streams/duplex:1:1,0x31e6f25f67f8,~
script-source,100,node:internal/streams/duplex,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototype inheritance\x2C this class\n// prototypically inherits from Readable\x2C and then parasitically from\n// Writable.\n\n'use strict';\n\nconst {\n  ObjectDefineProperties\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectKeys\x2C\n  ObjectSetPrototypeOf\x2C\n} = primordials;\n\nmodule.exports = Duplex;\n\nconst Stream = require('internal/streams/legacy').Stream;\nconst Readable = require('internal/streams/readable');\nconst Writable = require('internal/streams/writable');\n\nconst {\n  addAbortSignal\x2C\n} = require('internal/streams/add-abort-signal');\n\nconst destroyImpl = require('internal/streams/destroy');\nconst { kOnConstructed } = require('internal/streams/utils');\n\nObjectSetPrototypeOf(Duplex.prototype\x2C Readable.prototype);\nObjectSetPrototypeOf(Duplex\x2C Readable);\n\n{\n  const keys = ObjectKeys(Writable.prototype);\n  // Allow the keys array to be GC'ed.\n  for (let i = 0; i < keys.length; i++) {\n    const method = keys[i];\n    if (!Duplex.prototype[method])\n      Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  this._events ??= {\n    close: undefined\x2C\n    error: undefined\x2C\n    prefinish: undefined\x2C\n    finish: undefined\x2C\n    drain: undefined\x2C\n    data: undefined\x2C\n    end: undefined\x2C\n    readable: undefined\x2C\n    // Skip uncommon events...\n    // pause: undefined\x2C\n    // resume: undefined\x2C\n    // pipe: undefined\x2C\n    // unpipe: undefined\x2C\n    // [destroyImpl.kConstruct]: undefined\x2C\n    // [destroyImpl.kDestroy]: undefined\x2C\n  };\n\n  this._readableState = new Readable.ReadableState(options\x2C this\x2C true);\n  this._writableState = new Writable.WritableState(options\x2C this\x2C true);\n\n  if (options) {\n    this.allowHalfOpen = options.allowHalfOpen !== false;\n\n    if (options.readable === false) {\n      this._readableState.readable = false;\n      this._readableState.ended = true;\n      this._readableState.endEmitted = true;\n    }\n\n    if (options.writable === false) {\n      this._writableState.writable = false;\n      this._writableState.ending = true;\n      this._writableState.ended = true;\n      this._writableState.finished = true;\n    }\n\n    if (typeof options.read === 'function')\n      this._read = options.read;\n\n    if (typeof options.write === 'function')\n      this._write = options.write;\n\n    if (typeof options.writev === 'function')\n      this._writev = options.writev;\n\n    if (typeof options.destroy === 'function')\n      this._destroy = options.destroy;\n\n    if (typeof options.final === 'function')\n      this._final = options.final;\n\n    if (typeof options.construct === 'function')\n      this._construct = options.construct;\n\n    if (options.signal)\n      addAbortSignal(options.signal\x2C this);\n  } else {\n    this.allowHalfOpen = true;\n  }\n\n  Stream.call(this\x2C options);\n\n  if (this._construct != null) {\n    destroyImpl.construct(this\x2C () => {\n      this._readableState[kOnConstructed](this);\n      this._writableState[kOnConstructed](this);\n    });\n  }\n}\n\nObjectDefineProperties(Duplex.prototype\x2C {\n  writable:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writable') }\x2C\n  writableHighWaterMark:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableHighWaterMark') }\x2C\n  writableObjectMode:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableObjectMode') }\x2C\n  writableBuffer:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableBuffer') }\x2C\n  writableLength:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableLength') }\x2C\n  writableFinished:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableFinished') }\x2C\n  writableCorked:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableCorked') }\x2C\n  writableEnded:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableEnded') }\x2C\n  writableNeedDrain:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableNeedDrain') }\x2C\n\n  destroyed: {\n    __proto__: null\x2C\n    get() {\n      if (this._readableState === undefined ||\n        this._writableState === undefined) {\n        return false;\n      }\n      return this._readableState.destroyed && this._writableState.destroyed;\n    }\x2C\n    set(value) {\n      // Backward compatibility\x2C the user is explicitly\n      // managing destroyed.\n      if (this._readableState && this._writableState) {\n        this._readableState.destroyed = value;\n        this._writableState.destroyed = value;\n      }\n    }\x2C\n  }\x2C\n});\n\nlet webStreamsAdapters;\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined)\n    webStreamsAdapters = require('internal/webstreams/adapters');\n  return webStreamsAdapters;\n}\n\nDuplex.fromWeb = function(pair\x2C options) {\n  return lazyWebStreams().newStreamDuplexFromReadableWritablePair(\n    pair\x2C\n    options);\n};\n\nDuplex.toWeb = function(duplex) {\n  return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);\n};\n\nlet duplexify;\n\nDuplex.from = function(body) {\n  if (!duplexify) {\n    duplexify = require('internal/streams/duplexify');\n  }\n  return duplexify(body\x2C 'body');\n};\n
code-source-info,0x31e6f25f69ee,100,0,6489,C0O0C4O6489,,
code-creation,JS,10,100443,0x31e6f25f709e,679, node:internal/streams/duplex:1:1,0x31e6f25f6968,~
code-source-info,0x31e6f25f709e,100,0,6489,C0O0C45O1383C50O1409C55O1443C60O1457C65O1497C67O1512C71O1538C77O1538C82O1572C86O1538C88O1598C94O1598C98O1598C100O1653C106O1653C110O1653C112O1722C118O1722C123O1702C129O1789C135O1789C139O1789C141O1853C147O1853C152O1834C158O1889C161O1917C169O1937C174O1889C179O1949C185O1949C190O2007C193O2027C198O2007C203O2093C205O2105C209O2098C214O2139C216O2143C220O2152C223O2164C230O2173C235O2189C238O2196C246O2225C253O2234C256O2214C260O2114C265O2080C269O4216C272O4246C282O4275C290O4337C299O4297C318O4392C326O4454C335O4414C354O4519C362O4581C371O4541C390O4639C398O4701C407O4661C426O4755C434O4817C443O4777C462O4873C470O4935C479O4895C498O4991C506O5053C515O5013C534O5106C542O5168C551O5128C570O5224C578O5286C587O5246C606O5335C611O5362C619O5580C633O4216C638O5857C639O5857C641O6081C648O6096C652O6219C659O6232C663O6330C664O6330C666O6342C673O6354C678O6488,,
code-creation,Eval,10,100623,0x31e6f25f7efe,5, node:internal/streams/legacy:1:1,0x31e6f25f7d88,~
script-source,101,node:internal/streams/legacy,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ObjectSetPrototypeOf\x2C\n} = primordials;\n\nconst EE = require('events');\n\nfunction Stream(opts) {\n  EE.call(this\x2C opts);\n}\nObjectSetPrototypeOf(Stream.prototype\x2C EE.prototype);\nObjectSetPrototypeOf(Stream\x2C EE);\n\nStream.prototype.pipe = function(dest\x2C options) {\n  const source = this;\n\n  function ondata(chunk) {\n    if (dest.writable && dest.write(chunk) === false && source.pause) {\n      source.pause();\n    }\n  }\n\n  source.on('data'\x2C ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain'\x2C ondrain);\n\n  // If the 'end' option is not supplied\x2C dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end'\x2C onend);\n    source.on('close'\x2C onclose);\n  }\n\n  let didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // Don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this\x2C 'error') === 0) {\n      this.emit('error'\x2C er);\n    }\n  }\n\n  prependListener(source\x2C 'error'\x2C onerror);\n  prependListener(dest\x2C 'error'\x2C onerror);\n\n  // Remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data'\x2C ondata);\n    dest.removeListener('drain'\x2C ondrain);\n\n    source.removeListener('end'\x2C onend);\n    source.removeListener('close'\x2C onclose);\n\n    source.removeListener('error'\x2C onerror);\n    dest.removeListener('error'\x2C onerror);\n\n    source.removeListener('end'\x2C cleanup);\n    source.removeListener('close'\x2C cleanup);\n\n    dest.removeListener('close'\x2C cleanup);\n  }\n\n  source.on('end'\x2C cleanup);\n  source.on('close'\x2C cleanup);\n\n  dest.on('close'\x2C cleanup);\n  dest.emit('pipe'\x2C source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\nfunction prependListener(emitter\x2C event\x2C fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function')\n    return emitter.prependListener(event\x2C fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event])\n    emitter.on(event\x2C fn);\n  else if (ArrayIsArray(emitter._events[event]))\n    emitter._events[event].unshift(fn);\n  else\n    emitter._events[event] = [fn\x2C emitter._events[event]];\n}\n\nmodule.exports = { Stream\x2C prependListener };\n
code-source-info,0x31e6f25f7efe,101,0,2934,C0O0C4O2934,,
code-creation,JS,10,100818,0x31e6f25f8186,106, node:internal/streams/legacy:1:1,0x31e6f25f7e78,~
code-source-info,0x31e6f25f8186,101,0,2934,C0O0C22O25C28O41C33O92C36O92C40O92C42O189C50O203C55O161C60O215C63O215C68O257C77O272C81O2888C88O2907C94O2915C100O2903C105O2933,,
tick,0x10c964b44,101104,1,0x10c1e6120,2,0x10c41e000,0x112583f26,0x112583ca1,0x31e6f25f70fc,0x112583feb,0x112583ca1,0x31e6f25f3416,0x112583feb,0x112583ca1,0x31e6f25f1c60,0x112583feb,0x112583ca1,0x31e6f25e4346,0x112583feb,0x112583ca1,0x31e6f25e22c3,0x112583feb,0x112583ca1,0x31e6f25df4ab,0x112583feb,0x112583ca1,0x31e6f25da395,0x112583feb,0x112583ca1,0x31e6f25d7289,0x112583feb,0x31e6f25d6c7a,0x31e6f25d6880,0x31e6f6b607cb,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f25d543c,0x31e6f6b7a501,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
new,MemoryChunk,0x31e6451c0000,262144
code-creation,Eval,10,101693,0x31e6f25fadfe,5, node:internal/streams/readable:1:1,0x31e6f25f9980,~
script-source,102,node:internal/streams/readable,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeIndexOf\x2C\n  NumberIsInteger\x2C\n  NumberIsNaN\x2C\n  NumberParseInt\x2C\n  ObjectDefineProperties\x2C\n  ObjectKeys\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  SafeSet\x2C\n  Symbol\x2C\n  SymbolAsyncDispose\x2C\n  SymbolAsyncIterator\x2C\n  SymbolSpecies\x2C\n  TypedArrayPrototypeSet\x2C\n} = primordials;\n\nmodule.exports = Readable;\nReadable.ReadableState = ReadableState;\n\nconst EE = require('events');\nconst { Stream\x2C prependListener } = require('internal/streams/legacy');\nconst { Buffer } = require('buffer');\n\nconst {\n  addAbortSignal\x2C\n} = require('internal/streams/add-abort-signal');\nconst eos = require('internal/streams/end-of-stream');\n\nlet debug = require('internal/util/debuglog').debuglog('stream'\x2C (fn) => {\n  debug = fn;\n});\nconst destroyImpl = require('internal/streams/destroy');\nconst {\n  getHighWaterMark\x2C\n  getDefaultHighWaterMark\x2C\n} = require('internal/streams/state');\nconst {\n  kState\x2C\n  // bitfields\n  kObjectMode\x2C\n  kErrorEmitted\x2C\n  kAutoDestroy\x2C\n  kEmitClose\x2C\n  kDestroyed\x2C\n  kClosed\x2C\n  kCloseEmitted\x2C\n  kErrored\x2C\n  kConstructed\x2C\n  kOnConstructed\x2C\n} = require('internal/streams/utils');\n\nconst {\n  aggregateTwoErrors\x2C\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_METHOD_NOT_IMPLEMENTED\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_STREAM_PUSH_AFTER_EOF\x2C\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT\x2C\n    ERR_UNKNOWN_ENCODING\x2C\n  }\x2C\n  AbortError\x2C\n} = require('internal/errors');\nconst { validateObject } = require('internal/validators');\n\nconst FastBuffer = Buffer[SymbolSpecies];\n\nconst { StringDecoder } = require('string_decoder');\nconst from = require('internal/streams/from');\n\nObjectSetPrototypeOf(Readable.prototype\x2C Stream.prototype);\nObjectSetPrototypeOf(Readable\x2C Stream);\nconst nop = () => {};\n\nconst { errorOrDestroy } = destroyImpl;\n\nconst kErroredValue = Symbol('kErroredValue');\nconst kDefaultEncodingValue = Symbol('kDefaultEncodingValue');\nconst kDecoderValue = Symbol('kDecoderValue');\nconst kEncodingValue = Symbol('kEncodingValue');\n\nconst kEnded = 1 << 9;\nconst kEndEmitted = 1 << 10;\nconst kReading = 1 << 11;\nconst kSync = 1 << 12;\nconst kNeedReadable = 1 << 13;\nconst kEmittedReadable = 1 << 14;\nconst kReadableListening = 1 << 15;\nconst kResumeScheduled = 1 << 16;\nconst kMultiAwaitDrain = 1 << 17;\nconst kReadingMore = 1 << 18;\nconst kDataEmitted = 1 << 19;\nconst kDefaultUTF8Encoding = 1 << 20;\nconst kDecoder = 1 << 21;\nconst kEncoding = 1 << 22;\nconst kHasFlowing = 1 << 23;\nconst kFlowing = 1 << 24;\nconst kHasPaused = 1 << 25;\nconst kPaused = 1 << 26;\nconst kDataListening = 1 << 27;\n\n// TODO(benjamingr) it is likely slower to do it this way than with free functions\nfunction makeBitMapDescriptor(bit) {\n  return {\n    enumerable: false\x2C\n    get() { return (this[kState] & bit) !== 0; }\x2C\n    set(value) {\n      if (value) this[kState] |= bit;\n      else this[kState] &= ~bit;\n    }\x2C\n  };\n}\nObjectDefineProperties(ReadableState.prototype\x2C {\n  objectMode: makeBitMapDescriptor(kObjectMode)\x2C\n  ended: makeBitMapDescriptor(kEnded)\x2C\n  endEmitted: makeBitMapDescriptor(kEndEmitted)\x2C\n  reading: makeBitMapDescriptor(kReading)\x2C\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in\x2C therefore we start as\n  // constructed.\n  constructed: makeBitMapDescriptor(kConstructed)\x2C\n  // A flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately\x2C or on a later tick.  We set this to true at first\x2C because\n  // any actions that shouldn't happen until "later" should generally also\n  // not happen before the first read call.\n  sync: makeBitMapDescriptor(kSync)\x2C\n  // Whenever we return null\x2C then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  needReadable: makeBitMapDescriptor(kNeedReadable)\x2C\n  emittedReadable: makeBitMapDescriptor(kEmittedReadable)\x2C\n  readableListening: makeBitMapDescriptor(kReadableListening)\x2C\n  resumeScheduled: makeBitMapDescriptor(kResumeScheduled)\x2C\n  // True if the error was already emitted and should not be thrown again.\n  errorEmitted: makeBitMapDescriptor(kErrorEmitted)\x2C\n  emitClose: makeBitMapDescriptor(kEmitClose)\x2C\n  autoDestroy: makeBitMapDescriptor(kAutoDestroy)\x2C\n  // Has it been destroyed.\n  destroyed: makeBitMapDescriptor(kDestroyed)\x2C\n  // Indicates whether the stream has finished destroying.\n  closed: makeBitMapDescriptor(kClosed)\x2C\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  closeEmitted: makeBitMapDescriptor(kCloseEmitted)\x2C\n  multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain)\x2C\n  // If true\x2C a maybeReadMore has been scheduled.\n  readingMore: makeBitMapDescriptor(kReadingMore)\x2C\n  dataEmitted: makeBitMapDescriptor(kDataEmitted)\x2C\n\n  // Indicates whether the stream has errored. When true no further\n  // _read calls\x2C 'data' or 'readable' events should occur. This is needed\n  // since when autoDestroy is disabled we need a way to tell whether the\n  // stream has failed.\n  errored: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() {\n      return (this[kState] & kErrored) !== 0 ? this[kErroredValue] : null;\n    }\x2C\n    set(value) {\n      if (value) {\n        this[kErroredValue] = value;\n        this[kState] |= kErrored;\n      } else {\n        this[kState] &= ~kErrored;\n      }\n    }\x2C\n  }\x2C\n\n  defaultEncoding: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() { return (this[kState] & kDefaultUTF8Encoding) !== 0 ? 'utf8' : this[kDefaultEncodingValue]; }\x2C\n    set(value) {\n      if (value === 'utf8' || value === 'utf-8') {\n        this[kState] |= kDefaultUTF8Encoding;\n      } else {\n        this[kState] &= ~kDefaultUTF8Encoding;\n        this[kDefaultEncodingValue] = value;\n      }\n    }\x2C\n  }\x2C\n\n  decoder: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() {\n      return (this[kState] & kDecoder) !== 0 ? this[kDecoderValue] : null;\n    }\x2C\n    set(value) {\n      if (value) {\n        this[kDecoderValue] = value;\n        this[kState] |= kDecoder;\n      } else {\n        this[kState] &= ~kDecoder;\n      }\n    }\x2C\n  }\x2C\n\n  encoding: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() {\n      return (this[kState] & kEncoding) !== 0 ? this[kEncodingValue] : null;\n    }\x2C\n    set(value) {\n      if (value) {\n        this[kEncodingValue] = value;\n        this[kState] |= kEncoding;\n      } else {\n        this[kState] &= ~kEncoding;\n      }\n    }\x2C\n  }\x2C\n\n  flowing: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() {\n      return (this[kState] & kHasFlowing) !== 0 ? (this[kState] & kFlowing) !== 0 : null;\n    }\x2C\n    set(value) {\n      if (value == null) {\n        this[kState] &= ~(kHasFlowing | kFlowing);\n      } else if (value) {\n        this[kState] |= (kHasFlowing | kFlowing);\n      } else {\n        this[kState] |= kHasFlowing;\n        this[kState] &= ~kFlowing;\n      }\n    }\x2C\n  }\x2C\n});\n\n\nfunction ReadableState(options\x2C stream\x2C isDuplex) {\n  // Bit map field to store ReadableState more effciently with 1 bit per field\n  // instead of a V8 slot per field.\n  this[kState] = kEmitClose | kAutoDestroy | kConstructed | kSync;\n\n  // Object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away.\n  if (options && options.objectMode)\n    this[kState] |= kObjectMode;\n\n  if (isDuplex && options && options.readableObjectMode)\n    this[kState] |= kObjectMode;\n\n  // The point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value\x2C means "don't call _read preemptively ever"\n  this.highWaterMark = options ?\n    getHighWaterMark(this\x2C options\x2C 'readableHighWaterMark'\x2C isDuplex) :\n    getDefaultHighWaterMark(false);\n\n  this.buffer = [];\n  this.bufferIndex = 0;\n  this.length = 0;\n  this.pipes = [];\n\n  // Should close be emitted on destroy. Defaults to true.\n  if (options && options.emitClose === false) this[kState] &= ~kEmitClose;\n\n  // Should .destroy() be called after 'end' (and potentially 'finish').\n  if (options && options.autoDestroy === false) this[kState] &= ~kAutoDestroy;\n\n  // Crypto is kind of old and crusty.  Historically\x2C its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8'\x2C though.\n  const defaultEncoding = options?.defaultEncoding;\n  if (defaultEncoding == null || defaultEncoding === 'utf8' || defaultEncoding === 'utf-8') {\n    this[kState] |= kDefaultUTF8Encoding;\n  } else if (Buffer.isEncoding(defaultEncoding)) {\n    this.defaultEncoding = defaultEncoding;\n  } else {\n    throw new ERR_UNKNOWN_ENCODING(defaultEncoding);\n  }\n\n  // Ref the piped dest which we need a drain event on it\n  // type: null | Writable | Set<Writable>.\n  this.awaitDrainWriters = null;\n\n  if (options && options.encoding) {\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nReadableState.prototype[kOnConstructed] = function onConstructed(stream) {\n  if ((this[kState] & kNeedReadable) !== 0) {\n    maybeReadMore(stream\x2C this);\n  }\n};\n\nfunction Readable(options) {\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._events ??= {\n    close: undefined\x2C\n    error: undefined\x2C\n    data: undefined\x2C\n    end: undefined\x2C\n    readable: undefined\x2C\n    // Skip uncommon events...\n    // pause: undefined\x2C\n    // resume: undefined\x2C\n    // pipe: undefined\x2C\n    // unpipe: undefined\x2C\n    // [destroyImpl.kConstruct]: undefined\x2C\n    // [destroyImpl.kDestroy]: undefined\x2C\n  };\n\n  this._readableState = new ReadableState(options\x2C this\x2C false);\n\n  if (options) {\n    if (typeof options.read === 'function')\n      this._read = options.read;\n\n    if (typeof options.destroy === 'function')\n      this._destroy = options.destroy;\n\n    if (typeof options.construct === 'function')\n      this._construct = options.construct;\n\n    if (options.signal)\n      addAbortSignal(options.signal\x2C this);\n  }\n\n  Stream.call(this\x2C options);\n\n  if (this._construct != null) {\n    destroyImpl.construct(this\x2C () => {\n      this._readableState[kOnConstructed](this);\n    });\n  }\n}\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function(err\x2C cb) {\n  cb(err);\n};\n\nReadable.prototype[EE.captureRejectionSymbol] = function(err) {\n  this.destroy(err);\n};\n\nReadable.prototype[SymbolAsyncDispose] = function() {\n  let error;\n  if (!this.destroyed) {\n    error = this.readableEnded ? null : new AbortError();\n    this.destroy(error);\n  }\n  return new Promise((resolve\x2C reject) => eos(this\x2C (err) => (err && err !== error ? reject(err) : resolve(null))));\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet\x2C\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk\x2C encoding) {\n  debug('push'\x2C chunk);\n\n  const state = this._readableState;\n  return (state[kState] & kObjectMode) === 0 ?\n    readableAddChunkPushByteMode(this\x2C state\x2C chunk\x2C encoding) :\n    readableAddChunkPushObjectMode(this\x2C state\x2C chunk\x2C encoding);\n};\n\n// Unshift should *always* be something directly out of read().\nReadable.prototype.unshift = function(chunk\x2C encoding) {\n  debug('unshift'\x2C chunk);\n  const state = this._readableState;\n  return (state[kState] & kObjectMode) === 0 ?\n    readableAddChunkUnshiftByteMode(this\x2C state\x2C chunk\x2C encoding) :\n    readableAddChunkUnshiftObjectMode(this\x2C state\x2C chunk);\n};\n\n\nfunction readableAddChunkUnshiftByteMode(stream\x2C state\x2C chunk\x2C encoding) {\n  if (chunk === null) {\n    state[kState] &= ~kReading;\n    onEofChunk(stream\x2C state);\n\n    return false;\n  }\n\n  if (typeof chunk === 'string') {\n    encoding = encoding || state.defaultEncoding;\n    if (state.encoding !== encoding) {\n      if (state.encoding) {\n        // When unshifting\x2C if state.encoding is set\x2C we have to save\n        // the string in the BufferList with the state encoding.\n        chunk = Buffer.from(chunk\x2C encoding).toString(state.encoding);\n      } else {\n        chunk = Buffer.from(chunk\x2C encoding);\n      }\n    }\n  } else if (Stream._isUint8Array(chunk)) {\n    chunk = Stream._uint8ArrayToBuffer(chunk);\n  } else if (chunk !== undefined && !(chunk instanceof Buffer)) {\n    errorOrDestroy(stream\x2C new ERR_INVALID_ARG_TYPE(\n      'chunk'\x2C ['string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C chunk));\n    return false;\n  }\n\n\n  if (!(chunk && chunk.length > 0)) {\n    return canPushMore(state);\n  }\n\n  return readableAddChunkUnshiftValue(stream\x2C state\x2C chunk);\n}\n\nfunction readableAddChunkUnshiftObjectMode(stream\x2C state\x2C chunk) {\n  if (chunk === null) {\n    state[kState] &= ~kReading;\n    onEofChunk(stream\x2C state);\n\n    return false;\n  }\n\n  return readableAddChunkUnshiftValue(stream\x2C state\x2C chunk);\n}\n\nfunction readableAddChunkUnshiftValue(stream\x2C state\x2C chunk) {\n  if ((state[kState] & kEndEmitted) !== 0)\n    errorOrDestroy(stream\x2C new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());\n  else if ((state[kState] & (kDestroyed | kErrored)) !== 0)\n    return false;\n  else\n    addChunk(stream\x2C state\x2C chunk\x2C true);\n\n  return canPushMore(state);\n}\n\nfunction readableAddChunkPushByteMode(stream\x2C state\x2C chunk\x2C encoding) {\n  if (chunk === null) {\n    state[kState] &= ~kReading;\n    onEofChunk(stream\x2C state);\n    return false;\n  }\n\n  if (typeof chunk === 'string') {\n    encoding = encoding || state.defaultEncoding;\n    if (state.encoding !== encoding) {\n      chunk = Buffer.from(chunk\x2C encoding);\n      encoding = '';\n    }\n  } else if (chunk instanceof Buffer) {\n    encoding = '';\n  } else if (Stream._isUint8Array(chunk)) {\n    chunk = Stream._uint8ArrayToBuffer(chunk);\n    encoding = '';\n  } else if (chunk !== undefined) {\n    errorOrDestroy(stream\x2C new ERR_INVALID_ARG_TYPE(\n      'chunk'\x2C ['string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C chunk));\n    return false;\n  }\n\n  if (!chunk || chunk.length <= 0) {\n    state[kState] &= ~kReading;\n    maybeReadMore(stream\x2C state);\n\n    return canPushMore(state);\n  }\n\n  if ((state[kState] & kEnded) !== 0) {\n    errorOrDestroy(stream\x2C new ERR_STREAM_PUSH_AFTER_EOF());\n    return false;\n  }\n\n  if ((state[kState] & (kDestroyed | kErrored)) !== 0) {\n    return false;\n  }\n\n  state[kState] &= ~kReading;\n  if ((state[kState] & kDecoder) !== 0 && !encoding) {\n    chunk = state[kDecoderValue].write(chunk);\n    if (chunk.length === 0) {\n      maybeReadMore(stream\x2C state);\n      return canPushMore(state);\n    }\n  }\n\n  addChunk(stream\x2C state\x2C chunk\x2C false);\n  return canPushMore(state);\n}\n\nfunction readableAddChunkPushObjectMode(stream\x2C state\x2C chunk\x2C encoding) {\n  if (chunk === null) {\n    state[kState] &= ~kReading;\n    onEofChunk(stream\x2C state);\n    return false;\n  }\n\n  if ((state[kState] & kEnded) !== 0) {\n    errorOrDestroy(stream\x2C new ERR_STREAM_PUSH_AFTER_EOF());\n    return false;\n  }\n\n  if ((state[kState] & (kDestroyed | kErrored)) !== 0) {\n    return false;\n  }\n\n  state[kState] &= ~kReading;\n\n  if ((state[kState] & kDecoder) !== 0 && !encoding) {\n    chunk = state[kDecoderValue].write(chunk);\n  }\n\n  addChunk(stream\x2C state\x2C chunk\x2C false);\n  return canPushMore(state);\n}\n\nfunction canPushMore(state) {\n  // We can push more data if we are below the highWaterMark.\n  // Also\x2C if we have no data yet\x2C we can stand some more bytes.\n  // This is to work around cases where hwm=0\x2C such as the repl.\n  return (state[kState] & kEnded) === 0 &&\n    (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream\x2C state\x2C chunk\x2C addToFront) {\n  if ((state[kState] & (kFlowing | kSync | kDataListening)) === (kFlowing | kDataListening) && state.length === 0) {\n    // Use the guard to avoid creating `Set()` repeatedly\n    // when we have multiple pipes.\n    if ((state[kState] & kMultiAwaitDrain) !== 0) {\n      state.awaitDrainWriters.clear();\n    } else {\n      state.awaitDrainWriters = null;\n    }\n\n    state[kState] |= kDataEmitted;\n    stream.emit('data'\x2C chunk);\n  } else {\n    // Update the buffer info.\n    state.length += (state[kState] & kObjectMode) !== 0 ? 1 : chunk.length;\n    if (addToFront) {\n      if (state.bufferIndex > 0) {\n        state.buffer[--state.bufferIndex] = chunk;\n      } else {\n        state.buffer.unshift(chunk); // Slow path\n      }\n    } else {\n      state.buffer.push(chunk);\n    }\n\n    if ((state[kState] & kNeedReadable) !== 0)\n      emitReadable(stream);\n  }\n  maybeReadMore(stream\x2C state);\n}\n\nReadable.prototype.isPaused = function() {\n  const state = this._readableState;\n  return (state[kState] & kPaused) !== 0 || (state[kState] & (kHasFlowing | kFlowing)) === kHasFlowing;\n};\n\n// Backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  const state = this._readableState;\n\n  const decoder = new StringDecoder(enc);\n  state.decoder = decoder;\n  // If setEncoding(null)\x2C decoder.encoding equals utf8.\n  state.encoding = state.decoder.encoding;\n\n  // Iterate over current buffer to convert already stored Buffers:\n  let content = '';\n  for (const data of state.buffer.slice(state.bufferIndex)) {\n    content += decoder.write(data);\n  }\n  state.buffer.length = 0;\n  state.bufferIndex = 0;\n\n  if (content !== '')\n    state.buffer.push(content);\n  state.length = content.length;\n  return this;\n};\n\n// Don't raise the hwm > 1GB.\nconst MAX_HWM = 0x40000000;\nfunction computeNewHighWaterMark(n) {\n  if (n > MAX_HWM) {\n    throw new ERR_OUT_OF_RANGE('size'\x2C '<= 1GiB'\x2C n);\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts.\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable\x2C so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n\x2C state) {\n  if (n <= 0 || (state.length === 0 && (state[kState] & kEnded) !== 0))\n    return 0;\n  if ((state[kState] & kObjectMode) !== 0)\n    return 1;\n  if (NumberIsNaN(n)) {\n    // Only flow one buffer at a time.\n    if ((state[kState] & kFlowing) !== 0 && state.length)\n      return state.buffer[state.bufferIndex].length;\n    return state.length;\n  }\n  if (n <= state.length)\n    return n;\n  return (state[kState] & kEnded) !== 0 ? state.length : 0;\n}\n\n// You can override either this method\x2C or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  debug('read'\x2C n);\n  // Same as parseInt(undefined\x2C 10)\x2C however V8 7.3 performance regressed\n  // in this scenario\x2C so we are doing it manually.\n  if (n === undefined) {\n    n = NaN;\n  } else if (!NumberIsInteger(n)) {\n    n = NumberParseInt(n\x2C 10);\n  }\n  const state = this._readableState;\n  const nOrig = n;\n\n  // If we're asking for more than the current hwm\x2C then raise the hwm.\n  if (n > state.highWaterMark)\n    state.highWaterMark = computeNewHighWaterMark(n);\n\n  if (n !== 0)\n    state[kState] &= ~kEmittedReadable;\n\n  // If we're doing read(0) to trigger a readable event\x2C but we\n  // already have a bunch of data in the buffer\x2C then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      (state[kState] & kNeedReadable) !== 0 &&\n      ((state.highWaterMark !== 0 ?\n        state.length >= state.highWaterMark :\n        state.length > 0) ||\n       (state[kState] & kEnded) !== 0)) {\n    debug('read: emitReadable');\n    if (state.length === 0 && (state[kState] & kEnded) !== 0)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n\x2C state);\n\n  // If we've ended\x2C and we're now clear\x2C then finish it up.\n  if (n === 0 && (state[kState] & kEnded) !== 0) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases\x2C such as passthrough streams\x2C _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer\x2C providing enough data when\n  // before there was *not* enough.\n  //\n  // So\x2C the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read\x2C then call _read.\n  // Note that this may be asynchronous\x2C or synchronous.  Yes\x2C it is\n  // deeply ugly to write APIs this way\x2C but that still doesn't mean\n  // that the Readable class should behave improperly\x2C as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie\x2C if the read call\n  // has returned yet)\x2C so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event\x2C then we need to do some reading.\n  let doRead = (state[kState] & kNeedReadable) !== 0;\n  debug('need readable'\x2C doRead);\n\n  // If we currently have less than the highWaterMark\x2C then also read some.\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark'\x2C doRead);\n  }\n\n  // However\x2C if we've ended\x2C then there's no point\x2C if we're already\n  // reading\x2C then it's unnecessary\x2C if we're constructing we have to wait\x2C\n  // and if we're destroyed or errored\x2C then it's not allowed\x2C\n  if ((state[kState] & (kReading | kEnded | kDestroyed | kErrored | kConstructed)) !== kConstructed) {\n    doRead = false;\n    debug('reading\x2C ended or constructing'\x2C doRead);\n  } else if (doRead) {\n    debug('do read');\n    state[kState] |= kReading | kSync;\n    // If the length is currently zero\x2C then we *need* a readable event.\n    if (state.length === 0)\n      state[kState] |= kNeedReadable;\n\n    // Call internal read method\n    try {\n      this._read(state.highWaterMark);\n    } catch (err) {\n      errorOrDestroy(this\x2C err);\n    }\n    state[kState] &= ~kSync;\n\n    // If _read pushed data synchronously\x2C then `reading` will be false\x2C\n    // and we need to re-evaluate how much data we can return to the user.\n    if ((state[kState] & kReading) === 0)\n      n = howMuchToRead(nOrig\x2C state);\n  }\n\n  let ret;\n  if (n > 0)\n    ret = fromList(n\x2C state);\n  else\n    ret = null;\n\n  if (ret === null) {\n    state[kState] |= state.length <= state.highWaterMark ? kNeedReadable : 0;\n    n = 0;\n  } else {\n    state.length -= n;\n    if ((state[kState] & kMultiAwaitDrain) !== 0) {\n      state.awaitDrainWriters.clear();\n    } else {\n      state.awaitDrainWriters = null;\n    }\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer\x2C then we want to know\n    // as soon as we *do* get something into the buffer.\n    if ((state[kState] & kEnded) === 0)\n      state[kState] |= kNeedReadable;\n\n    // If we tried to read() past the EOF\x2C then emit end on the next tick.\n    if (nOrig !== n && (state[kState] & kEnded) !== 0)\n      endReadable(this);\n  }\n\n  if (ret !== null && (state[kState] & (kErrorEmitted | kCloseEmitted)) === 0) {\n    state[kState] |= kDataEmitted;\n    this.emit('data'\x2C ret);\n  }\n\n  return ret;\n};\n\nfunction onEofChunk(stream\x2C state) {\n  debug('onEofChunk');\n  if ((state[kState] & kEnded) !== 0) return;\n  const decoder = (state[kState] & kDecoder) !== 0 ? state[kDecoderValue] : null;\n  if (decoder) {\n    const chunk = decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += (state[kState] & kObjectMode) !== 0 ? 1 : chunk.length;\n    }\n  }\n  state[kState] |= kEnded;\n\n  if ((state[kState] & kSync) !== 0) {\n    // If we are sync\x2C wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call.\n    emitReadable(stream);\n  } else {\n    // Emit 'readable' now to make sure it gets picked up.\n    state[kState] &= ~kNeedReadable;\n    state[kState] |= kEmittedReadable;\n    // We have to emit readable now that we are EOF. Modules\n    // in the ecosystem (e.g. dicer) rely on this event being sync.\n    emitReadable_(stream);\n  }\n}\n\n// Don't emit readable right away in sync mode\x2C because this can trigger\n// another read() call => stack overflow.  This way\x2C it might trigger\n// a nextTick recursion warning\x2C but that's not so bad.\nfunction emitReadable(stream) {\n  const state = stream._readableState;\n  debug('emitReadable');\n  state[kState] &= ~kNeedReadable;\n  if ((state[kState] & kEmittedReadable) === 0) {\n    debug('emitReadable'\x2C (state[kState] & kFlowing) !== 0);\n    state[kState] |= kEmittedReadable;\n    process.nextTick(emitReadable_\x2C stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  const state = stream._readableState;\n  debug('emitReadable_');\n  if ((state[kState] & (kDestroyed | kErrored)) === 0 && (state.length || (state[kState] & kEnded) !== 0)) {\n    stream.emit('readable');\n    state[kState] &= ~kEmittedReadable;\n  }\n\n  // The stream needs another readable event if:\n  // 1. It is not flowing\x2C as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark\x2C so we can schedule\n  //    another readable later.\n  state[kState] |=\n    (state[kState] & (kFlowing | kEnded)) === 0 &&\n    state.length <= state.highWaterMark ? kNeedReadable : 0;\n  flow(stream);\n}\n\n\n// At this point\x2C the user has presumably seen the 'readable' event\x2C\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call\x2C in which case reading = true if\n// it's in progress.\n// However\x2C if we're not ended\x2C or reading\x2C and the length < hwm\x2C\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream\x2C state) {\n  if ((state[kState] & (kReadingMore | kConstructed)) === kConstructed) {\n    state[kState] |= kReadingMore;\n    process.nextTick(maybeReadMore_\x2C stream\x2C state);\n  }\n}\n\nfunction maybeReadMore_(stream\x2C state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer\x2C and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data\x2C the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the stream has called the implementation defined _read()\n  //   method\x2C but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while ((state[kState] & (kReading | kEnded)) === 0 &&\n         (state.length < state.highWaterMark ||\n          ((state[kState] & kFlowing) !== 0 && state.length === 0))) {\n    const len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // Didn't get any data\x2C stop spinning.\n      break;\n  }\n  state[kState] &= ~kReadingMore;\n}\n\n// Abstract method.  to be overridden in specific implementation classes.\n// call cb(er\x2C data) where data is <= n in length.\n// for virtual (non-string\x2C non-buffer) streams\x2C "length" is somewhat\n// arbitrary\x2C and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_read()');\n};\n\nReadable.prototype.pipe = function(dest\x2C pipeOpts) {\n  const src = this;\n  const state = this._readableState;\n\n  if (state.pipes.length === 1) {\n    if ((state[kState] & kMultiAwaitDrain) === 0) {\n      state[kState] |= kMultiAwaitDrain;\n      state.awaitDrainWriters = new SafeSet(\n        state.awaitDrainWriters ? [state.awaitDrainWriters] : []\x2C\n      );\n    }\n  }\n\n  state.pipes.push(dest);\n  debug('pipe count=%d opts=%j'\x2C state.pipes.length\x2C pipeOpts);\n\n  const doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  const endFn = doEnd ? onend : unpipe;\n  if ((state[kState] & kEndEmitted) !== 0)\n    process.nextTick(endFn);\n  else\n    src.once('end'\x2C endFn);\n\n  dest.on('unpipe'\x2C onunpipe);\n  function onunpipe(readable\x2C unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  let ondrain;\n\n  let cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // Cleanup event handlers once the pipe is broken.\n    dest.removeListener('close'\x2C onclose);\n    dest.removeListener('finish'\x2C onfinish);\n    if (ondrain) {\n      dest.removeListener('drain'\x2C ondrain);\n    }\n    dest.removeListener('error'\x2C onerror);\n    dest.removeListener('unpipe'\x2C onunpipe);\n    src.removeListener('end'\x2C onend);\n    src.removeListener('end'\x2C unpipe);\n    src.removeListener('data'\x2C ondata);\n\n    cleanedUp = true;\n\n    // If the reader is waiting for a drain event from this\n    // specific writer\x2C then it would cause it to never start\n    // flowing again.\n    // So\x2C if this is awaiting a drain\x2C then we just call it now.\n    // If we don't know\x2C then assume that we are waiting for one.\n    if (ondrain && state.awaitDrainWriters &&\n        (!dest._writableState || dest._writableState.needDrain))\n      ondrain();\n  }\n\n  function pause() {\n    // If the user unpiped during `dest.write()`\x2C it is possible\n    // to get stuck in a permanently paused state if that write\n    // also returned false.\n    // => Check whether `dest` is still a piping destination.\n    if (!cleanedUp) {\n      if (state.pipes.length === 1 && state.pipes[0] === dest) {\n        debug('false write response\x2C pause'\x2C 0);\n        state.awaitDrainWriters = dest;\n        state[kState] &= ~kMultiAwaitDrain;\n      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {\n        debug('false write response\x2C pause'\x2C state.awaitDrainWriters.size);\n        state.awaitDrainWriters.add(dest);\n      }\n      src.pause();\n    }\n    if (!ondrain) {\n      // When the dest drains\x2C it reduces the awaitDrain counter\n      // on the source.  This would be more elegant with a .once()\n      // handler in flow()\x2C but adding and removing repeatedly is\n      // too slow.\n      ondrain = pipeOnDrain(src\x2C dest);\n      dest.on('drain'\x2C ondrain);\n    }\n  }\n\n  src.on('data'\x2C ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    const ret = dest.write(chunk);\n    debug('dest.write'\x2C ret);\n    if (ret === false) {\n      pause();\n    }\n  }\n\n  // If the dest has an error\x2C then stop piping into it.\n  // However\x2C don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror'\x2C er);\n    unpipe();\n    dest.removeListener('error'\x2C onerror);\n    if (dest.listenerCount('error') === 0) {\n      const s = dest._writableState || dest._readableState;\n      if (s && !s.errorEmitted) {\n        // User incorrectly emitted 'error' directly on the stream.\n        errorOrDestroy(dest\x2C er);\n      } else {\n        dest.emit('error'\x2C er);\n      }\n    }\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest\x2C 'error'\x2C onerror);\n\n  // Both close and finish should trigger unpipe\x2C but only once.\n  function onclose() {\n    dest.removeListener('finish'\x2C onfinish);\n    unpipe();\n  }\n  dest.once('close'\x2C onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close'\x2C onclose);\n    unpipe();\n  }\n  dest.once('finish'\x2C onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // Tell the dest that it's being piped to.\n  dest.emit('pipe'\x2C src);\n\n  // Start the flow if it hasn't been started already.\n\n  if (dest.writableNeedDrain === true) {\n    pause();\n  } else if ((state[kState] & kFlowing) === 0) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src\x2C dest) {\n  return function pipeOnDrainFunctionResult() {\n    const state = src._readableState;\n\n    // `ondrain` will call directly\x2C\n    // `this` maybe not a reference to dest\x2C\n    // so we use the real dest here.\n    if (state.awaitDrainWriters === dest) {\n      debug('pipeOnDrain'\x2C 1);\n      state.awaitDrainWriters = null;\n    } else if ((state[kState] & kMultiAwaitDrain) !== 0) {\n      debug('pipeOnDrain'\x2C state.awaitDrainWriters.size);\n      state.awaitDrainWriters.delete(dest);\n    }\n\n    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) &&\n      (state[kState] & kDataListening) !== 0) {\n      src.resume();\n    }\n  };\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  const state = this._readableState;\n  const unpipeInfo = { hasUnpiped: false };\n\n  // If we're not piping anywhere\x2C then do nothing.\n  if (state.pipes.length === 0)\n    return this;\n\n  if (!dest) {\n    // remove all.\n    const dests = state.pipes;\n    state.pipes = [];\n    this.pause();\n\n    for (let i = 0; i < dests.length; i++)\n      dests[i].emit('unpipe'\x2C this\x2C { hasUnpiped: false });\n    return this;\n  }\n\n  // Try to find the right one.\n  const index = ArrayPrototypeIndexOf(state.pipes\x2C dest);\n  if (index === -1)\n    return this;\n\n  state.pipes.splice(index\x2C 1);\n  if (state.pipes.length === 0)\n    this.pause();\n\n  dest.emit('unpipe'\x2C this\x2C unpipeInfo);\n\n  return this;\n};\n\n// Set up data events if they are asked for\n// Ensure readable listeners eventually get something.\nReadable.prototype.on = function(ev\x2C fn) {\n  const res = Stream.prototype.on.call(this\x2C ev\x2C fn);\n  const state = this._readableState;\n\n  if (ev === 'data') {\n    state[kState] |= kDataListening;\n\n    // Update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state[kState] |= this.listenerCount('readable') > 0 ? kReadableListening : 0;\n\n    // Try start flowing on next tick if stream isn't explicitly paused.\n    if ((state[kState] & (kHasFlowing | kFlowing)) !== kHasFlowing) {\n      this.resume();\n    }\n  } else if (ev === 'readable') {\n    if ((state[kState] & (kEndEmitted | kReadableListening)) === 0) {\n      state[kState] |= kReadableListening | kNeedReadable | kHasFlowing;\n      state[kState] &= ~(kFlowing | kEmittedReadable);\n      debug('on readable');\n      if (state.length) {\n        emitReadable(this);\n      } else if ((state[kState] & kReading) === 0) {\n        process.nextTick(nReadingNextTick\x2C this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function(ev\x2C fn) {\n  const state = this._readableState;\n\n  const res = Stream.prototype.removeListener.call(this\x2C\n                                                   ev\x2C fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable'\x2C fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening\x2C this);\n  } else if (ev === 'data' && this.listenerCount('data') === 0) {\n    state[kState] &= ~kDataListening;\n  }\n\n  return res;\n};\nReadable.prototype.off = Readable.prototype.removeListener;\n\nReadable.prototype.removeAllListeners = function(ev) {\n  const res = Stream.prototype.removeAllListeners.apply(this\x2C\n                                                        arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable'\x2C fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening\x2C this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  const state = self._readableState;\n\n  if (self.listenerCount('readable') > 0) {\n    state[kState] |= kReadableListening;\n  } else {\n    state[kState] &= ~kReadableListening;\n  }\n\n  if ((state[kState] & (kHasPaused | kPaused | kResumeScheduled)) === (kHasPaused | kResumeScheduled)) {\n    // Flowing needs to be set to true now\x2C otherwise\n    // the upcoming resume will not flow.\n    state[kState] |= kHasFlowing | kFlowing;\n\n    // Crude way to check if we should resume.\n  } else if ((state[kState] & kDataListening) !== 0) {\n    self.resume();\n  } else if ((state[kState] & kReadableListening) === 0) {\n    state[kState] &= ~(kHasFlowing | kFlowing);\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them\x2C then switch into old mode.\nReadable.prototype.resume = function() {\n  const state = this._readableState;\n  if ((state[kState] & kFlowing) === 0) {\n    debug('resume');\n    // We flow only if there is no one listening\n    // for readable\x2C but we still have to call\n    // resume().\n    state[kState] |= kHasFlowing;\n    if ((state[kState] & kReadableListening) === 0) {\n      state[kState] |= kFlowing;\n    } else {\n      state[kState] &= ~kFlowing;\n    }\n    resume(this\x2C state);\n  }\n  state[kState] |= kHasPaused;\n  state[kState] &= ~kPaused;\n  return this;\n};\n\nfunction resume(stream\x2C state) {\n  if ((state[kState] & kResumeScheduled) === 0) {\n    state[kState] |= kResumeScheduled;\n    process.nextTick(resume_\x2C stream\x2C state);\n  }\n}\n\nfunction resume_(stream\x2C state) {\n  debug('resume'\x2C (state[kState] & kReading) !== 0);\n  if ((state[kState] & kReading) === 0) {\n    stream.read(0);\n  }\n\n  state[kState] &= ~kResumeScheduled;\n  stream.emit('resume');\n  flow(stream);\n  if ((state[kState] & (kFlowing | kReading)) === kFlowing)\n    stream.read(0);\n}\n\nReadable.prototype.pause = function() {\n  const state = this._readableState;\n  debug('call pause');\n  if ((state[kState] & (kHasFlowing | kFlowing)) !== kHasFlowing) {\n    debug('pause');\n    state[kState] |= kHasFlowing;\n    state[kState] &= ~kFlowing;\n    this.emit('pause');\n  }\n  state[kState] |= kHasPaused | kPaused;\n  return this;\n};\n\nfunction flow(stream) {\n  const state = stream._readableState;\n  debug('flow');\n  while ((state[kState] & kFlowing) !== 0 && stream.read() !== null);\n}\n\n// Wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  let paused = false;\n\n  // TODO (ronag): Should this.destroy(err) emit\n  // 'error' on the wrapped stream? Would require\n  // a static factory method\x2C e.g. Readable.wrap(stream).\n\n  stream.on('data'\x2C (chunk) => {\n    if (!this.push(chunk) && stream.pause) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  stream.on('end'\x2C () => {\n    this.push(null);\n  });\n\n  stream.on('error'\x2C (err) => {\n    errorOrDestroy(this\x2C err);\n  });\n\n  stream.on('close'\x2C () => {\n    this.destroy();\n  });\n\n  stream.on('destroy'\x2C () => {\n    this.destroy();\n  });\n\n  this._read = () => {\n    if (paused && stream.resume) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  // Proxy all the other methods. Important when wrapping filters and duplexes.\n  const streamKeys = ObjectKeys(stream);\n  for (let j = 1; j < streamKeys.length; j++) {\n    const i = streamKeys[j];\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = stream[i].bind(stream);\n    }\n  }\n\n  return this;\n};\n\nReadable.prototype[SymbolAsyncIterator] = function() {\n  return streamToAsyncIterator(this);\n};\n\nReadable.prototype.iterator = function(options) {\n  if (options !== undefined) {\n    validateObject(options\x2C 'options');\n  }\n  return streamToAsyncIterator(this\x2C options);\n};\n\nfunction streamToAsyncIterator(stream\x2C options) {\n  if (typeof stream.read !== 'function') {\n    stream = Readable.wrap(stream\x2C { objectMode: true });\n  }\n\n  const iter = createAsyncIterator(stream\x2C options);\n  iter.stream = stream;\n  return iter;\n}\n\nasync function* createAsyncIterator(stream\x2C options) {\n  let callback = nop;\n\n  function next(resolve) {\n    if (this === stream) {\n      callback();\n      callback = nop;\n    } else {\n      callback = resolve;\n    }\n  }\n\n  stream.on('readable'\x2C next);\n\n  let error;\n  const cleanup = eos(stream\x2C { writable: false }\x2C (err) => {\n    error = err ? aggregateTwoErrors(error\x2C err) : null;\n    callback();\n    callback = nop;\n  });\n\n  try {\n    while (true) {\n      const chunk = stream.destroyed ? null : stream.read();\n      if (chunk !== null) {\n        yield chunk;\n      } else if (error) {\n        throw error;\n      } else if (error === null) {\n        return;\n      } else {\n        await new Promise(next);\n      }\n    }\n  } catch (err) {\n    error = aggregateTwoErrors(error\x2C err);\n    throw error;\n  } finally {\n    if (\n      (error || options?.destroyOnReturn !== false) &&\n      (error === undefined || stream._readableState.autoDestroy)\n    ) {\n      destroyImpl.destroyer(stream\x2C null);\n    } else {\n      stream.off('readable'\x2C next);\n      cleanup();\n    }\n  }\n}\n\n// Making it explicit these properties are not enumerable\n// because otherwise some prototype manipulation in\n// userland will fail.\nObjectDefineProperties(Readable.prototype\x2C {\n  readable: {\n    __proto__: null\x2C\n    get() {\n      const r = this._readableState;\n      // r.readable === false means that this is part of a Duplex stream\n      // where the readable side was disabled upon construction.\n      // Compat. The user might manually disable readable side through\n      // deprecated setter.\n      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted &&\n        !r.endEmitted;\n    }\x2C\n    set(val) {\n      // Backwards compat.\n      if (this._readableState) {\n        this._readableState.readable = !!val;\n      }\n    }\x2C\n  }\x2C\n\n  readableDidRead: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get: function() {\n      return this._readableState.dataEmitted;\n    }\x2C\n  }\x2C\n\n  readableAborted: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get: function() {\n      return !!(\n        this._readableState.readable !== false &&\n        (this._readableState.destroyed || this._readableState.errored) &&\n        !this._readableState.endEmitted\n      );\n    }\x2C\n  }\x2C\n\n  readableHighWaterMark: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get: function() {\n      return this._readableState.highWaterMark;\n    }\x2C\n  }\x2C\n\n  readableBuffer: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get: function() {\n      return this._readableState && this._readableState.buffer;\n    }\x2C\n  }\x2C\n\n  readableFlowing: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get: function() {\n      return this._readableState.flowing;\n    }\x2C\n    set: function(state) {\n      if (this._readableState) {\n        this._readableState.flowing = state;\n      }\n    }\x2C\n  }\x2C\n\n  readableLength: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() {\n      return this._readableState.length;\n    }\x2C\n  }\x2C\n\n  readableObjectMode: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() {\n      return this._readableState ? this._readableState.objectMode : false;\n    }\x2C\n  }\x2C\n\n  readableEncoding: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() {\n      return this._readableState ? this._readableState.encoding : null;\n    }\x2C\n  }\x2C\n\n  errored: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() {\n      return this._readableState ? this._readableState.errored : null;\n    }\x2C\n  }\x2C\n\n  closed: {\n    __proto__: null\x2C\n    get() {\n      return this._readableState ? this._readableState.closed : false;\n    }\x2C\n  }\x2C\n\n  destroyed: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() {\n      return this._readableState ? this._readableState.destroyed : false;\n    }\x2C\n    set(value) {\n      // We ignore the value if the stream\n      // has not been initialized yet.\n      if (!this._readableState) {\n        return;\n      }\n\n      // Backward compatibility\x2C the user is explicitly\n      // managing destroyed.\n      this._readableState.destroyed = value;\n    }\x2C\n  }\x2C\n\n  readableEnded: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() {\n      return this._readableState ? this._readableState.endEmitted : false;\n    }\x2C\n  }\x2C\n\n});\n\nObjectDefineProperties(ReadableState.prototype\x2C {\n  // Legacy getter for `pipesCount`.\n  pipesCount: {\n    __proto__: null\x2C\n    get() {\n      return this.pipes.length;\n    }\x2C\n  }\x2C\n\n  // Legacy property for `paused`.\n  paused: {\n    __proto__: null\x2C\n    get() {\n      return (this[kState] & kPaused) !== 0;\n    }\x2C\n    set(value) {\n      this[kState] |= kHasPaused;\n      if (value) {\n        this[kState] |= kPaused;\n      } else {\n        this[kState] &= ~kPaused;\n      }\n    }\x2C\n  }\x2C\n});\n\n// Exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable\x2C so please take care when making\n// changes to the function body.\nfunction fromList(n\x2C state) {\n  // nothing buffered.\n  if (state.length === 0)\n    return null;\n\n  let idx = state.bufferIndex;\n  let ret;\n\n  const buf = state.buffer;\n  const len = buf.length;\n\n  if ((state[kState] & kObjectMode) !== 0) {\n    ret = buf[idx];\n    buf[idx++] = null;\n  } else if (!n || n >= state.length) {\n    // Read it all\x2C truncate the list.\n    if ((state[kState] & kDecoder) !== 0) {\n      ret = '';\n      while (idx < len) {\n        ret += buf[idx];\n        buf[idx++] = null;\n      }\n    } else if (len - idx === 0) {\n      ret = Buffer.alloc(0);\n    } else if (len - idx === 1) {\n      ret = buf[idx];\n      buf[idx++] = null;\n    } else {\n      ret = Buffer.allocUnsafe(state.length);\n\n      let i = 0;\n      while (idx < len) {\n        TypedArrayPrototypeSet(ret\x2C buf[idx]\x2C i);\n        i += buf[idx].length;\n        buf[idx++] = null;\n      }\n    }\n  } else if (n < buf[idx].length) {\n    // `slice` is the same for buffers and strings.\n    ret = buf[idx].slice(0\x2C n);\n    buf[idx] = buf[idx].slice(n);\n  } else if (n === buf[idx].length) {\n    // First chunk is a perfect match.\n    ret = buf[idx];\n    buf[idx++] = null;\n  } else if ((state[kState] & kDecoder) !== 0) {\n    ret = '';\n    while (idx < len) {\n      const str = buf[idx];\n      if (n > str.length) {\n        ret += str;\n        n -= str.length;\n        buf[idx++] = null;\n      } else {\n        if (n === buf.length) {\n          ret += str;\n          buf[idx++] = null;\n        } else {\n          ret += str.slice(0\x2C n);\n          buf[idx] = str.slice(n);\n        }\n        break;\n      }\n    }\n  } else {\n    ret = Buffer.allocUnsafe(n);\n\n    const retLen = n;\n    while (idx < len) {\n      const data = buf[idx];\n      if (n > data.length) {\n        TypedArrayPrototypeSet(ret\x2C data\x2C retLen - n);\n        n -= data.length;\n        buf[idx++] = null;\n      } else {\n        if (n === data.length) {\n          TypedArrayPrototypeSet(ret\x2C data\x2C retLen - n);\n          buf[idx++] = null;\n        } else {\n          TypedArrayPrototypeSet(ret\x2C new FastBuffer(data.buffer\x2C data.byteOffset\x2C n)\x2C retLen - n);\n          buf[idx] = new FastBuffer(data.buffer\x2C data.byteOffset + n\x2C data.length - n);\n        }\n        break;\n      }\n    }\n  }\n\n  if (idx === len) {\n    state.buffer.length = 0;\n    state.bufferIndex = 0;\n  } else if (idx > 1024) {\n    state.buffer.splice(0\x2C idx);\n    state.bufferIndex = 0;\n  } else {\n    state.bufferIndex = idx;\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  const state = stream._readableState;\n\n  debug('endReadable');\n  if ((state[kState] & kEndEmitted) === 0) {\n    state[kState] |= kEnded;\n    process.nextTick(endReadableNT\x2C state\x2C stream);\n  }\n}\n\nfunction endReadableNT(state\x2C stream) {\n  debug('endReadableNT');\n\n  // Check that we didn't get one last unshift.\n  if ((state[kState] & (kErrored | kCloseEmitted | kEndEmitted)) === 0 && state.length === 0) {\n    state[kState] |= kEndEmitted;\n    stream.emit('end');\n\n    if (stream.writable && stream.allowHalfOpen === false) {\n      process.nextTick(endWritableNT\x2C stream);\n    } else if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well.\n      const wState = stream._writableState;\n      const autoDestroy = !wState || (\n        wState.autoDestroy &&\n        // We don't expect the writable to ever 'finish'\n        // if writable is explicitly set to false.\n        (wState.finished || wState.writable === false)\n      );\n\n      if (autoDestroy) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nfunction endWritableNT(stream) {\n  const writable = stream.writable && !stream.writableEnded &&\n    !stream.destroyed;\n  if (writable) {\n    stream.end();\n  }\n}\n\nReadable.from = function(iterable\x2C opts) {\n  return from(Readable\x2C iterable\x2C opts);\n};\n\nlet webStreamsAdapters;\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined)\n    webStreamsAdapters = require('internal/webstreams/adapters');\n  return webStreamsAdapters;\n}\n\nReadable.fromWeb = function(readableStream\x2C options) {\n  return lazyWebStreams().newStreamReadableFromReadableStream(\n    readableStream\x2C\n    options);\n};\n\nReadable.toWeb = function(streamReadable\x2C options) {\n  return lazyWebStreams().newReadableStreamFromStreamReadable(\n    streamReadable\x2C\n    options);\n};\n\nReadable.wrap = function(src\x2C options) {\n  return new Readable({\n    objectMode: src.readableObjectMode ?? src.objectMode ?? true\x2C\n    ...options\x2C\n    destroy(err\x2C callback) {\n      destroyImpl.destroyer(src\x2C err);\n      callback(err);\n    }\x2C\n  }).wrap(src);\n};\n
code-source-info,0x31e6f25fadfe,102,0,51291,C0O0C4O51291,,
code-creation,JS,10,104841,0x31e6f25fe116,2570, node:internal/streams/readable:1:1,0x31e6f25fad78,~
code-source-info,0x31e6f25fe116,102,0,51291,C0O0C390O1159C396O1184C402O1203C408O1218C414O1236C419O1262C425O1276C430O1300C436O1311C442O1322C447O1332C452O1354C457O1377C462O1394C468O1436C470O1451C474O1463C479O1486C483O1515C489O1515C494O1570C500O1570C505O1542C511O1550C517O1625C523O1625C528O1614C534O1675C540O1675C545O1655C551O1733C557O1733C561O1733C563O1789C569O1789C574O1822C587O1823C593O1789C595O1890C601O1890C605O1890C607O1986C613O1986C618O1937C624O1957C630O2208C636O2208C641O2031C647O2056C653O2071C659O2088C665O2104C671O2118C677O2132C682O2143C688O2160C694O2172C700O2188C706O2485C712O2485C717O2254C723O2283C728O2289C734O2315C740O2347C746O2369C752O2400C758O2440C764O2469C770O2540C776O2540C781O2521C787O2592C792O2598C795O2592C797O2642C803O2642C808O2624C814O2682C820O2682C824O2682C826O2717C829O2747C837O2765C842O2717C847O2777C853O2777C858O2829C862O2829C864O2867C867O2848C873O2903C876O2903C880O2903C882O2958C885O2958C889O2958C891O3013C894O3013C898O3013C900O3061C903O3061C907O3061C909O3103C913O3103C915O3131C919O3131C921O3157C925O3157C927O3180C931O3180C933O3211C937O3211C939O3245C943O3245C945O3281C951O3281C953O3315C959O3315C961O3349C967O3349C969O3379C975O3379C977O3409C983O3409C985O3447C991O3447C993O3473C999O3473C1001O3500C1007O3500C1009O3529C1015O3529C1017O3555C1023O3555C1025O3583C1031O3583C1033O3608C1039O3608C1041O3640C1047O3640C1049O3956C1052O3993C1065O4020C1076O4064C1087O4108C1098O4154C1109O4383C1120O4696C1131O4851C1142O4907C1153O4968C1164O5029C1175O5160C1186O5210C1197O5259C1208O5336C1216O5439C1227O5578C1238O5634C1249O5739C1260O5790C1268O6079C1273O6129C1281O6223C1295O6416C1300O6466C1308O6572C1322O6821C1327O6871C1335O6965C1349O7151C1354O7201C1362O7297C1376O7485C1381O7535C1389O7644C1403O3956C1408O9921C1411O9935C1419O9945C1423O9961C1427O11119C1430O11128C1438O11160C1446O11146C1454O11169C1457O11178C1465O11213C1473O11199C1481O11224C1484O11233C1493O11252C1501O11289C1504O11298C1509O11311C1522O11335C1530O11378C1533O11387C1538O11397C1542O11417C1550O11878C1553O11887C1562O11902C1570O12240C1573O12249C1582O12267C1590O17422C1593O17431C1602O17450C1610O17638C1613O17647C1622O17669C1630O18290C1636O18290C1638O19318C1641O19327C1650O19342C1658O28822C1661O28831C1670O28847C1678O28918C1681O28927C1690O28942C1698O34137C1701O34146C1710O34163C1718O34968C1721O34977C1730O34990C1738O36003C1741O36012C1749O36045C1754O36055C1762O36034C1770O36060C1773O36069C1782O36094C1790O36805C1793O36814C1801O36839C1806O36849C1814O36828C1822O36866C1825O36875C1834O36904C1842O38421C1845O38430C1854O38447C1862O39448C1865O39457C1874O39473C1882O40099C1885O40108C1894O40123C1902O41149C1905O41158C1910O41168C1914O41189C1922O41246C1925O41255C1934O41274C1942O42884C1945O42916C1958O42941C1966O42968C1978O43363C2000O43520C2008O43575C2030O43666C2038O43721C2060O43962C2068O44017C2090O44109C2098O44164C2120O44273C2128O44328C2140O44399C2162O44534C2170O44584C2192O44668C2200O44718C2222O44834C2230O44884C2252O44988C2260O45038C2282O45140C2290O45167C2312O45272C2320O45322C2332O45415C2354O45729C2362O45779C2384O42884C2394O45880C2397O45917C2410O45981C2418O46008C2440O46106C2448O46133C2460O46197C2482O45880C2492O46408C2497O46427C2505O50403C2512O50417C2520O50495C2521O50495C2523O50719C2530O50736C2538O50875C2545O50890C2553O51029C2560O51043C2569O51290,,
tick,0x10da1184e,105009,1,0x10c1e6120,3,0x10c41e000,0x112583f26,0x112583ca1,0x31e6f25f70fc,0x112583feb,0x112583ca1,0x31e6f25f3416,0x112583feb,0x112583ca1,0x31e6f25f1c60,0x112583feb,0x112583ca1,0x31e6f25e4346,0x112583feb,0x112583ca1,0x31e6f25e22c3,0x112583feb,0x112583ca1,0x31e6f25df4ab,0x112583feb,0x112583ca1,0x31e6f25da395,0x112583feb,0x112583ca1,0x31e6f25d7289,0x112583feb,0x31e6f25d6c7a,0x31e6f25d6880,0x31e6f6b607cb,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f25d543c,0x31e6f6b7a501,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
tick,0x10c42f594,105036,1,0x10c1e6120,3,0x10c41e000,0x112583f26,0x112583ca1,0x31e6f25f70fc,0x112583feb,0x112583ca1,0x31e6f25f3416,0x112583feb,0x112583ca1,0x31e6f25f1c60,0x112583feb,0x112583ca1,0x31e6f25e4346,0x112583feb,0x112583ca1,0x31e6f25e22c3,0x112583feb,0x112583ca1,0x31e6f25df4ab,0x112583feb,0x112583ca1,0x31e6f25da395,0x112583feb,0x112583ca1,0x31e6f25d7289,0x112583feb,0x31e6f25d6c7a,0x31e6f25d6880,0x31e6f6b607cb,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f25d543c,0x31e6f6b7a501,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
tick,0x7ff8091ad5d5,105054,1,0x10c1e6120,3,0x10c41e000,0x112583f26,0x112583ca1,0x31e6f25f70fc,0x112583feb,0x112583ca1,0x31e6f25f3416,0x112583feb,0x112583ca1,0x31e6f25f1c60,0x112583feb,0x112583ca1,0x31e6f25e4346,0x112583feb,0x112583ca1,0x31e6f25e22c3,0x112583feb,0x112583ca1,0x31e6f25df4ab,0x112583feb,0x112583ca1,0x31e6f25da395,0x112583feb,0x112583ca1,0x31e6f25d7289,0x112583feb,0x31e6f25d6c7a,0x31e6f25d6880,0x31e6f6b607cb,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f25d543c,0x31e6f6b7a501,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,Eval,10,105283,0x31e6451c57b6,5, node:internal/streams/add-abort-signal:1:1,0x31e6451c55c0,~
script-source,103,node:internal/streams/add-abort-signal,'use strict';\n\nconst {\n  SymbolDispose\x2C\n} = primordials;\n\nconst {\n  AbortError\x2C\n  codes\x2C\n} = require('internal/errors');\n\nconst {\n  isNodeStream\x2C\n  isWebStream\x2C\n  kControllerErrorFunction\x2C\n} = require('internal/streams/utils');\n\nconst eos = require('internal/streams/end-of-stream');\nconst { ERR_INVALID_ARG_TYPE } = codes;\nlet addAbortListener;\n\n// This method is inlined here for readable-stream\n// It also does not allow for signal to not exist on the stream\n// https://github.com/nodejs/node/pull/36061#discussion_r533718029\nconst validateAbortSignal = (signal\x2C name) => {\n  if (typeof signal !== 'object' ||\n       !('aborted' in signal)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'AbortSignal'\x2C signal);\n  }\n};\n\nmodule.exports.addAbortSignal = function addAbortSignal(signal\x2C stream) {\n  validateAbortSignal(signal\x2C 'signal');\n  if (!isNodeStream(stream) && !isWebStream(stream)) {\n    throw new ERR_INVALID_ARG_TYPE('stream'\x2C ['ReadableStream'\x2C 'WritableStream'\x2C 'Stream']\x2C stream);\n  }\n  return module.exports.addAbortSignalNoValidate(signal\x2C stream);\n};\n\nmodule.exports.addAbortSignalNoValidate = function(signal\x2C stream) {\n  if (typeof signal !== 'object' || !('aborted' in signal)) {\n    return stream;\n  }\n  const onAbort = isNodeStream(stream) ?\n    () => {\n      stream.destroy(new AbortError(undefined\x2C { cause: signal.reason }));\n    } :\n    () => {\n      stream[kControllerErrorFunction](new AbortError(undefined\x2C { cause: signal.reason }));\n    };\n  if (signal.aborted) {\n    onAbort();\n  } else {\n    addAbortListener ??= require('events').addAbortListener;\n    const disposable = addAbortListener(signal\x2C onAbort);\n    eos(stream\x2C disposable[SymbolDispose]);\n  }\n  return stream;\n};\n
code-source-info,0x31e6451c57b6,103,0,1704,C0O0C4O1704,,
code-creation,JS,10,105420,0x31e6451c5a26,158, node:internal/streams/add-abort-signal:1:1,0x31e6451c5730,~
code-source-info,0x31e6451c5a26,103,0,1704,C0O0C40O25C46O93C52O93C57O68C63O82C68O193C74O193C79O132C85O148C91O163C97O241C103O241C107O241C109O292C115O328C116O328C118O557C122O557C124O719C127O726C136O749C140O1065C143O1072C152O1105C157O1703,,
code-creation,Eval,10,105558,0x31e6451c62a6,5, node:internal/streams/state:1:1,0x31e6451c60e0,~
script-source,104,node:internal/streams/state,'use strict';\n\nconst {\n  MathFloor\x2C\n  NumberIsInteger\x2C\n} = primordials;\nconst { validateInteger } = require('internal/validators');\n\nconst { ERR_INVALID_ARG_VALUE } = require('internal/errors').codes;\n\nlet defaultHighWaterMarkBytes = 16 * 1024;\nlet defaultHighWaterMarkObjectMode = 16;\n\nfunction highWaterMarkFrom(options\x2C isDuplex\x2C duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark :\n    isDuplex ? options[duplexKey] : null;\n}\n\nfunction getDefaultHighWaterMark(objectMode) {\n  return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;\n}\n\nfunction setDefaultHighWaterMark(objectMode\x2C value) {\n  validateInteger(value\x2C 'value'\x2C 0);\n  if (objectMode) {\n    defaultHighWaterMarkObjectMode = value;\n  } else {\n    defaultHighWaterMarkBytes = value;\n  }\n}\n\nfunction getHighWaterMark(state\x2C options\x2C duplexKey\x2C isDuplex) {\n  const hwm = highWaterMarkFrom(options\x2C isDuplex\x2C duplexKey);\n  if (hwm != null) {\n    if (!NumberIsInteger(hwm) || hwm < 0) {\n      const name = isDuplex ? `options.${duplexKey}` : 'options.highWaterMark';\n      throw new ERR_INVALID_ARG_VALUE(name\x2C hwm);\n    }\n    return MathFloor(hwm);\n  }\n\n  // Default value\n  return getDefaultHighWaterMark(state.objectMode);\n}\n\nmodule.exports = {\n  getHighWaterMark\x2C\n  getDefaultHighWaterMark\x2C\n  setDefaultHighWaterMark\x2C\n};\n
code-source-info,0x31e6451c62a6,104,0,1332,C0O0C4O1332,,
code-creation,JS,10,105660,0x31e6451c652e,131, node:internal/streams/state:1:1,0x31e6451c6220,~
code-source-info,0x31e6451c652e,104,0,1332,C0O0C45O25C51O38C57O100C60O100C65O80C71O167C74O167C79O193C84O141C90O234C94O234C96O282C98O282C100O1236C107O1257C113O1277C119O1304C125O1251C130O1331,,
tick,0x10c909cf0,105727,0,0x0,0,0x10c9fad00,0x31e6451c6592,0x112583feb,0x112583ca1,0x31e6f25fe37b,0x112583feb,0x112583ca1,0x31e6f25f70fc,0x112583feb,0x112583ca1,0x31e6f25f3416,0x112583feb,0x112583ca1,0x31e6f25f1c60,0x112583feb,0x112583ca1,0x31e6f25e4346,0x112583feb,0x112583ca1,0x31e6f25e22c3,0x112583feb,0x112583ca1,0x31e6f25df4ab,0x112583feb,0x112583ca1,0x31e6f25da395,0x112583feb,0x112583ca1,0x31e6f25d7289,0x112583feb,0x31e6f25d6c7a,0x31e6f25d6880,0x31e6f6b607cb,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f25d543c,0x31e6f6b7a501,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,105750,0x31e6451c69e6,5,get node:buffer:286:6,0x31e647c4f4a8,~
code-source-info,0x31e6451c69e6,24,8261,8286,C0O8266C4O8284,,
code-creation,Eval,10,105891,0x31e6451c6e16,5, node:string_decoder:1:1,0x31e6451c6ba0,~
script-source,105,node:string_decoder,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayBufferIsView\x2C\n  ObjectDefineProperties\x2C\n  Symbol\x2C\n  TypedArrayPrototypeSubarray\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst {\n  kIncompleteCharactersStart\x2C\n  kIncompleteCharactersEnd\x2C\n  kMissingBytes\x2C\n  kBufferedBytes\x2C\n  kEncodingField\x2C\n  kSize\x2C\n  decode\x2C\n  flush\x2C\n  encodings\x2C\n} = internalBinding('string_decoder');\nconst internalUtil = require('internal/util');\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_THIS\x2C\n  ERR_UNKNOWN_ENCODING\x2C\n} = require('internal/errors').codes;\nconst isEncoding = Buffer[internalUtil.kIsEncodingSymbol];\n\nconst kNativeDecoder = Symbol('kNativeDecoder');\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\n/**\n * Normalize encoding notation\n * @param {string} enc\n * @returns {"utf8" | "utf16le" | "hex" | "ascii"\n *           | "base64" | "latin1" | "base64url"}\n * @throws {TypeError} Throws an error when encoding is invalid\n */\nfunction normalizeEncoding(enc) {\n  const nenc = internalUtil.normalizeEncoding(enc);\n  if (nenc === undefined) {\n    if (Buffer.isEncoding === isEncoding || !Buffer.isEncoding(enc))\n      throw new ERR_UNKNOWN_ENCODING(enc);\n    return enc;\n  }\n  return nenc;\n}\n\nconst encodingsMap = {};\nfor (let i = 0; i < encodings.length; ++i)\n  encodingsMap[encodings[i]] = i;\n\n/**\n * StringDecoder provides an interface for efficiently splitting a series of\n * buffers into a series of JS strings without breaking apart multi-byte\n * characters.\n * @param {string} [encoding=utf-8]\n */\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  this[kNativeDecoder] = Buffer.alloc(kSize);\n  this[kNativeDecoder][kEncodingField] = encodingsMap[this.encoding];\n}\n\n/**\n * Returns a decoded string\x2C omitting any incomplete multi-bytes\n * characters at the end of the Buffer\x2C or TypedArray\x2C or DataView\n * @param {string | Buffer | TypedArray | DataView} buf\n * @returns {string}\n * @throws {TypeError} Throws when buf is not in one of supported types\n */\nStringDecoder.prototype.write = function write(buf) {\n  if (typeof buf === 'string')\n    return buf;\n  if (!ArrayBufferIsView(buf))\n    throw new ERR_INVALID_ARG_TYPE('buf'\x2C\n                                   ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n                                   buf);\n  if (!this[kNativeDecoder]) {\n    throw new ERR_INVALID_THIS('StringDecoder');\n  }\n  return decode(this[kNativeDecoder]\x2C buf);\n};\n\n/**\n * Returns any remaining input stored in the internal buffer as a string.\n * After end() is called\x2C the stringDecoder object can be reused for new\n * input.\n * @param {string | Buffer | TypedArray | DataView} [buf]\n * @returns {string}\n */\nStringDecoder.prototype.end = function end(buf) {\n  let ret = '';\n  if (buf !== undefined)\n    ret = this.write(buf);\n  if (this[kNativeDecoder][kBufferedBytes] > 0)\n    ret += flush(this[kNativeDecoder]);\n  return ret;\n};\n\n/* Everything below this line is undocumented legacy stuff. */\n/**\n *\n * @param {string | Buffer | TypedArray | DataView} buf\n * @param {number} offset\n * @returns {string}\n */\nStringDecoder.prototype.text = function text(buf\x2C offset) {\n  this[kNativeDecoder][kMissingBytes] = 0;\n  this[kNativeDecoder][kBufferedBytes] = 0;\n  return this.write(buf.slice(offset));\n};\n\nObjectDefineProperties(StringDecoder.prototype\x2C {\n  lastChar: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() {\n      return TypedArrayPrototypeSubarray(this[kNativeDecoder]\x2C\n                                         kIncompleteCharactersStart\x2C\n                                         kIncompleteCharactersEnd);\n    }\x2C\n  }\x2C\n  lastNeed: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() {\n      return this[kNativeDecoder][kMissingBytes];\n    }\x2C\n  }\x2C\n  lastTotal: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() {\n      return this[kNativeDecoder][kBufferedBytes] +\n             this[kNativeDecoder][kMissingBytes];\n    }\x2C\n  }\x2C\n});\n\nexports.StringDecoder = StringDecoder;\n
code-source-info,0x31e6451c6e16,105,0,5213,C0O0C4O5213,,
code-creation,JS,10,106223,0x31e6451c73a6,388, node:string_decoder:1:1,0x31e6451c6d90,~
code-source-info,0x31e6451c73a6,105,0,5213,C0O0C70O1159C76O1180C81O1206C86O1216C92O1282C95O1282C100O1271C106O1465C109O1465C114O1311C120O1341C126O1369C132O1386C138O1404C144O1422C150O1431C156O1441C162O1450C167O1521C170O1521C174O1521C176O1627C179O1627C184O1653C189O1557C195O1581C201O1601C207O1680C213O1700C217O1686C220O1680C222O1744C225O1744C229O1744C231O2414C232O2414C234O2431C236O2448C240O2436C245O2463C250O2485C256O2490C260O2458C265O2418C269O3209C278O3225C282O3873C291O3887C295O4274C304O4289C308O4488C318O4513C323O4586C337O4818C342O4891C356O4974C361O5047C375O4451C380O5174C382O5196C387O5212,,
code-creation,Eval,10,106439,0x31e6451c862e,5, node:internal/streams/from:1:1,0x31e6451c8478,~
script-source,106,node:internal/streams/from,'use strict';\n\nconst {\n  PromisePrototypeThen\x2C\n  SymbolAsyncIterator\x2C\n  SymbolIterator\x2C\n} = primordials;\nconst { Buffer } = require('buffer');\n\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_STREAM_NULL_VALUES\x2C\n} = require('internal/errors').codes;\n\nfunction from(Readable\x2C iterable\x2C opts) {\n  let iterator;\n  if (typeof iterable === 'string' || iterable instanceof Buffer) {\n    return new Readable({\n      objectMode: true\x2C\n      ...opts\x2C\n      read() {\n        this.push(iterable);\n        this.push(null);\n      }\x2C\n    });\n  }\n\n  let isAsync;\n  if (iterable && iterable[SymbolAsyncIterator]) {\n    isAsync = true;\n    iterator = iterable[SymbolAsyncIterator]();\n  } else if (iterable && iterable[SymbolIterator]) {\n    isAsync = false;\n    iterator = iterable[SymbolIterator]();\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('iterable'\x2C ['Iterable']\x2C iterable);\n  }\n\n\n  const readable = new Readable({\n    objectMode: true\x2C\n    highWaterMark: 1\x2C\n    // TODO(ronag): What options should be allowed?\n    ...opts\x2C\n  });\n\n  // Flag to protect against _read\n  // being called before last iteration completion.\n  let reading = false;\n  let isAsyncValues = false;\n\n  readable._read = function() {\n    if (!reading) {\n      reading = true;\n\n      if (isAsync) {\n        nextAsync();\n      } else if (isAsyncValues) {\n        nextSyncWithAsyncValues();\n      } else {\n        nextSyncWithSyncValues();\n      }\n    }\n  };\n\n  readable._destroy = function(error\x2C cb) {\n    PromisePrototypeThen(\n      close(error)\x2C\n      () => process.nextTick(cb\x2C error)\x2C // nextTick is here in case cb throws\n      (e) => process.nextTick(cb\x2C e || error)\x2C\n    );\n  };\n\n  async function close(error) {\n    const hadError = (error !== undefined) && (error !== null);\n    const hasThrow = typeof iterator.throw === 'function';\n    if (hadError && hasThrow) {\n      const { value\x2C done } = await iterator.throw(error);\n      await value;\n      if (done) {\n        return;\n      }\n    }\n    if (typeof iterator.return === 'function') {\n      const { value } = await iterator.return();\n      await value;\n    }\n  }\n\n  // There are a lot of duplication here\x2C it's done on purpose for performance\n  // reasons - avoid await when not needed.\n\n  function nextSyncWithSyncValues() {\n    for (;;) {\n      try {\n        const { value\x2C done } = iterator.next();\n\n        if (done) {\n          readable.push(null);\n          return;\n        }\n\n        if (value &&\n          typeof value.then === 'function') {\n          return changeToAsyncValues(value);\n        }\n\n        if (value === null) {\n          reading = false;\n          throw new ERR_STREAM_NULL_VALUES();\n        }\n\n        if (readable.push(value)) {\n          continue;\n        }\n\n        reading = false;\n      } catch (err) {\n        readable.destroy(err);\n      }\n      break;\n    }\n  }\n\n  async function changeToAsyncValues(value) {\n    isAsyncValues = true;\n\n    try {\n      const res = await value;\n\n      if (res === null) {\n        reading = false;\n        throw new ERR_STREAM_NULL_VALUES();\n      }\n\n      if (readable.push(res)) {\n        nextSyncWithAsyncValues();\n        return;\n      }\n\n      reading = false;\n    } catch (err) {\n      readable.destroy(err);\n    }\n  }\n\n  async function nextSyncWithAsyncValues() {\n    for (;;) {\n      try {\n        const { value\x2C done } = iterator.next();\n\n        if (done) {\n          readable.push(null);\n          return;\n        }\n\n        const res = (value &&\n          typeof value.then === 'function') ?\n          await value :\n          value;\n\n        if (res === null) {\n          reading = false;\n          throw new ERR_STREAM_NULL_VALUES();\n        }\n\n        if (readable.push(res)) {\n          continue;\n        }\n\n        reading = false;\n      } catch (err) {\n        readable.destroy(err);\n      }\n      break;\n    }\n  }\n\n  async function nextAsync() {\n    for (;;) {\n      try {\n        const { value\x2C done } = await iterator.next();\n\n        if (done) {\n          readable.push(null);\n          return;\n        }\n\n        if (value === null) {\n          reading = false;\n          throw new ERR_STREAM_NULL_VALUES();\n        }\n\n        if (readable.push(value)) {\n          continue;\n        }\n\n        reading = false;\n      } catch (err) {\n        readable.destroy(err);\n      }\n      break;\n    }\n  }\n  return readable;\n}\n\nmodule.exports = from;\n
code-source-info,0x31e6451c862e,106,0,4341,C0O0C4O4341,,
code-creation,JS,10,106730,0x31e6451c87ae,97, node:internal/streams/from:1:1,0x31e6451c85a8,~
code-source-info,0x31e6451c87ae,106,0,4341,C0O0C32O25C38O49C44O72C50O124C53O124C58O113C64O206C67O206C72O232C77O154C83O178C89O4318C91O4333C96O4340,,
code-creation,JS,10,106877,0x31e6451c9a16,33,makeBitMapDescriptor node:internal/streams/readable:127:30,0x31e6f25fae30,~
code-source-info,0x31e6451c9a16,102,3762,3955,C0O3762C9O3772C14O3808C22O3858C32O3953,,
tick,0x7ff809125618,107004,0,0x0,0,0x10c66acb0,0x31e6f25fea16,0x112583feb,0x112583ca1,0x31e6f25f70fc,0x112583feb,0x112583ca1,0x31e6f25f3416,0x112583feb,0x112583ca1,0x31e6f25f1c60,0x112583feb,0x112583ca1,0x31e6f25e4346,0x112583feb,0x112583ca1,0x31e6f25e22c3,0x112583feb,0x112583ca1,0x31e6f25df4ab,0x112583feb,0x112583ca1,0x31e6f25da395,0x112583feb,0x112583ca1,0x31e6f25d7289,0x112583feb,0x31e6f25d6c7a,0x31e6f25d6880,0x31e6f6b607cb,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f25d543c,0x31e6f6b7a501,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,Eval,10,107599,0x31e6451cfa86,5, node:internal/streams/writable:1:1,0x31e6451cee78,~
script-source,107,node:internal/streams/writable,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk\x2C encoding\x2C cb)\x2C and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nconst {\n  ArrayPrototypeSlice\x2C\n  Error\x2C\n  FunctionPrototypeSymbolHasInstance\x2C\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectSetPrototypeOf\x2C\n  StringPrototypeToLowerCase\x2C\n  Symbol\x2C\n  SymbolHasInstance\x2C\n} = primordials;\n\nmodule.exports = Writable;\nWritable.WritableState = WritableState;\n\nconst EE = require('events');\nconst Stream = require('internal/streams/legacy').Stream;\nconst { Buffer } = require('buffer');\nconst destroyImpl = require('internal/streams/destroy');\n\nconst {\n  addAbortSignal\x2C\n} = require('internal/streams/add-abort-signal');\n\nconst {\n  getHighWaterMark\x2C\n  getDefaultHighWaterMark\x2C\n} = require('internal/streams/state');\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_METHOD_NOT_IMPLEMENTED\x2C\n  ERR_MULTIPLE_CALLBACK\x2C\n  ERR_STREAM_CANNOT_PIPE\x2C\n  ERR_STREAM_DESTROYED\x2C\n  ERR_STREAM_ALREADY_FINISHED\x2C\n  ERR_STREAM_NULL_VALUES\x2C\n  ERR_STREAM_WRITE_AFTER_END\x2C\n  ERR_UNKNOWN_ENCODING\x2C\n} = require('internal/errors').codes;\nconst {\n  kState\x2C\n  // bitfields\n  kObjectMode\x2C\n  kErrorEmitted\x2C\n  kAutoDestroy\x2C\n  kEmitClose\x2C\n  kDestroyed\x2C\n  kClosed\x2C\n  kCloseEmitted\x2C\n  kErrored\x2C\n  kConstructed\x2C\n  kOnConstructed\x2C\n} = require('internal/streams/utils');\n\nconst { errorOrDestroy } = destroyImpl;\n\nObjectSetPrototypeOf(Writable.prototype\x2C Stream.prototype);\nObjectSetPrototypeOf(Writable\x2C Stream);\n\nfunction nop() {}\n\nconst kOnFinishedValue = Symbol('kOnFinishedValue');\nconst kErroredValue = Symbol('kErroredValue');\nconst kDefaultEncodingValue = Symbol('kDefaultEncodingValue');\nconst kWriteCbValue = Symbol('kWriteCbValue');\nconst kAfterWriteTickInfoValue = Symbol('kAfterWriteTickInfoValue');\nconst kBufferedValue = Symbol('kBufferedValue');\n\nconst kSync = 1 << 9;\nconst kFinalCalled = 1 << 10;\nconst kNeedDrain = 1 << 11;\nconst kEnding = 1 << 12;\nconst kFinished = 1 << 13;\nconst kDecodeStrings = 1 << 14;\nconst kWriting = 1 << 15;\nconst kBufferProcessing = 1 << 16;\nconst kPrefinished = 1 << 17;\nconst kAllBuffers = 1 << 18;\nconst kAllNoop = 1 << 19;\nconst kOnFinished = 1 << 20;\nconst kHasWritable = 1 << 21;\nconst kWritable = 1 << 22;\nconst kCorked = 1 << 23;\nconst kDefaultUTF8Encoding = 1 << 24;\nconst kWriteCb = 1 << 25;\nconst kExpectWriteCb = 1 << 26;\nconst kAfterWriteTickInfo = 1 << 27;\nconst kAfterWritePending = 1 << 28;\nconst kBuffered = 1 << 29;\nconst kEnded = 1 << 30;\n\n// TODO(benjamingr) it is likely slower to do it this way than with free functions\nfunction makeBitMapDescriptor(bit) {\n  return {\n    enumerable: false\x2C\n    get() { return (this[kState] & bit) !== 0; }\x2C\n    set(value) {\n      if (value) this[kState] |= bit;\n      else this[kState] &= ~bit;\n    }\x2C\n  };\n}\nObjectDefineProperties(WritableState.prototype\x2C {\n  // Object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  objectMode: makeBitMapDescriptor(kObjectMode)\x2C\n\n  // if _final has been called.\n  finalCalled: makeBitMapDescriptor(kFinalCalled)\x2C\n\n  // drain event flag.\n  needDrain: makeBitMapDescriptor(kNeedDrain)\x2C\n\n  // At the start of calling end()\n  ending: makeBitMapDescriptor(kEnding)\x2C\n\n  // When end() has been called\x2C and returned.\n  ended: makeBitMapDescriptor(kEnded)\x2C\n\n  // When 'finish' is emitted.\n  finished: makeBitMapDescriptor(kFinished)\x2C\n\n  // Has it been destroyed.\n  destroyed: makeBitMapDescriptor(kDestroyed)\x2C\n\n  // Should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  decodeStrings: makeBitMapDescriptor(kDecodeStrings)\x2C\n\n  // A flag to see when we're in the middle of a write.\n  writing: makeBitMapDescriptor(kWriting)\x2C\n\n  // A flag to be able to tell if the onwrite cb is called immediately\x2C\n  // or on a later tick.  We set this to true at first\x2C because any\n  // actions that shouldn't happen until "later" should generally also\n  // not happen before the first write call.\n  sync: makeBitMapDescriptor(kSync)\x2C\n\n  // A flag to know if we're processing previously buffered items\x2C which\n  // may call the _write() callback in the same tick\x2C so that we don't\n  // end up in an overlapped onwrite situation.\n  bufferProcessing: makeBitMapDescriptor(kBufferProcessing)\x2C\n\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in\x2C therefore we start as\n  // constructed.\n  constructed: makeBitMapDescriptor(kConstructed)\x2C\n\n  // Emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams.\n  prefinished: makeBitMapDescriptor(kPrefinished)\x2C\n\n  // True if the error was already emitted and should not be thrown again.\n  errorEmitted: makeBitMapDescriptor(kErrorEmitted)\x2C\n\n  // Should close be emitted on destroy. Defaults to true.\n  emitClose: makeBitMapDescriptor(kEmitClose)\x2C\n\n  // Should .destroy() be called after 'finish' (and potentially 'end').\n  autoDestroy: makeBitMapDescriptor(kAutoDestroy)\x2C\n\n  // Indicates whether the stream has finished destroying.\n  closed: makeBitMapDescriptor(kClosed)\x2C\n\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  closeEmitted: makeBitMapDescriptor(kCloseEmitted)\x2C\n\n  allBuffers: makeBitMapDescriptor(kAllBuffers)\x2C\n  allNoop: makeBitMapDescriptor(kAllNoop)\x2C\n\n  // Indicates whether the stream has errored. When true all write() calls\n  // should return false. This is needed since when autoDestroy\n  // is disabled we need a way to tell whether the stream has failed.\n  // This is/should be a cold path.\n  errored: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() { return (this[kState] & kErrored) !== 0 ? this[kErroredValue] : null; }\x2C\n    set(value) {\n      if (value) {\n        this[kErroredValue] = value;\n        this[kState] |= kErrored;\n      } else {\n        this[kState] &= ~kErrored;\n      }\n    }\x2C\n  }\x2C\n\n  writable: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() { return (this[kState] & kHasWritable) !== 0 ? (this[kState] & kWritable) !== 0 : undefined; }\x2C\n    set(value) {\n      if (value == null) {\n        this[kState] &= ~(kHasWritable | kWritable);\n      } else if (value) {\n        this[kState] |= (kHasWritable | kWritable);\n      } else {\n        this[kState] |= kHasWritable;\n        this[kState] &= ~kWritable;\n      }\n    }\x2C\n  }\x2C\n\n  defaultEncoding: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() { return (this[kState] & kDefaultUTF8Encoding) !== 0 ? 'utf8' : this[kDefaultEncodingValue]; }\x2C\n    set(value) {\n      if (value === 'utf8' || value === 'utf-8') {\n        this[kState] |= kDefaultUTF8Encoding;\n      } else {\n        this[kState] &= ~kDefaultUTF8Encoding;\n        this[kDefaultEncodingValue] = value;\n      }\n    }\x2C\n  }\x2C\n\n  // The callback that the user supplies to write(chunk\x2C encoding\x2C cb).\n  writecb: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() { return (this[kState] & kWriteCb) !== 0 ? this[kWriteCbValue] : nop; }\x2C\n    set(value) {\n      if (value) {\n        this[kWriteCbValue] = value;\n        this[kState] |= kWriteCb;\n      } else {\n        this[kState] &= ~kWriteCb;\n      }\n    }\x2C\n  }\x2C\n\n  // Storage for data passed to the afterWrite() callback in case of\n  // synchronous _write() completion.\n  afterWriteTickInfo: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() { return (this[kState] & kAfterWriteTickInfo) !== 0 ? this[kAfterWriteTickInfoValue] : null; }\x2C\n    set(value) {\n      if (value) {\n        this[kAfterWriteTickInfoValue] = value;\n        this[kState] |= kAfterWriteTickInfo;\n      } else {\n        this[kState] &= ~kAfterWriteTickInfo;\n      }\n    }\x2C\n  }\x2C\n\n  buffered: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() { return (this[kState] & kBuffered) !== 0 ? this[kBufferedValue] : []; }\x2C\n    set(value) {\n      this[kBufferedValue] = value;\n      if (value) {\n        this[kState] |= kBuffered;\n      } else {\n        this[kState] &= ~kBuffered;\n      }\n    }\x2C\n  }\x2C\n\n});\n\nfunction WritableState(options\x2C stream\x2C isDuplex) {\n  // Bit map field to store WritableState more effciently with 1 bit per field\n  // instead of a V8 slot per field.\n  this[kState] = kSync | kConstructed | kEmitClose | kAutoDestroy;\n\n  if (options && options.objectMode)\n    this[kState] |= kObjectMode;\n\n  if (isDuplex && options && options.writableObjectMode)\n    this[kState] |= kObjectMode;\n\n  // The point at which write() starts returning false\n  // Note: 0 is a valid value\x2C means that we always return false if\n  // the entire buffer is not flushed immediately on write().\n  this.highWaterMark = options ?\n    getHighWaterMark(this\x2C options\x2C 'writableHighWaterMark'\x2C isDuplex) :\n    getDefaultHighWaterMark(false);\n\n  if (!options || options.decodeStrings !== false) this[kState] |= kDecodeStrings;\n\n  // Should close be emitted on destroy. Defaults to true.\n  if (options && options.emitClose === false) this[kState] &= ~kEmitClose;\n\n  // Should .destroy() be called after 'end' (and potentially 'finish').\n  if (options && options.autoDestroy === false) this[kState] &= ~kAutoDestroy;\n\n  // Crypto is kind of old and crusty.  Historically\x2C its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8'\x2C though.\n  const defaultEncoding = options ? options.defaultEncoding : null;\n  if (defaultEncoding == null || defaultEncoding === 'utf8' || defaultEncoding === 'utf-8') {\n    this[kState] |= kDefaultUTF8Encoding;\n  } else if (Buffer.isEncoding(defaultEncoding)) {\n    this[kState] &= ~kDefaultUTF8Encoding;\n    this[kDefaultEncodingValue] = defaultEncoding;\n  } else {\n    throw new ERR_UNKNOWN_ENCODING(defaultEncoding);\n  }\n\n  // Not an actual buffer we keep track of\x2C but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // When true all writes will be buffered until .uncork() call.\n  this.corked = 0;\n\n  // The callback that's passed to _write(chunk\x2C cb).\n  this.onwrite = onwrite.bind(undefined\x2C stream);\n\n  // The amount that is being written when _write is called.\n  this.writelen = 0;\n\n  resetBuffer(this);\n\n  // Number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted.\n  this.pendingcb = 0;\n}\n\nfunction resetBuffer(state) {\n  state[kBufferedValue] = null;\n  state.bufferedIndex = 0;\n  state[kState] |= kAllBuffers | kAllNoop;\n  state[kState] &= ~kBuffered;\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  return (this[kState] & kBuffered) === 0 ? [] : ArrayPrototypeSlice(this.buffered\x2C this.bufferedIndex);\n};\n\nObjectDefineProperty(WritableState.prototype\x2C 'bufferedRequestCount'\x2C {\n  __proto__: null\x2C\n  get() {\n    return (this[kState] & kBuffered) === 0 ? 0 : this[kBufferedValue].length - this.bufferedIndex;\n  }\x2C\n});\n\nWritableState.prototype[kOnConstructed] = function onConstructed(stream) {\n  if ((this[kState] & kWriting) === 0) {\n    clearBuffer(stream\x2C this);\n  }\n\n  if ((this[kState] & kEnding) !== 0) {\n    finishMaybe(stream\x2C this);\n  }\n};\n\nfunction Writable(options) {\n  if (!(this instanceof Writable))\n    return new Writable(options);\n\n  this._events ??= {\n    close: undefined\x2C\n    error: undefined\x2C\n    prefinish: undefined\x2C\n    finish: undefined\x2C\n    drain: undefined\x2C\n    // Skip uncommon events...\n    // [destroyImpl.kConstruct]: undefined\x2C\n    // [destroyImpl.kDestroy]: undefined\x2C\n  };\n\n  this._writableState = new WritableState(options\x2C this\x2C false);\n\n  if (options) {\n    if (typeof options.write === 'function')\n      this._write = options.write;\n\n    if (typeof options.writev === 'function')\n      this._writev = options.writev;\n\n    if (typeof options.destroy === 'function')\n      this._destroy = options.destroy;\n\n    if (typeof options.final === 'function')\n      this._final = options.final;\n\n    if (typeof options.construct === 'function')\n      this._construct = options.construct;\n\n    if (options.signal)\n      addAbortSignal(options.signal\x2C this);\n  }\n\n  Stream.call(this\x2C options);\n\n  if (this._construct != null) {\n    destroyImpl.construct(this\x2C () => {\n      this._writableState[kOnConstructed](this);\n    });\n  }\n}\n\nObjectDefineProperty(Writable\x2C SymbolHasInstance\x2C {\n  __proto__: null\x2C\n  value: function(object) {\n    if (FunctionPrototypeSymbolHasInstance(this\x2C object)) return true;\n    if (this !== Writable) return false;\n\n    return object && object._writableState instanceof WritableState;\n  }\x2C\n});\n\n// Otherwise people can pipe Writable streams\x2C which is just wrong.\nWritable.prototype.pipe = function() {\n  errorOrDestroy(this\x2C new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction _write(stream\x2C chunk\x2C encoding\x2C cb) {\n  const state = stream._writableState;\n\n  if (cb == null || typeof cb !== 'function') {\n    cb = nop;\n  }\n\n  if (chunk === null) {\n    throw new ERR_STREAM_NULL_VALUES();\n  }\n\n  if ((state[kState] & kObjectMode) === 0) {\n    if (!encoding) {\n      encoding = (state[kState] & kDefaultUTF8Encoding) !== 0 ? 'utf8' : state.defaultEncoding;\n    } else if (encoding !== 'buffer' && !Buffer.isEncoding(encoding)) {\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    }\n\n    if (typeof chunk === 'string') {\n      if ((state[kState] & kDecodeStrings) !== 0) {\n        chunk = Buffer.from(chunk\x2C encoding);\n        encoding = 'buffer';\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = 'buffer';\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk);\n      encoding = 'buffer';\n    } else {\n      throw new ERR_INVALID_ARG_TYPE(\n        'chunk'\x2C ['string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C chunk);\n    }\n  }\n\n  let err;\n  if ((state[kState] & kEnding) !== 0) {\n    err = new ERR_STREAM_WRITE_AFTER_END();\n  } else if ((state[kState] & kDestroyed) !== 0) {\n    err = new ERR_STREAM_DESTROYED('write');\n  }\n\n  if (err) {\n    process.nextTick(cb\x2C err);\n    errorOrDestroy(stream\x2C err\x2C true);\n    return err;\n  }\n\n  state.pendingcb++;\n  return writeOrBuffer(stream\x2C state\x2C chunk\x2C encoding\x2C cb);\n}\n\nWritable.prototype.write = function(chunk\x2C encoding\x2C cb) {\n  if (encoding != null && typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  return _write(this\x2C chunk\x2C encoding\x2C cb) === true;\n};\n\nWritable.prototype.cork = function() {\n  const state = this._writableState;\n\n  state[kState] |= kCorked;\n  state.corked++;\n};\n\nWritable.prototype.uncork = function() {\n  const state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.corked) {\n      state[kState] &= ~kCorked;\n    }\n\n    if ((state[kState] & kWriting) === 0)\n      clearBuffer(this\x2C state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string')\n    encoding = StringPrototypeToLowerCase(encoding);\n  if (!Buffer.isEncoding(encoding))\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\n// If we're already writing something\x2C then just put this\n// in the queue\x2C and wait our turn.  Otherwise\x2C call _write\n// If we return false\x2C then we need a drain event\x2C so set that flag.\nfunction writeOrBuffer(stream\x2C state\x2C chunk\x2C encoding\x2C callback) {\n  const len = (state[kState] & kObjectMode) !== 0 ? 1 : chunk.length;\n\n  state.length += len;\n\n  if ((state[kState] & (kWriting | kErrored | kCorked | kConstructed)) !== kConstructed) {\n    if ((state[kState] & kBuffered) === 0) {\n      state[kState] |= kBuffered;\n      state[kBufferedValue] = [];\n    }\n\n    state[kBufferedValue].push({ chunk\x2C encoding\x2C callback });\n    if ((state[kState] & kAllBuffers) !== 0 && encoding !== 'buffer') {\n      state[kState] &= ~kAllBuffers;\n    }\n    if ((state[kState] & kAllNoop) !== 0 && callback !== nop) {\n      state[kState] &= ~kAllNoop;\n    }\n  } else {\n    state.writelen = len;\n    if (callback !== nop) {\n      state.writecb = callback;\n    }\n    state[kState] |= kWriting | kSync | kExpectWriteCb;\n    stream._write(chunk\x2C encoding\x2C state.onwrite);\n    state[kState] &= ~kSync;\n  }\n\n  const ret = state.length < state.highWaterMark;\n\n  if (!ret) {\n    state[kState] |= kNeedDrain;\n  }\n\n  // Return false if errored or destroyed in order to break\n  // any synchronous while(stream.write(data)) loops.\n  return ret && (state[kState] & (kDestroyed | kErrored)) === 0;\n}\n\nfunction doWrite(stream\x2C state\x2C writev\x2C len\x2C chunk\x2C encoding\x2C cb) {\n  state.writelen = len;\n  if (cb !== nop) {\n    state.writecb = cb;\n  }\n  state[kState] |= kWriting | kSync | kExpectWriteCb;\n  if ((state[kState] & kDestroyed) !== 0)\n    state.onwrite(new ERR_STREAM_DESTROYED('write'));\n  else if (writev)\n    stream._writev(chunk\x2C state.onwrite);\n  else\n    stream._write(chunk\x2C encoding\x2C state.onwrite);\n  state[kState] &= ~kSync;\n}\n\nfunction onwriteError(stream\x2C state\x2C er\x2C cb) {\n  --state.pendingcb;\n\n  cb(er);\n  // Ensure callbacks are invoked even when autoDestroy is\n  // not enabled. Passing `er` here doesn't make sense since\n  // it's related to one specific write\x2C not to the buffered\n  // writes.\n  errorBuffer(state);\n  // This can emit error\x2C but error must always follow cb.\n  errorOrDestroy(stream\x2C er);\n}\n\nfunction onwrite(stream\x2C er) {\n  const state = stream._writableState;\n\n  if ((state[kState] & kExpectWriteCb) === 0) {\n    errorOrDestroy(stream\x2C new ERR_MULTIPLE_CALLBACK());\n    return;\n  }\n\n  const sync = (state[kState] & kSync) !== 0;\n  const cb = (state[kState] & kWriteCb) !== 0 ? state[kWriteCbValue] : nop;\n\n  state[kState] &= ~(kWriting | kExpectWriteCb | kWriteCb);\n  state.length -= state.writelen;\n  state.writelen = 0;\n\n  if (er) {\n    // Avoid V8 leak\x2C https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    er.stack; // eslint-disable-line no-unused-expressions\n\n    if ((state[kState] & kErrored) === 0) {\n      state[kErroredValue] = er;\n      state[kState] |= kErrored;\n    }\n\n    // In case of duplex streams we need to notify the readable side of the\n    // error.\n    if (stream._readableState && !stream._readableState.errored) {\n      stream._readableState.errored = er;\n    }\n\n    if (sync) {\n      process.nextTick(onwriteError\x2C stream\x2C state\x2C er\x2C cb);\n    } else {\n      onwriteError(stream\x2C state\x2C er\x2C cb);\n    }\n  } else {\n    if ((state[kState] & kBuffered) !== 0) {\n      clearBuffer(stream\x2C state);\n    }\n\n    if (sync) {\n      const needDrain = (state[kState] & kNeedDrain) !== 0 && state.length === 0;\n      const needTick = needDrain || (state[kState] & kDestroyed !== 0) || cb !== nop;\n\n      // It is a common case that the callback passed to .write() is always\n      // the same. In that case\x2C we do not schedule a new nextTick()\x2C but\n      // rather just increase a counter\x2C to improve performance and avoid\n      // memory allocations.\n      if (cb === nop) {\n        if ((state[kState] & kAfterWritePending) === 0 && needTick) {\n          process.nextTick(afterWrite\x2C stream\x2C state\x2C 1\x2C cb);\n          state[kState] |= kAfterWritePending;\n        } else {\n          state.pendingcb--;\n          if ((state[kState] & kEnding) !== 0) {\n            finishMaybe(stream\x2C state\x2C true);\n          }\n        }\n      } else if ((state[kState] & kAfterWriteTickInfo) !== 0 &&\n                 state[kAfterWriteTickInfoValue].cb === cb) {\n        state[kAfterWriteTickInfoValue].count++;\n      } else if (needTick) {\n        state[kAfterWriteTickInfoValue] = { count: 1\x2C cb\x2C stream\x2C state };\n        process.nextTick(afterWriteTick\x2C state[kAfterWriteTickInfoValue]);\n        state[kState] |= (kAfterWritePending | kAfterWriteTickInfo);\n      } else {\n        state.pendingcb--;\n        if ((state[kState] & kEnding) !== 0) {\n          finishMaybe(stream\x2C state\x2C true);\n        }\n      }\n    } else {\n      afterWrite(stream\x2C state\x2C 1\x2C cb);\n    }\n  }\n}\n\nfunction afterWriteTick({ stream\x2C state\x2C count\x2C cb }) {\n  state[kState] &= ~kAfterWriteTickInfo;\n  state[kAfterWriteTickInfoValue] = null;\n  return afterWrite(stream\x2C state\x2C count\x2C cb);\n}\n\nfunction afterWrite(stream\x2C state\x2C count\x2C cb) {\n  state[kState] &= ~kAfterWritePending;\n\n  const needDrain = (state[kState] & (kEnding | kNeedDrain | kDestroyed)) === kNeedDrain && state.length === 0;\n  if (needDrain) {\n    state[kState] &= ~kNeedDrain;\n    stream.emit('drain');\n  }\n\n  while (count-- > 0) {\n    state.pendingcb--;\n    cb(null);\n  }\n\n  if ((state[kState] & kDestroyed) !== 0) {\n    errorBuffer(state);\n  }\n\n  if ((state[kState] & kEnding) !== 0) {\n    finishMaybe(stream\x2C state\x2C true);\n  }\n}\n\n// If there's something in the buffer waiting\x2C then invoke callbacks.\nfunction errorBuffer(state) {\n  if ((state[kState] & kWriting) !== 0) {\n    return;\n  }\n\n  if ((state[kState] & kBuffered) !== 0) {\n    for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {\n      const { chunk\x2C callback } = state[kBufferedValue][n];\n      const len = (state[kState] & kObjectMode) !== 0 ? 1 : chunk.length;\n      state.length -= len;\n      callback(state.errored ?? new ERR_STREAM_DESTROYED('write'));\n    }\n  }\n\n\n  callFinishedCallbacks(state\x2C state.errored ?? new ERR_STREAM_DESTROYED('end'));\n\n  resetBuffer(state);\n}\n\n// If there's something in the buffer waiting\x2C then process it.\nfunction clearBuffer(stream\x2C state) {\n  if ((state[kState] & (kDestroyed | kBufferProcessing | kCorked | kBuffered)) !== kBuffered) {\n    return;\n  }\n\n  const objectMode = (state[kState] & kObjectMode) !== 0;\n  const { [kBufferedValue]: buffered\x2C bufferedIndex } = state;\n  const bufferedLength = buffered.length - bufferedIndex;\n\n  if (!bufferedLength) {\n    return;\n  }\n\n  let i = bufferedIndex;\n\n  state[kState] |= kBufferProcessing;\n  if (bufferedLength > 1 && stream._writev) {\n    state.pendingcb -= bufferedLength - 1;\n\n    const callback = (state[kState] & kAllNoop) !== 0 ? nop : (err) => {\n      for (let n = i; n < buffered.length; ++n) {\n        buffered[n].callback(err);\n      }\n    };\n    // Make a copy of `buffered` if it's going to be used by `callback` above\x2C\n    // since `doWrite` will mutate the array.\n    const chunks = (state[kState] & kAllNoop) !== 0 && i === 0 ?\n      buffered : ArrayPrototypeSlice(buffered\x2C i);\n    chunks.allBuffers = (state[kState] & kAllBuffers) !== 0;\n\n    doWrite(stream\x2C state\x2C true\x2C state.length\x2C chunks\x2C ''\x2C callback);\n\n    resetBuffer(state);\n  } else {\n    do {\n      const { chunk\x2C encoding\x2C callback } = buffered[i];\n      buffered[i++] = null;\n      const len = objectMode ? 1 : chunk.length;\n      doWrite(stream\x2C state\x2C false\x2C len\x2C chunk\x2C encoding\x2C callback);\n    } while (i < buffered.length && (state[kState] & kWriting) === 0);\n\n    if (i === buffered.length) {\n      resetBuffer(state);\n    } else if (i > 256) {\n      buffered.splice(0\x2C i);\n      state.bufferedIndex = 0;\n    } else {\n      state.bufferedIndex = i;\n    }\n  }\n  state[kState] &= ~kBufferProcessing;\n}\n\nWritable.prototype._write = function(chunk\x2C encoding\x2C cb) {\n  if (this._writev) {\n    this._writev([{ chunk\x2C encoding }]\x2C cb);\n  } else {\n    throw new ERR_METHOD_NOT_IMPLEMENTED('_write()');\n  }\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk\x2C encoding\x2C cb) {\n  const state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  let err;\n\n  if (chunk != null) {\n    const ret = _write(this\x2C chunk\x2C encoding);\n    if (ret instanceof Error) {\n      err = ret;\n    }\n  }\n\n  // .end() fully uncorks.\n  if ((state[kState] & kCorked) !== 0) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  if (err) {\n    // Do nothing...\n  } else if ((state[kState] & (kEnding | kErrored)) === 0) {\n    // This is forgiving in terms of unnecessary calls to end() and can hide\n    // logic errors. However\x2C usually such errors are harmless and causing a\n    // hard error can be disproportionately destructive. It is not always\n    // trivial for the user to determine whether end() needs to be called\n    // or not.\n\n    state[kState] |= kEnding;\n    finishMaybe(this\x2C state\x2C true);\n    state[kState] |= kEnded;\n  } else if ((state[kState] & kFinished) !== 0) {\n    err = new ERR_STREAM_ALREADY_FINISHED('end');\n  } else if ((state[kState] & kDestroyed) !== 0) {\n    err = new ERR_STREAM_DESTROYED('end');\n  }\n\n  if (typeof cb === 'function') {\n    if (err) {\n      process.nextTick(cb\x2C err);\n    } else if ((state[kState] & kErrored) !== 0) {\n      process.nextTick(cb\x2C state[kErroredValue]);\n    } else if ((state[kState] & kFinished) !== 0) {\n      process.nextTick(cb\x2C null);\n    } else {\n      state[kState] |= kOnFinished;\n      state[kOnFinishedValue] ??= [];\n      state[kOnFinishedValue].push(cb);\n    }\n  }\n\n  return this;\n};\n\nfunction needFinish(state) {\n  return (\n    // State is ended && constructed but not destroyed\x2C finished\x2C writing\x2C errorEmitted or closedEmitted\n    (state[kState] & (\n      kEnding |\n          kDestroyed |\n          kConstructed |\n          kFinished |\n          kWriting |\n          kErrorEmitted |\n          kCloseEmitted |\n          kErrored |\n          kBuffered\n    )) === (kEnding | kConstructed) && state.length === 0);\n}\n\nfunction onFinish(stream\x2C state\x2C err) {\n  if ((state[kState] & kPrefinished) !== 0) {\n    errorOrDestroy(stream\x2C err ?? ERR_MULTIPLE_CALLBACK());\n    return;\n  }\n  state.pendingcb--;\n  if (err) {\n    callFinishedCallbacks(state\x2C err);\n    errorOrDestroy(stream\x2C err\x2C (state[kState] & kSync) !== 0);\n  } else if (needFinish(state)) {\n    state[kState] |= kPrefinished;\n    stream.emit('prefinish');\n    // Backwards compat. Don't check state.sync here.\n    // Some streams assume 'finish' will be emitted\n    // asynchronously relative to _final callback.\n    state.pendingcb++;\n    process.nextTick(finish\x2C stream\x2C state);\n  }\n}\n\nfunction prefinish(stream\x2C state) {\n  if ((state[kState] & (kPrefinished | kFinalCalled)) !== 0) {\n    return;\n  }\n\n  if (typeof stream._final === 'function' && (state[kState] & kDestroyed) === 0) {\n    state[kState] |= kFinalCalled | kSync;\n    state.pendingcb++;\n\n    try {\n      stream._final((err) => onFinish(stream\x2C state\x2C err));\n    } catch (err) {\n      onFinish(stream\x2C state\x2C err);\n    }\n\n    state[kState] &= ~kSync;\n  } else {\n    state[kState] |= kFinalCalled | kPrefinished;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream\x2C state\x2C sync) {\n  if (needFinish(state)) {\n    prefinish(stream\x2C state);\n    if (state.pendingcb === 0) {\n      if (sync) {\n        state.pendingcb++;\n        process.nextTick((stream\x2C state) => {\n          if (needFinish(state)) {\n            finish(stream\x2C state);\n          } else {\n            state.pendingcb--;\n          }\n        }\x2C stream\x2C state);\n      } else if (needFinish(state)) {\n        state.pendingcb++;\n        finish(stream\x2C state);\n      }\n    }\n  }\n}\n\nfunction finish(stream\x2C state) {\n  state.pendingcb--;\n  state[kState] |= kFinished;\n\n  callFinishedCallbacks(state\x2C null);\n\n  stream.emit('finish');\n\n  if ((state[kState] & kAutoDestroy) !== 0) {\n    // In case of duplex streams we need a way to detect\n    // if the readable side is ready for autoDestroy as well.\n    const rState = stream._readableState;\n    const autoDestroy = !rState || (\n      rState.autoDestroy &&\n      // We don't expect the readable to ever 'end'\n      // if readable is explicitly set to false.\n      (rState.endEmitted || rState.readable === false)\n    );\n    if (autoDestroy) {\n      stream.destroy();\n    }\n  }\n}\n\nfunction callFinishedCallbacks(state\x2C err) {\n  if ((state[kState] & kOnFinished) === 0) {\n    return;\n  }\n\n  const onfinishCallbacks = state[kOnFinishedValue];\n  state[kOnFinishedValue] = null;\n  state[kState] &= ~kOnFinished;\n  for (let i = 0; i < onfinishCallbacks.length; i++) {\n    onfinishCallbacks[i](err);\n  }\n}\n\nObjectDefineProperties(Writable.prototype\x2C {\n  closed: {\n    __proto__: null\x2C\n    get() {\n      return this._writableState ? (this._writableState[kState] & kClosed) !== 0 : false;\n    }\x2C\n  }\x2C\n\n  destroyed: {\n    __proto__: null\x2C\n    get() {\n      return this._writableState ? (this._writableState[kState] & kDestroyed) !== 0 : false;\n    }\x2C\n    set(value) {\n      // Backward compatibility\x2C the user is explicitly managing destroyed.\n      if (!this._writableState) return;\n\n      if (value) this._writableState[kState] |= kDestroyed;\n      else this._writableState[kState] &= ~kDestroyed;\n    }\x2C\n  }\x2C\n\n  writable: {\n    __proto__: null\x2C\n    get() {\n      const w = this._writableState;\n      // w.writable === false means that this is part of a Duplex stream\n      // where the writable side was disabled upon construction.\n      // Compat. The user might manually disable writable side through\n      // deprecated setter.\n      return !!w && w.writable !== false && !w.errored &&\n        (w[kState] & (kEnding | kEnded | kDestroyed)) === 0;\n    }\x2C\n    set(val) {\n      // Backwards compatible.\n      if (this._writableState) {\n        this._writableState.writable = !!val;\n      }\n    }\x2C\n  }\x2C\n\n  writableFinished: {\n    __proto__: null\x2C\n    get() {\n      const state = this._writableState;\n      return state ? (state[kState] & kFinished) !== 0 : false;\n    }\x2C\n  }\x2C\n\n  writableObjectMode: {\n    __proto__: null\x2C\n    get() {\n      const state = this._writableState;\n      return state ? (state[kState] & kObjectMode) !== 0 : false;\n    }\x2C\n  }\x2C\n\n  writableBuffer: {\n    __proto__: null\x2C\n    get() {\n      const state = this._writableState;\n      return state && state.getBuffer();\n    }\x2C\n  }\x2C\n\n  writableEnded: {\n    __proto__: null\x2C\n    get() {\n      const state = this._writableState;\n      return state ? (state[kState] & kEnding) !== 0 : false;\n    }\x2C\n  }\x2C\n\n  writableNeedDrain: {\n    __proto__: null\x2C\n    get() {\n      const state = this._writableState;\n      return state ? (state[kState] & (kDestroyed | kEnding | kNeedDrain)) === kNeedDrain : false;\n    }\x2C\n  }\x2C\n\n  writableHighWaterMark: {\n    __proto__: null\x2C\n    get() {\n      const state = this._writableState;\n      return state && state.highWaterMark;\n    }\x2C\n  }\x2C\n\n  writableCorked: {\n    __proto__: null\x2C\n    get() {\n      const state = this._writableState;\n      return state ? state.corked : 0;\n    }\x2C\n  }\x2C\n\n  writableLength: {\n    __proto__: null\x2C\n    get() {\n      const state = this._writableState;\n      return state && state.length;\n    }\x2C\n  }\x2C\n\n  errored: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() {\n      const state = this._writableState;\n      return state ? state.errored : null;\n    }\x2C\n  }\x2C\n\n  writableAborted: {\n    __proto__: null\x2C\n    get: function() {\n      const state = this._writableState;\n      return (\n        (state[kState] & (kHasWritable | kWritable)) !== kHasWritable &&\n        (state[kState] & (kDestroyed | kErrored)) !== 0 &&\n        (state[kState] & kFinished) === 0\n      );\n    }\x2C\n  }\x2C\n});\n\nconst destroy = destroyImpl.destroy;\nWritable.prototype.destroy = function(err\x2C cb) {\n  const state = this._writableState;\n\n  // Invoke pending callbacks.\n  if ((state[kState] & (kBuffered | kOnFinished)) !== 0 && (state[kState] & kDestroyed) === 0) {\n    process.nextTick(errorBuffer\x2C state);\n  }\n\n  destroy.call(this\x2C err\x2C cb);\n  return this;\n};\n\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function(err\x2C cb) {\n  cb(err);\n};\n\nWritable.prototype[EE.captureRejectionSymbol] = function(err) {\n  this.destroy(err);\n};\n\nlet webStreamsAdapters;\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined)\n    webStreamsAdapters = require('internal/webstreams/adapters');\n  return webStreamsAdapters;\n}\n\nWritable.fromWeb = function(writableStream\x2C options) {\n  return lazyWebStreams().newStreamWritableFromWritableStream(\n    writableStream\x2C\n    options);\n};\n\nWritable.toWeb = function(streamWritable) {\n  return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);\n};\n
code-source-info,0x31e6451cfa86,107,0,33049,C0O0C4O33049,,
code-creation,JS,10,109573,0x31e6451d1f46,2109, node:internal/streams/writable:1:1,0x31e6451cfa00,~
code-source-info,0x31e6451d1f46,107,0,33049,C0O0C321O1316C327O1339C333O1348C339O1386C344O1410C349O1436C354O1460C360O1490C365O1500C370O1537C372O1552C376O1564C381O1587C385O1616C391O1616C396O1650C402O1650C407O1684C411O1650C413O1712C419O1712C424O1701C430O1751C436O1751C440O1751C442O1819C448O1819C453O1799C459O1925C465O1925C470O1876C476O1896C482O2212C488O2212C493O2238C498O1970C504O1994C510O2024C516O2049C522O2075C528O2099C534O2130C540O2156C546O2186C552O2433C558O2433C563O2256C569O2281C575O2296C581O2313C587O2329C593O2343C599O2357C605O2368C611O2385C617O2397C623O2413C629O2496C632O2477C638O2510C641O2540C649O2558C654O2510C659O2570C665O2570C670O2655C673O2655C677O2655C679O2705C682O2705C686O2705C688O2760C691O2760C695O2760C697O2815C700O2815C704O2815C706O2873C709O2873C713O2873C715O2932C718O2932C722O2932C724O2973C728O2973C730O3002C734O3002C736O3030C740O3030C742O3055C746O3055C748O3082C752O3082C754O3114C758O3114C760O3140C766O3140C768O3175C774O3175C776O3205C782O3205C784O3234C790O3234C792O3260C798O3260C800O3289C806O3289C808O3319C814O3319C816O3346C822O3346C824O3371C830O3371C832O3409C838O3409C840O3435C846O3435C848O3467C854O3467C856O3504C862O3504C864O3540C870O3540C872O3567C878O3567C880O3591C886O3591C888O3907C891O3944C904O4068C915O4151C926O4224C937O4304C948O4392C959O4466C970O4541C981O4763C992O4869C1003O5166C1014O5408C1025O5647C1036O5826C1047O5954C1058O6064C1069O6187C1080O6293C1091O6433C1102O6485C1113O6531C1121O6820C1126O6870C1134O6954C1148O7140C1153O7190C1161O7296C1175O7596C1180O7646C1188O7752C1202O8073C1207O8123C1215O8206C1229O8509C1234O8559C1242O8665C1256O8884C1261O8934C1269O9018C1283O3907C1288O11667C1291O11681C1300O11701C1304O11835C1307O11870C1320O11928C1328O11835C1333O12046C1336O12060C1344O12070C1348O12086C1352O13385C1355O13416C1360O13465C1371O13385C1376O13744C1379O13753C1388O13768C1392O15224C1395O15233C1404O15249C1408O15445C1411O15454C1420O15469C1428O15572C1431O15581C1440O15598C1448O15841C1451O15850C1460O15879C1468O24021C1471O24030C1480O24047C1488O24221C1491O24230C1497O24248C1505O24257C1508O24266C1517O24280C1525O28978C1528O29010C1541O29033C1549O29060C1571O29184C1579O29211C1591O29323C1613O29593C1621O29620C1633O30032C1655O30194C1663O30221C1685O30369C1693O30396C1715O30542C1723O30569C1745O30689C1753O30716C1775O30861C1783O30888C1805O31074C1813O31101C1835O31224C1843O31251C1865O31370C1873O31397C1895O31506C1903O31556C1925O31680C1933O31712C1955O28978C1965O31997C1968O32009C1976O31997C1978O32018C1981O32027C1990O32045C1998O32330C2001O32339C2009O32374C2017O32360C2025O32385C2028O32394C2037O32413C2045O32450C2048O32459C2053O32472C2066O32496C2074O32543C2075O32543C2077O32767C2084O32784C2092O32923C2099O32938C2108O33048,,
tick,0x7ff8092c91ac,109740,1,0x10c1e6120,3,0x10c41e000,0x112583f26,0x112583ca1,0x31e6f25f7108,0x112583feb,0x112583ca1,0x31e6f25f3416,0x112583feb,0x112583ca1,0x31e6f25f1c60,0x112583feb,0x112583ca1,0x31e6f25e4346,0x112583feb,0x112583ca1,0x31e6f25e22c3,0x112583feb,0x112583ca1,0x31e6f25df4ab,0x112583feb,0x112583ca1,0x31e6f25da395,0x112583feb,0x112583ca1,0x31e6f25d7289,0x112583feb,0x31e6f25d6c7a,0x31e6f25d6880,0x31e6f6b607cb,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f25d543c,0x31e6f6b7a501,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
tick,0x7ff809303924,109764,1,0x10c1e6120,3,0x10c41e000,0x112583f26,0x112583ca1,0x31e6f25f7108,0x112583feb,0x112583ca1,0x31e6f25f3416,0x112583feb,0x112583ca1,0x31e6f25f1c60,0x112583feb,0x112583ca1,0x31e6f25e4346,0x112583feb,0x112583ca1,0x31e6f25e22c3,0x112583feb,0x112583ca1,0x31e6f25df4ab,0x112583feb,0x112583ca1,0x31e6f25da395,0x112583feb,0x112583ca1,0x31e6f25d7289,0x112583feb,0x31e6f25d6c7a,0x31e6f25d6880,0x31e6f6b607cb,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f25d543c,0x31e6f6b7a501,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,109955,0x31e6451d62ae,33,makeBitMapDescriptor node:internal/streams/writable:120:30,0x31e6451cfb08,~
code-source-info,0x31e6451d62ae,107,3713,3906,C0O3713C9O3723C14O3759C22O3809C32O3904,,
code-creation,Eval,10,110236,0x31e6451dabce,5, node:stream/promises:1:1,0x31e6451daa28,~
script-source,108,node:stream/promises,'use strict';\n\nconst {\n  ArrayPrototypePop\x2C\n  Promise\x2C\n} = primordials;\n\nconst {\n  isIterable\x2C\n  isNodeStream\x2C\n  isWebStream\x2C\n} = require('internal/streams/utils');\n\nconst { pipelineImpl: pl } = require('internal/streams/pipeline');\nconst { finished } = require('internal/streams/end-of-stream');\n\nrequire('stream');\n\nfunction pipeline(...streams) {\n  return new Promise((resolve\x2C reject) => {\n    let signal;\n    let end;\n    const lastArg = streams[streams.length - 1];\n    if (lastArg && typeof lastArg === 'object' &&\n        !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {\n      const options = ArrayPrototypePop(streams);\n      signal = options.signal;\n      end = options.end;\n    }\n\n    pl(streams\x2C (err\x2C value) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(value);\n      }\n    }\x2C { signal\x2C end });\n  });\n}\n\nmodule.exports = {\n  finished\x2C\n  pipeline\x2C\n};\n
code-source-info,0x31e6451dabce,108,0,917,C0O0C4O917,,
code-creation,JS,10,110322,0x31e6451dad4e,125, node:stream/promises:1:1,0x31e6451dab48,~
code-source-info,0x31e6451dad4e,108,0,917,C0O0C28O25C34O46C40O130C43O130C48O83C54O97C60O113C66O195C69O195C74O188C80O254C83O254C88O241C93O298C96O298C100O871C107O892C113O904C119O886C124O916,,
code-creation,Eval,10,110578,0x31e6451db7ae,5, node:internal/streams/transform:1:1,0x31e6451db5e8,~
script-source,109,node:internal/streams/transform,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a "filter"\x2C\n// but that's not a great name for it\x2C since that implies a thing where\n// some bits pass through\x2C and others are simply ignored.  (That would\n// be a valid example of a transform\x2C of course.)\n//\n// While the output is causally related to the input\x2C it's not a\n// necessarily symmetric or synchronous transformation.  For example\x2C\n// a zlib stream might take multiple plain-text writes()\x2C and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk)\x2C that calls _write(chunk\x2Ccb)\n// internally\x2C and returns false if there's a lot of pending writes\n// buffered up.  When you call read()\x2C that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream\x2C the written data is placed in a buffer.  When\n// _read(n) is called\x2C it transforms the queued up data\x2C calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks\x2C then the first\n// outputted bit calls the readcb\x2C and subsequent chunks just go into\n// the read buffer\x2C and will cause it to emit 'readable' if necessary.\n//\n// This way\x2C back-pressure is actually determined by the reading side\x2C\n// since _read has to be called to start processing a new chunk.  However\x2C\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example\x2C imagine a stream where every byte of input is\n// interpreted as an integer from 0-255\x2C and then results in that many\n// bytes of output.  Writing the 4 bytes {ff\x2Cff\x2Cff\x2Cff} would result in\n// 1kb of data being output.  In this case\x2C you could write a very small\n// amount of input\x2C and end up with a very large amount of output.  In\n// such a pathological inflating mechanism\x2C there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However\x2C even in such a pathological case\x2C only a single written chunk\n// would be consumed\x2C and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nconst {\n  ObjectSetPrototypeOf\x2C\n  Symbol\x2C\n} = primordials;\n\nmodule.exports = Transform;\nconst {\n  ERR_METHOD_NOT_IMPLEMENTED\x2C\n} = require('internal/errors').codes;\nconst Duplex = require('internal/streams/duplex');\nconst { getHighWaterMark } = require('internal/streams/state');\nObjectSetPrototypeOf(Transform.prototype\x2C Duplex.prototype);\nObjectSetPrototypeOf(Transform\x2C Duplex);\n\nconst kCallback = Symbol('kCallback');\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  // TODO (ronag): This should preferably always be\n  // applied but would be semver-major. Or even better;\n  // make Transform a Readable with the Writable interface.\n  const readableHighWaterMark = options ? getHighWaterMark(this\x2C options\x2C 'readableHighWaterMark'\x2C true) : null;\n  if (readableHighWaterMark === 0) {\n    // A Duplex will buffer both on the writable and readable side while\n    // a Transform just wants to buffer hwm number of elements. To avoid\n    // buffering twice we disable buffering on the writable side.\n    options = {\n      ...options\x2C\n      highWaterMark: null\x2C\n      readableHighWaterMark\x2C\n      writableHighWaterMark: options.writableHighWaterMark || 0\x2C\n    };\n  }\n\n  Duplex.call(this\x2C options);\n\n  // We have implemented the _read method\x2C and done the other things\n  // that Readable wants before the first _read call\x2C so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  this[kCallback] = null;\n\n  if (options) {\n    if (typeof options.transform === 'function')\n      this._transform = options.transform;\n\n    if (typeof options.flush === 'function')\n      this._flush = options.flush;\n  }\n\n  // When the writable side finishes\x2C then flush out anything remaining.\n  // Backwards compat. Some Transform streams incorrectly implement _final\n  // instead of or in addition to _flush. By using 'prefinish' instead of\n  // implementing _final we continue supporting this unfortunate use case.\n  this.on('prefinish'\x2C prefinish);\n}\n\nfunction final(cb) {\n  if (typeof this._flush === 'function' && !this.destroyed) {\n    this._flush((er\x2C data) => {\n      if (er) {\n        if (cb) {\n          cb(er);\n        } else {\n          this.destroy(er);\n        }\n        return;\n      }\n\n      if (data != null) {\n        this.push(data);\n      }\n      this.push(null);\n      if (cb) {\n        cb();\n      }\n    });\n  } else {\n    this.push(null);\n    if (cb) {\n      cb();\n    }\n  }\n}\n\nfunction prefinish() {\n  if (this._final !== final) {\n    final.call(this);\n  }\n}\n\nTransform.prototype._final = final;\n\nTransform.prototype._transform = function(chunk\x2C encoding\x2C callback) {\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_transform()');\n};\n\nTransform.prototype._write = function(chunk\x2C encoding\x2C callback) {\n  const rState = this._readableState;\n  const wState = this._writableState;\n  const length = rState.length;\n\n  this._transform(chunk\x2C encoding\x2C (err\x2C val) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (val != null) {\n      this.push(val);\n    }\n\n    if (rState.ended) {\n      // If user has called this.push(null) we have to\n      // delay the callback to properly progate the new\n      // state.\n      process.nextTick(callback);\n    } else if (\n      wState.ended || // Backwards compat.\n      length === rState.length || // Backwards compat.\n      rState.length < rState.highWaterMark\n    ) {\n      callback();\n    } else {\n      this[kCallback] = callback;\n    }\n  });\n};\n\nTransform.prototype._read = function() {\n  if (this[kCallback]) {\n    const callback = this[kCallback];\n    this[kCallback] = null;\n    callback();\n  }\n};\n
code-source-info,0x31e6451db7ae,109,0,7121,C0O0C4O7121,,
code-creation,JS,10,111052,0x31e6451dbb66,202, node:internal/streams/transform:1:1,0x31e6451db728,~
code-source-info,0x31e6451dbb66,109,0,7121,C0O0C39O3508C44O3532C49O3558C51O3573C55O3628C58O3628C63O3654C68O3596C74O3677C77O3677C81O3677C83O3742C86O3742C91O3721C97O3777C100O3808C108O3826C113O3777C118O3838C124O3838C129O3898C132O3898C136O3898C138O6031C141O6041C148O6058C152O6068C155O6078C164O6099C168O6199C171O6209C180O6226C184O6966C187O6976C196O6992C201O7120,,
tick,0x7ff809333aaa,111121,1,0x10c1e6120,3,0x10c41e000,0x112583f26,0x112583ca1,0x31e6f25e25d0,0x112583feb,0x112583ca1,0x31e6f25df4ab,0x112583feb,0x112583ca1,0x31e6f25da395,0x112583feb,0x112583ca1,0x31e6f25d7289,0x112583feb,0x31e6f25d6c7a,0x31e6f25d6880,0x31e6f6b607cb,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f25d543c,0x31e6f6b7a501,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,Eval,10,111185,0x31e6451dc8be,5, node:internal/streams/passthrough:1:1,0x31e6451dc758,~
script-source,110,node:internal/streams/passthrough,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nconst {\n  ObjectSetPrototypeOf\x2C\n} = primordials;\n\nmodule.exports = PassThrough;\n\nconst Transform = require('internal/streams/transform');\nObjectSetPrototypeOf(PassThrough.prototype\x2C Transform.prototype);\nObjectSetPrototypeOf(PassThrough\x2C Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n\n  Transform.call(this\x2C options);\n}\n\nPassThrough.prototype._transform = function(chunk\x2C encoding\x2C cb) {\n  cb(null\x2C chunk);\n};\n
code-source-info,0x31e6451dc8be,110,0,1762,C0O0C4O1762,,
code-creation,JS,10,111315,0x31e6451dca56,84, node:internal/streams/passthrough:1:1,0x31e6451dc838,~
code-source-info,0x31e6451dca56,110,0,1762,C0O0C14O1288C19O1328C21O1343C25O1377C28O1377C32O1377C34O1416C37O1449C45O1470C50O1416C55O1482C61O1482C66O1673C69O1685C78O1706C83O1761,,
code-creation,Eval,10,111666,0x31e6451df0fe,5, node:internal/error_serdes:1:1,0x31e6451ded68,~
script-source,111,node:internal/error_serdes,'use strict';\n\nconst Buffer = require('buffer').Buffer;\nconst {\n  ArrayPrototypeForEach\x2C\n  Error\x2C\n  EvalError\x2C\n  FunctionPrototypeCall\x2C\n  ObjectAssign\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyNames\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeToString\x2C\n  RangeError\x2C\n  ReferenceError\x2C\n  SafeSet\x2C\n  StringFromCharCode\x2C\n  StringPrototypeSubstring\x2C\n  SymbolToStringTag\x2C\n  SyntaxError\x2C\n  SymbolFor\x2C\n  TypeError\x2C\n  TypedArrayPrototypeGetBuffer\x2C\n  TypedArrayPrototypeGetByteOffset\x2C\n  TypedArrayPrototypeGetByteLength\x2C\n  URIError\x2C\n} = primordials;\nconst { inspect: { custom: customInspectSymbol } } = require('util');\n\nconst kSerializedError = 0;\nconst kSerializedObject = 1;\nconst kInspectedError = 2;\nconst kInspectedSymbol = 3;\nconst kCustomInspectedObject = 4;\n\nconst kSymbolStringLength = 'Symbol('.length;\n\nconst errors = {\n  Error\x2C TypeError\x2C RangeError\x2C URIError\x2C SyntaxError\x2C ReferenceError\x2C EvalError\x2C\n};\nconst errorConstructorNames = new SafeSet(ObjectKeys(errors));\n\nfunction TryGetAllProperties(object\x2C target = object) {\n  const all = { __proto__: null };\n  if (object === null)\n    return all;\n  ObjectAssign(all\x2C\n               TryGetAllProperties(ObjectGetPrototypeOf(object)\x2C target));\n  const keys = ObjectGetOwnPropertyNames(object);\n  ArrayPrototypeForEach(keys\x2C (key) => {\n    let descriptor;\n    try {\n      // TODO: create a null-prototype descriptor with needed properties only\n      descriptor = ObjectGetOwnPropertyDescriptor(object\x2C key);\n    } catch { return; }\n    const getter = descriptor.get;\n    if (getter && key !== '__proto__') {\n      try {\n        descriptor.value = FunctionPrototypeCall(getter\x2C target);\n        delete descriptor.get;\n        delete descriptor.set;\n      } catch {\n        // Continue regardless of error.\n      }\n    }\n    if (key === 'cause') {\n      descriptor.value = serializeError(descriptor.value);\n      all[key] = descriptor;\n    } else if ('value' in descriptor &&\n            typeof descriptor.value !== 'function' && typeof descriptor.value !== 'symbol') {\n      all[key] = descriptor;\n    }\n  });\n  return all;\n}\n\nfunction GetConstructors(object) {\n  const constructors = [];\n\n  for (let current = object;\n    current !== null;\n    current = ObjectGetPrototypeOf(current)) {\n    const desc = ObjectGetOwnPropertyDescriptor(current\x2C 'constructor');\n    if (desc && desc.value) {\n      ObjectDefineProperty(constructors\x2C constructors.length\x2C {\n        __proto__: null\x2C\n        value: desc.value\x2C enumerable: true\x2C\n      });\n    }\n  }\n\n  return constructors;\n}\n\nfunction GetName(object) {\n  const desc = ObjectGetOwnPropertyDescriptor(object\x2C 'name');\n  return desc && desc.value;\n}\n\nlet internalUtilInspect;\nfunction inspect(...args) {\n  if (!internalUtilInspect) {\n    internalUtilInspect = require('internal/util/inspect');\n  }\n  return internalUtilInspect.inspect(...args);\n}\n\nlet serialize;\nfunction serializeError(error) {\n  if (!serialize) serialize = require('v8').serialize;\n  if (typeof error === 'symbol') {\n    return Buffer.from(StringFromCharCode(kInspectedSymbol) + inspect(error)\x2C 'utf8');\n  }\n  try {\n    if (typeof error === 'object' &&\n        ObjectPrototypeToString(error) === '[object Error]') {\n      const constructors = GetConstructors(error);\n      for (let i = 0; i < constructors.length; i++) {\n        const name = GetName(constructors[i]);\n        if (errorConstructorNames.has(name)) {\n          const serialized = serialize({\n            constructor: name\x2C\n            properties: TryGetAllProperties(error)\x2C\n          });\n          return Buffer.concat([Buffer.from([kSerializedError])\x2C serialized]);\n        }\n      }\n    }\n  } catch {\n    // Continue regardless of error.\n  }\n  try {\n    if (error != null && customInspectSymbol in error) {\n      return Buffer.from(StringFromCharCode(kCustomInspectedObject) + inspect(error)\x2C 'utf8');\n    }\n  } catch {\n    // Continue regardless of error.\n  }\n  try {\n    const serialized = serialize(error);\n    return Buffer.concat([Buffer.from([kSerializedObject])\x2C serialized]);\n  } catch {\n    // Continue regardless of error.\n  }\n  return Buffer.from(StringFromCharCode(kInspectedError) + inspect(error)\x2C 'utf8');\n}\n\nfunction fromBuffer(error) {\n  return Buffer.from(TypedArrayPrototypeGetBuffer(error)\x2C\n                     TypedArrayPrototypeGetByteOffset(error) + 1\x2C\n                     TypedArrayPrototypeGetByteLength(error) - 1);\n}\n\nlet deserialize;\nfunction deserializeError(error) {\n  if (!deserialize) deserialize = require('v8').deserialize;\n  switch (error[0]) {\n    case kSerializedError: {\n      const { constructor\x2C properties } = deserialize(error.subarray(1));\n      const ctor = errors[constructor];\n      ObjectDefineProperty(properties\x2C SymbolToStringTag\x2C {\n        __proto__: null\x2C\n        value: { __proto__: null\x2C value: 'Error'\x2C configurable: true }\x2C\n        enumerable: true\x2C\n      });\n      if ('cause' in properties && 'value' in properties.cause) {\n        properties.cause.value = deserializeError(properties.cause.value);\n      }\n      return ObjectCreate(ctor.prototype\x2C properties);\n    }\n    case kSerializedObject:\n      return deserialize(error.subarray(1));\n    case kInspectedError:\n      return fromBuffer(error).toString('utf8');\n    case kInspectedSymbol: {\n      const buf = fromBuffer(error);\n      return SymbolFor(StringPrototypeSubstring(buf.toString('utf8')\x2C kSymbolStringLength\x2C buf.length - 1));\n    }\n    case kCustomInspectedObject:\n      return {\n        __proto__: null\x2C\n        [customInspectSymbol]: () => fromBuffer(error).toString('utf8')\x2C\n      };\n  }\n  require('assert').fail('This should not happen');\n}\n\nmodule.exports = { serializeError\x2C deserializeError };\n
code-source-info,0x31e6451df0fe,111,0,5723,C0O0C4O5723,,
code-creation,JS,10,112091,0x31e6451df5ce,448, node:internal/error_serdes:1:1,0x31e6451df078,~
code-source-info,0x31e6451df5ce,111,0,5723,C0O0C138O30C144O30C149O47C153O30C155O66C161O91C166O100C171O113C177O138C183O154C189O170C195O194C201O228C207O257C213O281C218O295C224O322C229O336C234O354C239O365C245O387C251O415C257O436C262O451C268O464C273O477C279O509C285O545C291O581C296O661C302O661C307O625C312O635C318O704C319O704C321O733C323O733C325O760C327O760C329O788C331O788C333O822C335O822C337O854C340O864C344O854C346O888C353O892C359O899C365O910C371O922C377O932C383O945C389O961C395O888C397O1005C400O1017C407O1005C412O1005C414O2716C415O2716C417O2913C418O2913C420O4448C421O4448C423O5668C430O5687C436O5703C442O5683C447O5722,,
tick,0x7ff8093039b3,112176,1,0x10c1e6120,3,0x10c41e000,0x112583f26,0x112583ca1,0x31e6f25da3e9,0x112583feb,0x112583ca1,0x31e6f25d7289,0x112583feb,0x31e6f25d6c7a,0x31e6f25d6880,0x31e6f6b607cb,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f25d543c,0x31e6f6b7a501,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,Eval,10,112486,0x31e6451e0ee6,5, node:diagnostics_channel:1:1,0x31e6451e0ac0,~
script-source,112,node:diagnostics_channel,'use strict';\n\nconst {\n  ArrayPrototypeAt\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSplice\x2C\n  SafeFinalizationRegistry\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n  PromiseReject\x2C\n  ReflectApply\x2C\n  SafeMap\x2C\n  SymbolHasInstance\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n  }\x2C\n} = require('internal/errors');\nconst {\n  validateFunction\x2C\n} = require('internal/validators');\n\nconst { triggerUncaughtException } = internalBinding('errors');\n\nconst { WeakReference } = require('internal/util');\n\n// Can't delete when weakref count reaches 0 as it could increment again.\n// Only GC can be used as a valid time to clean up the channels map.\nclass WeakRefMap extends SafeMap {\n  #finalizers = new SafeFinalizationRegistry((key) => {\n    this.delete(key);\n  });\n\n  set(key\x2C value) {\n    this.#finalizers.register(value\x2C key);\n    return super.set(key\x2C new WeakReference(value));\n  }\n\n  get(key) {\n    return super.get(key)?.get();\n  }\n\n  incRef(key) {\n    return super.get(key)?.incRef();\n  }\n\n  decRef(key) {\n    return super.get(key)?.decRef();\n  }\n}\n\nfunction markActive(channel) {\n  // eslint-disable-next-line no-use-before-define\n  ObjectSetPrototypeOf(channel\x2C ActiveChannel.prototype);\n  channel._subscribers = [];\n  channel._stores = new SafeMap();\n}\n\nfunction maybeMarkInactive(channel) {\n  // When there are no more active subscribers or bound\x2C restore to fast prototype.\n  if (!channel._subscribers.length && !channel._stores.size) {\n    // eslint-disable-next-line no-use-before-define\n    ObjectSetPrototypeOf(channel\x2C Channel.prototype);\n    channel._subscribers = undefined;\n    channel._stores = undefined;\n  }\n}\n\nfunction defaultTransform(data) {\n  return data;\n}\n\nfunction wrapStoreRun(store\x2C data\x2C next\x2C transform = defaultTransform) {\n  return () => {\n    let context;\n    try {\n      context = transform(data);\n    } catch (err) {\n      process.nextTick(() => {\n        triggerUncaughtException(err\x2C false);\n      });\n      return next();\n    }\n\n    return store.run(context\x2C next);\n  };\n}\n\n// TODO(qard): should there be a C++ channel interface?\nclass ActiveChannel {\n  subscribe(subscription) {\n    validateFunction(subscription\x2C 'subscription');\n    ArrayPrototypePush(this._subscribers\x2C subscription);\n    channels.incRef(this.name);\n  }\n\n  unsubscribe(subscription) {\n    const index = ArrayPrototypeIndexOf(this._subscribers\x2C subscription);\n    if (index === -1) return false;\n\n    ArrayPrototypeSplice(this._subscribers\x2C index\x2C 1);\n\n    channels.decRef(this.name);\n    maybeMarkInactive(this);\n\n    return true;\n  }\n\n  bindStore(store\x2C transform) {\n    const replacing = this._stores.has(store);\n    if (!replacing) channels.incRef(this.name);\n    this._stores.set(store\x2C transform);\n  }\n\n  unbindStore(store) {\n    if (!this._stores.has(store)) {\n      return false;\n    }\n\n    this._stores.delete(store);\n\n    channels.decRef(this.name);\n    maybeMarkInactive(this);\n\n    return true;\n  }\n\n  get hasSubscribers() {\n    return true;\n  }\n\n  publish(data) {\n    for (let i = 0; i < (this._subscribers?.length || 0); i++) {\n      try {\n        const onMessage = this._subscribers[i];\n        onMessage(data\x2C this.name);\n      } catch (err) {\n        process.nextTick(() => {\n          triggerUncaughtException(err\x2C false);\n        });\n      }\n    }\n  }\n\n  runStores(data\x2C fn\x2C thisArg\x2C ...args) {\n    let run = () => {\n      this.publish(data);\n      return ReflectApply(fn\x2C thisArg\x2C args);\n    };\n\n    for (const entry of this._stores.entries()) {\n      const store = entry[0];\n      const transform = entry[1];\n      run = wrapStoreRun(store\x2C data\x2C run\x2C transform);\n    }\n\n    return run();\n  }\n}\n\nclass Channel {\n  constructor(name) {\n    this._subscribers = undefined;\n    this._stores = undefined;\n    this.name = name;\n\n    channels.set(name\x2C this);\n  }\n\n  static [SymbolHasInstance](instance) {\n    const prototype = ObjectGetPrototypeOf(instance);\n    return prototype === Channel.prototype ||\n           prototype === ActiveChannel.prototype;\n  }\n\n  subscribe(subscription) {\n    markActive(this);\n    this.subscribe(subscription);\n  }\n\n  unsubscribe() {\n    return false;\n  }\n\n  bindStore(store\x2C transform) {\n    markActive(this);\n    this.bindStore(store\x2C transform);\n  }\n\n  unbindStore() {\n    return false;\n  }\n\n  get hasSubscribers() {\n    return false;\n  }\n\n  publish() {}\n\n  runStores(data\x2C fn\x2C thisArg\x2C ...args) {\n    return ReflectApply(fn\x2C thisArg\x2C args);\n  }\n}\n\nconst channels = new WeakRefMap();\n\nfunction channel(name) {\n  const channel = channels.get(name);\n  if (channel) return channel;\n\n  if (typeof name !== 'string' && typeof name !== 'symbol') {\n    throw new ERR_INVALID_ARG_TYPE('channel'\x2C ['string'\x2C 'symbol']\x2C name);\n  }\n\n  return new Channel(name);\n}\n\nfunction subscribe(name\x2C subscription) {\n  return channel(name).subscribe(subscription);\n}\n\nfunction unsubscribe(name\x2C subscription) {\n  return channel(name).unsubscribe(subscription);\n}\n\nfunction hasSubscribers(name) {\n  const channel = channels.get(name);\n  if (!channel) return false;\n\n  return channel.hasSubscribers;\n}\n\nconst traceEvents = [\n  'start'\x2C\n  'end'\x2C\n  'asyncStart'\x2C\n  'asyncEnd'\x2C\n  'error'\x2C\n];\n\nfunction assertChannel(value\x2C name) {\n  if (!(value instanceof Channel)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C ['Channel']\x2C value);\n  }\n}\n\nclass TracingChannel {\n  constructor(nameOrChannels) {\n    if (typeof nameOrChannels === 'string') {\n      this.start = channel(`tracing:${nameOrChannels}:start`);\n      this.end = channel(`tracing:${nameOrChannels}:end`);\n      this.asyncStart = channel(`tracing:${nameOrChannels}:asyncStart`);\n      this.asyncEnd = channel(`tracing:${nameOrChannels}:asyncEnd`);\n      this.error = channel(`tracing:${nameOrChannels}:error`);\n    } else if (typeof nameOrChannels === 'object') {\n      const { start\x2C end\x2C asyncStart\x2C asyncEnd\x2C error } = nameOrChannels;\n\n      assertChannel(start\x2C 'nameOrChannels.start');\n      assertChannel(end\x2C 'nameOrChannels.end');\n      assertChannel(asyncStart\x2C 'nameOrChannels.asyncStart');\n      assertChannel(asyncEnd\x2C 'nameOrChannels.asyncEnd');\n      assertChannel(error\x2C 'nameOrChannels.error');\n\n      this.start = start;\n      this.end = end;\n      this.asyncStart = asyncStart;\n      this.asyncEnd = asyncEnd;\n      this.error = error;\n    } else {\n      throw new ERR_INVALID_ARG_TYPE('nameOrChannels'\x2C\n                                     ['string'\x2C 'object'\x2C 'Channel']\x2C\n                                     nameOrChannels);\n    }\n  }\n\n  subscribe(handlers) {\n    for (const name of traceEvents) {\n      if (!handlers[name]) continue;\n\n      this[name]?.subscribe(handlers[name]);\n    }\n  }\n\n  unsubscribe(handlers) {\n    let done = true;\n\n    for (const name of traceEvents) {\n      if (!handlers[name]) continue;\n\n      if (!this[name]?.unsubscribe(handlers[name])) {\n        done = false;\n      }\n    }\n\n    return done;\n  }\n\n  traceSync(fn\x2C context = {}\x2C thisArg\x2C ...args) {\n    const { start\x2C end\x2C error } = this;\n\n    return start.runStores(context\x2C () => {\n      try {\n        const result = ReflectApply(fn\x2C thisArg\x2C args);\n        context.result = result;\n        return result;\n      } catch (err) {\n        context.error = err;\n        error.publish(context);\n        throw err;\n      } finally {\n        end.publish(context);\n      }\n    });\n  }\n\n  tracePromise(fn\x2C context = {}\x2C thisArg\x2C ...args) {\n    const { start\x2C end\x2C asyncStart\x2C asyncEnd\x2C error } = this;\n\n    function reject(err) {\n      context.error = err;\n      error.publish(context);\n      asyncStart.publish(context);\n      // TODO: Is there a way to have asyncEnd _after_ the continuation?\n      asyncEnd.publish(context);\n      return PromiseReject(err);\n    }\n\n    function resolve(result) {\n      context.result = result;\n      asyncStart.publish(context);\n      // TODO: Is there a way to have asyncEnd _after_ the continuation?\n      asyncEnd.publish(context);\n      return result;\n    }\n\n    return start.runStores(context\x2C () => {\n      try {\n        let promise = ReflectApply(fn\x2C thisArg\x2C args);\n        // Convert thenables to native promises\n        if (!(promise instanceof Promise)) {\n          promise = PromiseResolve(promise);\n        }\n        return PromisePrototypeThen(promise\x2C resolve\x2C reject);\n      } catch (err) {\n        context.error = err;\n        error.publish(context);\n        throw err;\n      } finally {\n        end.publish(context);\n      }\n    });\n  }\n\n  traceCallback(fn\x2C position = -1\x2C context = {}\x2C thisArg\x2C ...args) {\n    const { start\x2C end\x2C asyncStart\x2C asyncEnd\x2C error } = this;\n\n    function wrappedCallback(err\x2C res) {\n      if (err) {\n        context.error = err;\n        error.publish(context);\n      } else {\n        context.result = res;\n      }\n\n      // Using runStores here enables manual context failure recovery\n      asyncStart.runStores(context\x2C () => {\n        try {\n          if (callback) {\n            return ReflectApply(callback\x2C this\x2C arguments);\n          }\n        } finally {\n          asyncEnd.publish(context);\n        }\n      });\n    }\n\n    const callback = ArrayPrototypeAt(args\x2C position);\n    if (typeof callback !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE('callback'\x2C ['function']\x2C callback);\n    }\n    ArrayPrototypeSplice(args\x2C position\x2C 1\x2C wrappedCallback);\n\n    return start.runStores(context\x2C () => {\n      try {\n        return ReflectApply(fn\x2C thisArg\x2C args);\n      } catch (err) {\n        context.error = err;\n        error.publish(context);\n        throw err;\n      } finally {\n        end.publish(context);\n      }\n    });\n  }\n}\n\nfunction tracingChannel(nameOrChannels) {\n  return new TracingChannel(nameOrChannels);\n}\n\nmodule.exports = {\n  channel\x2C\n  hasSubscribers\x2C\n  subscribe\x2C\n  tracingChannel\x2C\n  unsubscribe\x2C\n  Channel\x2C\n};\n
code-source-info,0x31e6451e0ee6,112,0,9791,C0O0C4O9791,,
code-creation,JS,10,113122,0x31e6451e2876,616, node:diagnostics_channel:1:1,0x31e6451e0e60,~
code-source-info,0x31e6451e2876,112,0,9791,C0O0C131O25C137O45C143O70C149O92C155O116C161O144C167O168C173O192C179O203C185O227C191O245C197O262C203O278C209O289C214O380C217O380C222O343C227O349C233O440C236O440C241O418C247O510C250O510C255O481C261O564C264O564C269O546C297O759C354O734C409O2160C427O3888C503O3717C505O4516C507O4516C512O4516C514O5148C518O5148C565O5359C567O9683C574O9704C580O9715C586O9733C592O9746C598O9764C604O9779C610O9698C615O9790,,
code-creation,JS,10,113161,0x31e6451e2c56,40,<instance_members_initializer> node:diagnostics_channel:35:1,0x31e6451e13c8,~
code-source-info,0x31e6451e2c56,112,734,1143,C0O734C14O785C28O785C39O1143,,
tick,0x7ff809303aef,113189,1,0x10c1e6120,3,0x10c41e000,0x112583f26,0x112583ca1,0x31e6f25da53f,0x112583feb,0x112583ca1,0x31e6f25d7289,0x112583feb,0x31e6f25d6c7a,0x31e6f25d6880,0x31e6f6b607cb,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f25d543c,0x31e6f6b7a501,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,JS,10,113312,0x31e6451e427e,52,WeakRefMap node:diagnostics_channel:35:1,0x31e6451e1238,~
code-source-info,0x31e6451e427e,112,734,734,C0O734C5O734C29O734C51O734,,
code-creation,JS,10,113416,0x31e6451e5486,70,channel node:diagnostics_channel:213:17,0x31e6451e1058,~
code-source-info,0x31e6451e5486,112,4551,4801,C0O4578C5O4587C10O4587C16O4600C18O4613C20O4628C21O4632C33O4696C51O4702C56O4696C57O4774C64O4781C69O4799,,
code-creation,JS,10,113466,0x31e6451e55b6,34,get node:diagnostics_channel:45:6,0x31e6451e12d8,~
code-source-info,0x31e6451e55b6,112,980,1025,C0O992C2O1005C13O1005C21O1013C26O1015C33O1021,,
code-creation,JS,10,113504,0x31e6451e5706,36,Channel node:diagnostics_channel:168:14,0x31e6451e16a8,~
code-source-info,0x31e6451e5706,112,3746,3876,C0O3759C1O3777C5O3794C6O3807C10O3824C12O3834C16O3847C23O3856C28O3856C35O3875,,
code-creation,JS,10,113548,0x31e6451e5986,51,set node:diagnostics_channel:40:6,0x31e6451e1288,~
code-source-info,0x31e6451e5986,112,859,973,C0O878C2O883C6O895C11O895C17O921C19O934C28O947C33O943C45O934C50O969,,
code-creation,JS,10,113585,0x31e6451e5aee,37,WeakReference node:internal/util:835:14,0x31e647c44288,~
code-source-info,0x31e6451e5aee,16,23029,23085,C0O23029C14O23044C21O23061C26O23057C31O23055C36O23084,,
code-creation,JS,10,113637,0x31e6451e5d3e,43,SafeWeakRef node:internal/per_context/primordials:447:16,0x31e6931b5068,~
code-source-info,0x31e6451e5d3e,6,12965,12992,C3O12976C27O12976C42O12991,,
code-creation,JS,10,113769,0x31e6451e6b7e,170,getESMFacade node:internal/bootstrap/realm:349:15,0x31e6931b6e50,~
code-source-info,0x31e6451e6b7e,9,11188,11938,C0O11188C8O11206C14O11226C18O11233C19O11261C29O11261C34O11246C39O11379C46O11411C53O11379C58O11445C61O11458C70O11484C72O11484C74O11514C81O11539C86O11514C91O11556C101O11556C106O11604C108O11656C121O11618C126O11616C130O11852C135O11859C140O11859C144O11883C149O11890C159O11890C165O11927C169O11934,,
code-creation,JS,10,113867,0x31e6451e70a6,40, node:internal/bootstrap/realm:360:15,0x31e6451e6a68,~
code-source-info,0x31e6451e70a6,9,11683,11778,C0O11696C5O11704C10O11704C14O11732C24O11753C27O11761C32O11732C39O11777,,
code-creation,JS,10,113914,0x31e6451e71f6,90,syncExports node:internal/bootstrap/realm:374:14,0x31e6931b6ec8,~
code-source-info,0x31e6451e71f6,9,12245,12578,C0O12273C5O12298C11O12327C13O12340C17O12332C22O12382C24O12387C28O12400C30O12415C35O12430C37O12453C42O12460C51O12512C54O12524C59O12550C67O12512C73O12460C79O12349C84O12314C89O12577,,
code-creation,JS,10,113971,0x31e6451e738e,35,getOwn node:internal/bootstrap/realm:204:16,0x31e6931b68b0,~
code-source-info,0x31e6451e738e,9,6427,6581,C0O6463C5O6470C14O6524C26O6524C34O6579,,
tick,0x10c5009c7,114042,0,0x0,0,0x10c66a960,0x31e6451e720e,0x31e6451e70b0,0x10c1c1e90,0x31e6451e6c1d,0x31e6f25d6cbd,0x31e6f25d6880,0x31e6f6b607cb,0x31e6f6b7ce4a,0x31e6f6b7ccbe,0x31e6f25d543c,0x31e6f6b7a501,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
code-creation,Eval,10,114214,0x31e6451e7d1e,5, node:inspector:1:1,0x31e6451e7970,~
script-source,113,node:inspector,'use strict';\n\nconst {\n  JSONParse\x2C\n  JSONStringify\x2C\n  SafeMap\x2C\n  SymbolDispose\x2C\n} = primordials;\n\nconst {\n  ERR_INSPECTOR_ALREADY_ACTIVATED\x2C\n  ERR_INSPECTOR_ALREADY_CONNECTED\x2C\n  ERR_INSPECTOR_CLOSED\x2C\n  ERR_INSPECTOR_COMMAND\x2C\n  ERR_INSPECTOR_NOT_AVAILABLE\x2C\n  ERR_INSPECTOR_NOT_CONNECTED\x2C\n  ERR_INSPECTOR_NOT_ACTIVE\x2C\n  ERR_INSPECTOR_NOT_WORKER\x2C\n} = require('internal/errors').codes;\n\nconst { hasInspector } = internalBinding('config');\nif (!hasInspector)\n  throw new ERR_INSPECTOR_NOT_AVAILABLE();\n\nconst EventEmitter = require('events');\nconst { queueMicrotask } = require('internal/process/task_queues');\nconst {\n  isUint32\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst { isMainThread } = require('worker_threads');\nconst { _debugEnd } = internalBinding('process_methods');\n\nconst {\n  Connection\x2C\n  MainThreadConnection\x2C\n  open\x2C\n  url\x2C\n  isEnabled\x2C\n  waitForDebugger\x2C\n  console\x2C\n} = internalBinding('inspector');\n\nclass Session extends EventEmitter {\n  #connection = null;\n  #nextId = 1;\n  #messageCallbacks = new SafeMap();\n\n  /**\n   * Connects the session to the inspector back-end.\n   * @returns {void}\n   */\n  connect() {\n    if (this.#connection)\n      throw new ERR_INSPECTOR_ALREADY_CONNECTED('The inspector session');\n    this.#connection = new Connection((message) => this.#onMessage(message));\n  }\n\n  /**\n   * Connects the session to the main thread\n   * inspector back-end.\n   * @returns {void}\n   */\n  connectToMainThread() {\n    if (isMainThread)\n      throw new ERR_INSPECTOR_NOT_WORKER();\n    if (this.#connection)\n      throw new ERR_INSPECTOR_ALREADY_CONNECTED('The inspector session');\n    this.#connection =\n      new MainThreadConnection(\n        (message) => queueMicrotask(() => this.#onMessage(message)));\n  }\n\n  #onMessage(message) {\n    const parsed = JSONParse(message);\n    try {\n      if (parsed.id) {\n        const callback = this.#messageCallbacks.get(parsed.id);\n        this.#messageCallbacks.delete(parsed.id);\n        if (callback) {\n          if (parsed.error) {\n            return callback(\n              new ERR_INSPECTOR_COMMAND(parsed.error.code\x2C parsed.error.message)\x2C\n            );\n          }\n\n          callback(null\x2C parsed.result);\n        }\n      } else {\n        this.emit(parsed.method\x2C parsed);\n        this.emit('inspectorNotification'\x2C parsed);\n      }\n    } catch (error) {\n      process.emitWarning(error);\n    }\n  }\n\n  /**\n   * Posts a message to the inspector back-end.\n   * @param {string} method\n   * @param {Record<unknown\x2C unknown>} [params]\n   * @param {Function} [callback]\n   * @returns {void}\n   */\n  post(method\x2C params\x2C callback) {\n    validateString(method\x2C 'method');\n    if (!callback && typeof params === 'function') {\n      callback = params;\n      params = null;\n    }\n    if (params) {\n      validateObject(params\x2C 'params');\n    }\n    if (callback) {\n      validateFunction(callback\x2C 'callback');\n    }\n\n    if (!this.#connection) {\n      throw new ERR_INSPECTOR_NOT_CONNECTED();\n    }\n    const id = this.#nextId++;\n    const message = { id\x2C method };\n    if (params) {\n      message.params = params;\n    }\n    if (callback) {\n      this.#messageCallbacks.set(id\x2C callback);\n    }\n    this.#connection.dispatch(JSONStringify(message));\n  }\n\n  /**\n   * Immediately closes the session\x2C all pending\n   * message callbacks will be called with an\n   * error.\n   * @returns {void}\n   */\n  disconnect() {\n    if (!this.#connection)\n      return;\n    this.#connection.disconnect();\n    this.#connection = null;\n    const remainingCallbacks = this.#messageCallbacks.values();\n    for (const callback of remainingCallbacks) {\n      process.nextTick(callback\x2C new ERR_INSPECTOR_CLOSED());\n    }\n    this.#messageCallbacks.clear();\n    this.#nextId = 1;\n  }\n}\n\n/**\n * Activates inspector on host and port.\n * @param {number} [port]\n * @param {string} [host]\n * @param {boolean} [wait]\n * @returns {void}\n */\nfunction inspectorOpen(port\x2C host\x2C wait) {\n  if (isEnabled()) {\n    throw new ERR_INSPECTOR_ALREADY_ACTIVATED();\n  }\n  // inspectorOpen() currently does not typecheck its arguments and adding\n  // such checks would be a potentially breaking change. However\x2C the native\n  // open() function requires the port to fit into a 16-bit unsigned integer\x2C\n  // causing an integer overflow otherwise\x2C so we at least need to prevent that.\n  if (isUint32(port)) {\n    validateInt32(port\x2C 'port'\x2C 0\x2C 65535);\n  }\n  open(port\x2C host);\n  if (wait)\n    waitForDebugger();\n\n  return { __proto__: null\x2C [SymbolDispose]() { _debugEnd(); } };\n}\n\n/**\n * Blocks until a client (existing or connected later)\n * has sent the `Runtime.runIfWaitingForDebugger`\n * command.\n * @returns {void}\n */\nfunction inspectorWaitForDebugger() {\n  if (!waitForDebugger())\n    throw new ERR_INSPECTOR_NOT_ACTIVE();\n}\n\nmodule.exports = {\n  open: inspectorOpen\x2C\n  close: _debugEnd\x2C\n  url\x2C\n  waitForDebugger: inspectorWaitForDebugger\x2C\n  console\x2C\n  Session\x2C\n};\n
code-source-info,0x31e6451e7d1e,113,0,4958,C0O0C4O4958,,
code-creation,JS,10,114516,0x31e6451e844e,496, node:inspector:1:1,0x31e6451e7c98,~
code-source-info,0x31e6451e844e,113,0,4958,C0O0C91O25C97O38C103O55C109O66C115O348C118O348C123O374C128O109C134O144C140O179C146O203C152O228C157O259C163O290C169O318C175O408C178O408C183O391C188O435C190O456C192O462C197O456C198O519C201O519C206O565C209O565C214O546C220O703C223O703C228O616C234O628C240O648C246O665C252O683C258O760C261O760C266O743C272O809C275O809C280O795C286O954C289O954C294O856C300O870C306O894C312O902C317O909C323O922C329O941C393O1007C447O4819C454O4846C460O4870C466O4883C472O4907C478O4935C484O4946C490O4834C495O4957,,
code-creation,JS,10,114553,0x31e6451e877e,41,<instance_members_initializer> node:inspector:47:1,0x31e6451e7ff8,~
code-source-info,0x31e6451e877e,113,985,3793,C3O1038C12O1056C22O1081C29O1081C40O3793,,
code-creation,JS,10,114713,0x31e6451e958e,159,isAsyncInspectorOpenSupported /Users/peterhage/Applications/WebStorm.app/Contents/plugins/javascript-debugger/debugConnector.js:140:39,0x31e6f6b7a018,~
code-source-info,0x31e6451e958e,81,5028,5384,C3O5062C7O5070C12O5079C17O5084C25O5084C31O5114C36O5131C43O5114C49O5159C55O5176C62O5159C68O5190C70O5203C77O5218C84O5234C87O5239C99O5262C103O5270C116O5322C120O5327C125O5337C129O5345C134O5327C139O5320C143O5276C151O5270C157O5365C158O5378,,
code-creation,JS,10,114789,0x31e6451e984e,86,findAvailablePort /Users/peterhage/Applications/WebStorm.app/Contents/plugins/javascript-debugger/debugConnector.js:153:27,0x31e6f6b7a068,~
code-source-info,0x31e6451e984e,81,5412,6047,C0O5412C8O5477C18O5485C27O5477C32O5545C37O5545C42O5525C47O5557C51O5609C56O5609C60O5628C62O5640C74O5672C79O5672C83O5685C85O5685,,
code-creation,JS,10,114831,0x31e6451e9a0e,14,getBindHost /Users/peterhage/Applications/WebStorm.app/Contents/plugins/javascript-debugger/debugConnector.js:182:21,0x31e6f6b7a0e0,~
code-source-info,0x31e6451e9a0e,81,6171,6224,C0O6178C4O6193C9O6197C13O6222,,
code-creation,JS,10,114901,0x31e6451e9b8e,102,inspectorOpen node:inspector:162:23,0x31e6451e7d50,~
code-source-info,0x31e6451e9b8e,113,3964,4564,C0O3987C5O3991C10O4010C15O4016C20O4010C21O4372C26O4376C32O4398C52O4398C57O4443C62O4443C67O4463C71O4477C76O4477C79O4499C86O4526C90O4525C101O4562,,
code-creation,JS,10,114938,0x31e6451ea356,9,isUint32 node:internal/validators:51:18,0x31e6931bf170,~
code-source-info,0x31e6451ea356,15,963,1008,C0O975C2O999C5O988C8O1006,,
code-creation,JS,10,114985,0x31e6451ea4b6,155, node:internal/validators:114:3,0x31e6931bf260,~
code-source-info,0x31e6451ea4b6,15,2811,3274,C36O2952C42O2991C58O2997C63O2991C64O3056C69O3061C75O3093C91O3099C96O3093C97O3158C99O3168C106O3183C111O3198C121O3237C134O3250C147O3204C152O3198C154O3273,,
tick,0x7ff8092cb5ce,115163,1,0x10c30b370,6,0x10c41e000,0x31e6451e9bcc,0x31e6451e9869,0x31e6f6b7a538,0x31e6f6b785bd,0x31e6f6b735b4,0x31e6f6b7288e,0x31e6f6b60853,0x31e6f6b602e2,0x31e6f6b5e9a1,0x31e6f6b5e745,0x31e6f6b582ae,0x31e63e0bd445,0x31e63e0bb686,0x31e63e0bb024
